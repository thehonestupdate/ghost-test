(function(){"use strict";try{if(typeof document<"u"){var e=document.createElement("style");e.appendChild(document.createTextNode(`@import"https://fonts.bunny.net/css?family=cardo:400,700";@import"https://fonts.bunny.net/css?family=manrope:300,500,700";@import"https://fonts.bunny.net/css?family=merriweather:300,700";@import"https://fonts.bunny.net/css?family=nunito:400,600,700";@import"https://fonts.bunny.net/css?family=old-standard-tt:400,700";@import"https://fonts.bunny.net/css?family=prata:400";@import"https://fonts.bunny.net/css?family=roboto:400,500,700";@import"https://fonts.bunny.net/css?family=rufina:400,500,700";@import"https://fonts.bunny.net/css?family=tenor-sans:400";@import"https://fonts.bunny.net/css?family=space-grotesk:700";@import"https://fonts.bunny.net/css?family=chakra-petch:400";@import"https://fonts.bunny.net/css?family=noto-sans:400,700";@import"https://fonts.bunny.net/css?family=poppins:400,700";@import"https://fonts.bunny.net/css?family=fira-sans:400,700";@import"https://fonts.bunny.net/css?family=inter:400,700";@import"https://fonts.bunny.net/css?family=noto-serif:400,700";@import"https://fonts.bunny.net/css?family=lora:400,700";@import"https://fonts.bunny.net/css?family=ibm-plex-serif:400,700";@import"https://fonts.bunny.net/css?family=space-mono:400,700";@import"https://fonts.bunny.net/css?family=fira-mono:400,700";@import"https://fonts.bunny.net/css?family=jetbrains-mono:400,700";.shade *,.shade :before,.shade :after{box-sizing:border-box;max-width:revert;max-height:revert;min-width:revert;min-height:revert;border-width:0;border-style:solid;border-color:#ebeef0}.shade :before,.shade :after{--tw-content: ""}.shade html{line-height:1.5;-webkit-text-size-adjust:100%;-moz-tab-size:4;-o-tab-size:4;tab-size:4;font-family:Inter,-apple-system,BlinkMacSystemFont,avenir next,avenir,helvetica neue,helvetica,ubuntu,roboto,noto,segoe ui,arial,sans-serif}.shade body{margin:0;line-height:inherit}.shade hr{height:0;color:inherit;border-top-width:1px}.shade abbr:where([title]){-webkit-text-decoration:underline dotted;text-decoration:underline dotted}.shade h1,.shade h2,.shade h3,.shade h4,.shade h5,.shade h6{margin:0;padding:0}.shade a{color:inherit;text-decoration:inherit}.shade b,.shade strong{font-weight:bolder}.shade code,.shade kbd,.shade samp,.shade pre{font-family:Consolas,Liberation Mono,Menlo,Courier,monospace;font-size:1em}.shade small{font-size:80%}.shade sub,.shade sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}.shade sub{bottom:-.25em}.shade sup{top:-.5em}.shade table{text-indent:0;border-color:inherit;border-collapse:collapse;margin:0;width:auto;max-width:auto}.shade table td,.shade table th{padding:unset;vertical-align:middle;text-align:left;line-height:auto;-webkit-user-select:text;-moz-user-select:text;user-select:text}.shade button,.shade input,.shade optgroup,.shade select,.shade textarea{font-family:inherit;font-size:100%;font-weight:inherit;line-height:inherit;color:inherit;margin:0;padding:0;outline:none}.shade button,.shade select{text-transform:none;letter-spacing:inherit;border-radius:inherit;-moz-appearance:auto;appearance:auto;-webkit-appearance:auto;background:unset}.shade button,.shade [type=reset],.shade [type=submit]{-webkit-appearance:button;background-color:transparent;background-image:none}.shade :-moz-focusring{outline:none}.shade :-moz-ui-invalid{box-shadow:none}.shade progress{vertical-align:baseline}.shade ::-webkit-inner-spin-button,.shade ::-webkit-outer-spin-button{height:auto}.shade [type=search]{-webkit-appearance:textfield;outline-offset:-2px}.shade ::-webkit-search-decoration{-webkit-appearance:none}.shade ::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}.shade summary{display:list-item}.shade blockquote,.shade dl,.shade dd,.shade h1,.shade h2,.shade h3,.shade h4,.shade h5,.shade h6,.shade hr,.shade figure,.shade p,.shade pre{margin:0}.shade fieldset{margin:0;padding:0}.shade legend{padding:0}.shade ol,.shade ul,.shade menu{list-style:none;margin:0;padding:0}.shade li{margin:unset;line-height:unset}.shade textarea{resize:vertical}.shade input::-moz-placeholder,.shade textarea::-moz-placeholder{opacity:1;--tw-text-opacity: 1;color:rgb(174 183 193 / var(--tw-text-opacity))}.shade input::placeholder,.shade textarea::placeholder{opacity:1;--tw-text-opacity: 1;color:rgb(174 183 193 / var(--tw-text-opacity))}.shade button:focus-visible,.shade input:focus-visible{outline:none}.shade img,.shade svg,.shade video,.shade canvas,.shade audio,.shade iframe,.shade embed,.shade object{display:block;vertical-align:middle}.shade img,.shade video{max-width:100%;height:auto}*,:before,:after{--tw-border-spacing-x: 0;--tw-border-spacing-y: 0;--tw-translate-x: 0;--tw-translate-y: 0;--tw-rotate: 0;--tw-skew-x: 0;--tw-skew-y: 0;--tw-scale-x: 1;--tw-scale-y: 1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness: proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width: 0px;--tw-ring-offset-color: #fff;--tw-ring-color: rgb(20 184 255 / .5);--tw-ring-offset-shadow: 0 0 #0000;--tw-ring-shadow: 0 0 #0000;--tw-shadow: 0 0 #0000;--tw-shadow-colored: 0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: ;--tw-contain-size: ;--tw-contain-layout: ;--tw-contain-paint: ;--tw-contain-style: }::backdrop{--tw-border-spacing-x: 0;--tw-border-spacing-y: 0;--tw-translate-x: 0;--tw-translate-y: 0;--tw-rotate: 0;--tw-skew-x: 0;--tw-skew-y: 0;--tw-scale-x: 1;--tw-scale-y: 1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness: proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width: 0px;--tw-ring-offset-color: #fff;--tw-ring-color: rgb(20 184 255 / .5);--tw-ring-offset-shadow: 0 0 #0000;--tw-ring-shadow: 0 0 #0000;--tw-shadow: 0 0 #0000;--tw-shadow-colored: 0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: ;--tw-contain-size: ;--tw-contain-layout: ;--tw-contain-paint: ;--tw-contain-style: }:root{--background: 0 0% 100%;--foreground: 216 11% 9%;--muted: 200 12% 96%;--muted-foreground: 211 11% 43%;--popover: 0 0% 100%;--popover-foreground: 216 11% 9%;--border: 204 14% 93%;--input: 204 14% 93%;--card: 0 0% 100%;--card-foreground: 216 11% 9%;--primary: 216 11% 9%;--primary-foreground: 0 0% 100%;--secondary: 204 14% 93%;--secondary-foreground: 216 11% 9%;--accent: 200 12% 96%;--accent-foreground: 216 11% 9%;--destructive: 354 92% 50%;--destructive-foreground: 0 0% 100%;--ring: 215 13% 63%;--radius: 9px;--chart-1: 221.2 83.2% 53.3%;--chart-2: 212 95% 68%;--chart-3: 216 92% 60%;--chart-4: 210 98% 78%;--chart-5: 212 97% 87%;--sidebar-background: 0 0% 100%;--sidebar-foreground: 216 11% 9%;--sidebar-primary: 216 11% 9%;--sidebar-primary-foreground: 0 0% 100%;--sidebar-accent: 200 12% 96%;--sidebar-accent-foreground: 216 11% 9%;--sidebar-border: 210 13% 88%;--sidebar-ring: 215 13% 63%}.dark{--background: 216 11% 9%;--foreground: 210 13% 88%;--muted: 210 11% 25%;--muted-foreground: 210 13% 63%;--accent: 210 11% 25%;--accent-foreground: 200 12% 96%;--popover: 216 11% 9%;--popover-foreground: 212 13% 72%;--border: 210 11% 25%;--input: 210 11% 25%;--card: 216 11% 9%;--card-foreground: 213 31% 91%;--primary: 200 12% 96%;--primary-foreground: 216 11% 9%;--secondary: 216 11% 9%;--secondary-foreground: 200 12% 96%;--destructive: 354 81% 31%;--destructive-foreground: 240 11% 98%;--ring: 210 11% 25%;--chart-1: 221.2 83.2% 53.3%;--chart-2: 212 95% 68%;--chart-3: 216 92% 60%;--chart-4: 210 98% 78%;--chart-5: 212 97% 87%;--sidebar-background: 216 11% 9%;--sidebar-foreground: 200 12% 96%;--sidebar-primary: 210 11% 25%;--sidebar-primary-foreground: 0 0% 100%;--sidebar-accent: 210 11% 25%;--sidebar-accent-foreground: 200 12% 96%;--sidebar-border: 210 11% 25%;--sidebar-ring: 210 13% 55%}@font-face{font-family:Inter;src:local("Inter") format("truetype-variations");font-weight:100 900}.shade{font-family:Inter,-apple-system,BlinkMacSystemFont,avenir next,avenir,helvetica neue,helvetica,ubuntu,roboto,noto,segoe ui,arial,sans-serif;font-size:1.4rem;line-height:1.5;--tw-text-opacity: 1;color:rgb(21 23 26 / var(--tw-text-opacity))}body{background-color:hsl(var(--background));font-family:Inter,-apple-system,BlinkMacSystemFont,avenir next,avenir,helvetica neue,helvetica,ubuntu,roboto,noto,segoe ui,arial,sans-serif;color:hsl(var(--foreground));-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}*{border-color:hsl(var(--border))}body{background-color:hsl(var(--background));color:hsl(var(--foreground))}.shade .sr-only{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);white-space:nowrap;border-width:0}.shade .pointer-events-none{pointer-events:none}.shade .fixed{position:fixed}.shade .absolute{position:absolute}.shade .relative{position:relative}.shade .inset-0{inset:0px}.shade .inset-x-0{left:0px;right:0px}.shade .inset-y-0{top:0px;bottom:0px}.shade .bottom-0{bottom:0px}.shade .left-0{left:0px}.shade .left-2{left:.8rem}.shade .left-\\[50\\%\\]{left:50%}.shade .right-0{right:0px}.shade .right-1{right:.4rem}.shade .right-2{right:.8rem}.shade .right-3{right:1.2rem}.shade .right-4{right:1.6rem}.shade .top-0{top:0px}.shade .top-1\\.5{top:.6rem}.shade .top-3\\.5{top:1.4rem}.shade .top-4{top:1.6rem}.shade .top-\\[50\\%\\]{top:50%}.shade .top-\\[8vmin\\]{top:8vmin}.shade .z-10{z-index:10}.shade .z-20{z-index:20}.shade .z-50{z-index:50}.shade .-mx-1{margin-left:-.4rem;margin-right:-.4rem}.shade .mx-2{margin-left:.8rem;margin-right:.8rem}.shade .mx-3\\.5{margin-left:1.4rem;margin-right:1.4rem}.shade .mx-auto{margin-left:auto;margin-right:auto}.shade .my-0\\.5{margin-top:.2rem;margin-bottom:.2rem}.shade .my-1{margin-top:.4rem;margin-bottom:.4rem}.shade .ml-auto{margin-left:auto}.shade .mt-2{margin-top:.8rem}.shade .mt-4{margin-top:1.6rem}.shade .block{display:block}.shade .flex{display:flex}.shade .inline-flex{display:inline-flex}.shade .table{display:table}.shade .grid{display:grid}.shade .hidden{display:none}.shade .aspect-square{aspect-ratio:1 / 1}.shade .aspect-video{aspect-ratio:16 / 9}.shade .size-4{width:1.6rem;height:1.6rem}.shade .h-10{height:4rem}.shade .h-11{height:4.4rem}.shade .h-12{height:4.8rem}.shade .h-2{height:.8rem}.shade .h-2\\.5{height:1rem}.shade .h-3{height:1.2rem}.shade .h-3\\.5{height:1.4rem}.shade .h-4{height:1.6rem}.shade .h-5{height:2rem}.shade .h-6{height:2.4rem}.shade .h-7{height:2.8rem}.shade .h-8{height:3.2rem}.shade .h-9{height:3.6rem}.shade .h-\\[102px\\]{height:102px}.shade .h-\\[1px\\]{height:1px}.shade .h-\\[34px\\]{height:34px}.shade .h-full{height:100%}.shade .h-px{height:1px}.shade .h-screen{height:100vh}.shade .h-svh{height:100svh}.shade .min-h-0{min-height:0px}.shade .min-h-full{min-height:100%}.shade .min-h-svh{min-height:100svh}.shade .w-0{width:0px}.shade .w-1{width:.4rem}.shade .w-2{width:.8rem}.shade .w-2\\.5{width:1rem}.shade .w-3{width:1.2rem}.shade .w-3\\.5{width:1.4rem}.shade .w-3\\/4{width:75%}.shade .w-4{width:1.6rem}.shade .w-5{width:2rem}.shade .w-6{width:2.4rem}.shade .w-7{width:2.8rem}.shade .w-8{width:3.2rem}.shade .w-9{width:3.6rem}.shade .w-\\[--sidebar-width\\]{width:var(--sidebar-width)}.shade .w-\\[1px\\]{width:1px}.shade .w-auto{width:auto}.shade .w-full{width:100%}.shade .min-w-0{min-width:0px}.shade .min-w-5{min-width:2rem}.shade .min-w-\\[8rem\\]{min-width:8rem}.shade .max-w-\\[--skeleton-width\\]{max-width:var(--skeleton-width)}.shade .max-w-lg{max-width:51.2rem}.shade .max-w-page{max-width:148rem}.shade .flex-1{flex:1 1 0%}.shade .shrink-0{flex-shrink:0}.shade .grow{flex-grow:1}.shade .caption-bottom{caption-side:bottom}.shade .-translate-x-1\\/2{--tw-translate-x: -50%;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.shade .-translate-x-px{--tw-translate-x: -1px;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.shade .translate-x-\\[-50\\%\\]{--tw-translate-x: -50%;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.shade .translate-x-px{--tw-translate-x: 1px;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.shade .translate-y-\\[-50\\%\\]{--tw-translate-y: -50%;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.shade .transform{transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.shade .transform-gpu{transform:translate3d(var(--tw-translate-x),var(--tw-translate-y),0) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}@keyframes pulse{50%{opacity:.5}}.shade .animate-pulse{animation:pulse 2s cubic-bezier(.4,0,.6,1) infinite}.shade .cursor-default{cursor:default}.shade .select-none{-webkit-user-select:none;-moz-user-select:none;user-select:none}.shade .scroll-m-20{scroll-margin:8rem}.shade .flex-col{flex-direction:column}.shade .flex-col-reverse{flex-direction:column-reverse}.shade .flex-wrap{flex-wrap:wrap}.shade .items-start{align-items:flex-start}.shade .items-end{align-items:flex-end}.shade .items-center{align-items:center}.shade .items-stretch{align-items:stretch}.shade .justify-center{justify-content:center}.shade .justify-between{justify-content:space-between}.shade .gap-1\\.5{gap:.6rem}.shade .gap-2{gap:.8rem}.shade .gap-4{gap:1.6rem}.shade .gap-5{gap:2rem}.shade .gap-6{gap:2.4rem}.shade .gap-7{gap:2.8rem}.shade .gap-px{gap:1px}.shade :is(.space-y-1\\.5>:not([hidden])~:not([hidden])){--tw-space-y-reverse: 0;margin-top:calc(.6rem * calc(1 - var(--tw-space-y-reverse)));margin-bottom:calc(.6rem * var(--tw-space-y-reverse))}.shade :is(.space-y-2>:not([hidden])~:not([hidden])){--tw-space-y-reverse: 0;margin-top:calc(.8rem * calc(1 - var(--tw-space-y-reverse)));margin-bottom:calc(.8rem * var(--tw-space-y-reverse))}.shade .overflow-auto{overflow:auto}.shade .overflow-hidden{overflow:hidden}.shade .whitespace-nowrap{white-space:nowrap}.shade .break-words{overflow-wrap:break-word}.shade .rounded-\\[2px\\]{border-radius:2px}.shade .rounded-full{border-radius:9999px}.shade .rounded-lg{border-radius:var(--radius)}.shade .rounded-md{border-radius:calc(var(--radius) - 2px)}.shade .rounded-sm{border-radius:calc(var(--radius) - 4px)}.shade .rounded-xl{border-radius:1.2rem}.shade .border{border-width:1px}.shade .border-\\[1\\.5px\\]{border-width:1.5px}.shade .border-b{border-bottom-width:1px}.shade .border-l{border-left-width:1px}.shade .border-r{border-right-width:1px}.shade .border-t{border-top-width:1px}.shade .border-dashed{border-style:dashed}.shade .border-\\[--color-border\\]{border-color:var(--color-border)}.shade .border-border\\/50{border-color:hsl(var(--border) / .5)}.shade .border-input{border-color:hsl(var(--input))}.shade .border-sidebar-border{border-color:hsl(var(--sidebar-border))}.shade .border-transparent{border-color:transparent}.shade .bg-\\[--color-bg\\]{background-color:var(--color-bg)}.shade .bg-background{background-color:hsl(var(--background))}.shade .bg-black\\/30{background-color:#15171a4d}.shade .bg-black\\/80{background-color:#15171acc}.shade .bg-border{background-color:hsl(var(--border))}.shade .bg-card{background-color:hsl(var(--card))}.shade .bg-destructive{background-color:hsl(var(--destructive))}.shade .bg-destructive\\/20{background-color:hsl(var(--destructive) / .2)}.shade .bg-green\\/20{background-color:#30cf4333}.shade .bg-muted{background-color:hsl(var(--muted))}.shade .bg-muted\\/50{background-color:hsl(var(--muted) / .5)}.shade .bg-popover{background-color:hsl(var(--popover))}.shade .bg-primary{background-color:hsl(var(--primary))}.shade .bg-primary\\/10{background-color:hsl(var(--primary) / .1)}.shade .bg-secondary{background-color:hsl(var(--secondary))}.shade .bg-sidebar{background-color:hsl(var(--sidebar-background))}.shade .bg-sidebar-border{background-color:hsl(var(--sidebar-border))}.shade .bg-transparent{background-color:transparent}.shade .bg-white{--tw-bg-opacity: 1;background-color:rgb(255 255 255 / var(--tw-bg-opacity))}.shade .fill-current{fill:currentColor}.shade .p-0{padding:0}.shade .p-1{padding:.4rem}.shade .p-2{padding:.8rem}.shade .p-5{padding:2rem}.shade .p-6{padding:2.4rem}.shade .px-0{padding-left:0;padding-right:0}.shade .px-1{padding-left:.4rem;padding-right:.4rem}.shade .px-1\\.5{padding-left:.6rem;padding-right:.6rem}.shade .px-2{padding-left:.8rem;padding-right:.8rem}.shade .px-2\\.5{padding-left:1rem;padding-right:1rem}.shade .px-3{padding-left:1.2rem;padding-right:1.2rem}.shade .px-6{padding-left:2.4rem;padding-right:2.4rem}.shade .px-8{padding-left:3.2rem;padding-right:3.2rem}.shade .px-\\[3px\\]{padding-left:3px;padding-right:3px}.shade .py-0\\.5{padding-top:.2rem;padding-bottom:.2rem}.shade .py-1{padding-top:.4rem;padding-bottom:.4rem}.shade .py-1\\.5{padding-top:.6rem;padding-bottom:.6rem}.shade .py-2{padding-top:.8rem;padding-bottom:.8rem}.shade .py-5{padding-top:2rem;padding-bottom:2rem}.shade .pb-1{padding-bottom:.4rem}.shade .pb-3{padding-bottom:1.2rem}.shade .pl-8{padding-left:3.2rem}.shade .pr-2{padding-right:.8rem}.shade .pt-0{padding-top:0}.shade .pt-3{padding-top:1.2rem}.shade .text-left{text-align:left}.shade .text-center{text-align:center}.shade .align-middle{vertical-align:middle}.shade .font-mono{font-family:Consolas,Liberation Mono,Menlo,Courier,monospace}.shade .text-2xl{font-size:2.2rem}.shade .text-3xl{font-size:2.7rem}.shade .text-base{font-size:1.4rem}.shade .text-lg{font-size:1.5rem}.shade .text-md{font-size:1.4rem}.shade .text-sm{font-size:1.3rem}.shade .text-xl{font-size:1.7rem}.shade .text-xs{font-size:1.2rem}.shade .font-bold{font-weight:700}.shade .font-medium{font-weight:500}.shade .font-normal{font-weight:400}.shade .font-semibold{font-weight:600}.shade .tabular-nums{--tw-numeric-spacing: tabular-nums;font-variant-numeric:var(--tw-ordinal) var(--tw-slashed-zero) var(--tw-numeric-figure) var(--tw-numeric-spacing) var(--tw-numeric-fraction)}.shade .leading-none{line-height:1}.shade .leading-supertight{line-height:1.1em}.shade .tracking-tight{letter-spacing:-.01em}.shade .tracking-wider{letter-spacing:.025em}.shade .text-black{--tw-text-opacity: 1;color:rgb(21 23 26 / var(--tw-text-opacity))}.shade .text-card-foreground{color:hsl(var(--card-foreground))}.shade .text-destructive{color:hsl(var(--destructive))}.shade .text-destructive-foreground{color:hsl(var(--destructive-foreground))}.shade .text-foreground{color:hsl(var(--foreground))}.shade .text-gray-600{--tw-text-opacity: 1;color:rgb(149 161 173 / var(--tw-text-opacity))}.shade .text-gray-700{--tw-text-opacity: 1;color:rgb(124 139 154 / var(--tw-text-opacity))}.shade .text-gray-800{--tw-text-opacity: 1;color:rgb(98 109 121 / var(--tw-text-opacity))}.shade .text-green{--tw-text-opacity: 1;color:rgb(48 207 67 / var(--tw-text-opacity))}.shade .text-muted-foreground{color:hsl(var(--muted-foreground))}.shade .text-popover-foreground{color:hsl(var(--popover-foreground))}.shade .text-primary{color:hsl(var(--primary))}.shade .text-primary-foreground{color:hsl(var(--primary-foreground))}.shade .text-secondary-foreground{color:hsl(var(--secondary-foreground))}.shade .text-secondary-foreground\\/70{color:hsl(var(--secondary-foreground) / .7)}.shade .text-sidebar-foreground{color:hsl(var(--sidebar-foreground))}.shade .text-sidebar-foreground\\/70{color:hsl(var(--sidebar-foreground) / .7)}.shade .underline{text-decoration-line:underline}.shade .underline-offset-4{text-underline-offset:4px}.shade .opacity-60{opacity:.6}.shade .opacity-70{opacity:.7}.shade .shadow-\\[0_0_0_1px_hsl\\(var\\(--sidebar-border\\)\\)\\]{--tw-shadow: 0 0 0 1px hsl(var(--sidebar-border));--tw-shadow-colored: 0 0 0 1px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000),var(--tw-ring-shadow, 0 0 #0000),var(--tw-shadow)}.shade .shadow-lg{--tw-shadow: 0 0 7px rgba(0, 0, 0, .08), 0 2.1px 2.2px -5px rgba(0, 0, 0, .011), 0 5.1px 5.3px -5px rgba(0, 0, 0, .016), 0 9.5px 10px -5px rgba(0, 0, 0, .02), 0 17px 17.9px -5px rgba(0, 0, 0, .024), 0 31.8px 33.4px -5px rgba(0, 0, 0, .029), 0 76px 80px -5px rgba(0, 0, 0, .04);--tw-shadow-colored: 0 0 7px var(--tw-shadow-color), 0 2.1px 2.2px -5px var(--tw-shadow-color), 0 5.1px 5.3px -5px var(--tw-shadow-color), 0 9.5px 10px -5px var(--tw-shadow-color), 0 17px 17.9px -5px var(--tw-shadow-color), 0 31.8px 33.4px -5px var(--tw-shadow-color), 0 76px 80px -5px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000),var(--tw-ring-shadow, 0 0 #0000),var(--tw-shadow)}.shade .shadow-md{--tw-shadow: 0 0 1px rgba(0,0,0,.12), 0 1px 6px rgba(0,0,0,.03), 0 8px 10px -8px rgba(0,0,0,.05), 0px 24px 37px -21px rgba(0, 0, 0, .05);--tw-shadow-colored: 0 0 1px var(--tw-shadow-color), 0 1px 6px var(--tw-shadow-color), 0 8px 10px -8px var(--tw-shadow-color), 0px 24px 37px -21px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000),var(--tw-ring-shadow, 0 0 #0000),var(--tw-shadow)}.shade .shadow-none{--tw-shadow: 0 0 #0000;--tw-shadow-colored: 0 0 var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000),var(--tw-ring-shadow, 0 0 #0000),var(--tw-shadow)}.shade .shadow-sm{--tw-shadow: 0 0 1px rgba(0,0,0,.12), 0 1px 6px rgba(0,0,0,.03), 0 8px 10px -8px rgba(0,0,0,.1);--tw-shadow-colored: 0 0 1px var(--tw-shadow-color), 0 1px 6px var(--tw-shadow-color), 0 8px 10px -8px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000),var(--tw-ring-shadow, 0 0 #0000),var(--tw-shadow)}.shade .shadow-xl{--tw-shadow: 0 2.8px 2.2px rgba(0, 0, 0, .02), 0 6.7px 5.3px rgba(0, 0, 0, .028), 0 12.5px 10px rgba(0, 0, 0, .035), 0 22.3px 17.9px rgba(0, 0, 0, .042), 0 41.8px 33.4px rgba(0, 0, 0, .05), 0 100px 80px rgba(0, 0, 0, .07);--tw-shadow-colored: 0 2.8px 2.2px var(--tw-shadow-color), 0 6.7px 5.3px var(--tw-shadow-color), 0 12.5px 10px var(--tw-shadow-color), 0 22.3px 17.9px var(--tw-shadow-color), 0 41.8px 33.4px var(--tw-shadow-color), 0 100px 80px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000),var(--tw-ring-shadow, 0 0 #0000),var(--tw-shadow)}.shade .outline-none{outline:2px solid transparent;outline-offset:2px}.shade .outline{outline-style:solid}.shade .ring-sidebar-ring{--tw-ring-color: hsl(var(--sidebar-ring))}.shade .ring-offset-background{--tw-ring-offset-color: hsl(var(--background))}.shade .filter{filter:var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow)}.shade .backdrop-blur-none{--tw-backdrop-blur: ;-webkit-backdrop-filter:var(--tw-backdrop-blur) var(--tw-backdrop-brightness) var(--tw-backdrop-contrast) var(--tw-backdrop-grayscale) var(--tw-backdrop-hue-rotate) var(--tw-backdrop-invert) var(--tw-backdrop-opacity) var(--tw-backdrop-saturate) var(--tw-backdrop-sepia);backdrop-filter:var(--tw-backdrop-blur) var(--tw-backdrop-brightness) var(--tw-backdrop-contrast) var(--tw-backdrop-grayscale) var(--tw-backdrop-hue-rotate) var(--tw-backdrop-invert) var(--tw-backdrop-opacity) var(--tw-backdrop-saturate) var(--tw-backdrop-sepia)}.shade .transition{transition-property:color,background-color,border-color,text-decoration-color,fill,stroke,opacity,box-shadow,transform,filter,-webkit-backdrop-filter;transition-property:color,background-color,border-color,text-decoration-color,fill,stroke,opacity,box-shadow,transform,filter,backdrop-filter;transition-property:color,background-color,border-color,text-decoration-color,fill,stroke,opacity,box-shadow,transform,filter,backdrop-filter,-webkit-backdrop-filter;transition-timing-function:cubic-bezier(.4,0,.2,1);transition-duration:.15s}.shade .transition-\\[left\\,right\\,width\\]{transition-property:left,right,width;transition-timing-function:cubic-bezier(.4,0,.2,1);transition-duration:.15s}.shade .transition-\\[margin\\,opa\\]{transition-property:margin,opa;transition-timing-function:cubic-bezier(.4,0,.2,1);transition-duration:.15s}.shade .transition-\\[width\\,height\\,padding\\]{transition-property:width,height,padding;transition-timing-function:cubic-bezier(.4,0,.2,1);transition-duration:.15s}.shade .transition-\\[width\\]{transition-property:width;transition-timing-function:cubic-bezier(.4,0,.2,1);transition-duration:.15s}.shade .transition-all{transition-property:all;transition-timing-function:cubic-bezier(.4,0,.2,1);transition-duration:.15s}.shade .transition-colors{transition-property:color,background-color,border-color,text-decoration-color,fill,stroke;transition-timing-function:cubic-bezier(.4,0,.2,1);transition-duration:.15s}.shade .transition-opacity{transition-property:opacity;transition-timing-function:cubic-bezier(.4,0,.2,1);transition-duration:.15s}.shade .transition-transform{transition-property:transform;transition-timing-function:cubic-bezier(.4,0,.2,1);transition-duration:.15s}.shade .duration-200{transition-duration:.2s}.shade .ease-in-out{transition-timing-function:cubic-bezier(.4,0,.2,1)}.shade .ease-linear{transition-timing-function:linear}@keyframes enter{0%{opacity:var(--tw-enter-opacity, 1);transform:translate3d(var(--tw-enter-translate-x, 0),var(--tw-enter-translate-y, 0),0) scale3d(var(--tw-enter-scale, 1),var(--tw-enter-scale, 1),var(--tw-enter-scale, 1)) rotate(var(--tw-enter-rotate, 0))}}@keyframes exit{to{opacity:var(--tw-exit-opacity, 1);transform:translate3d(var(--tw-exit-translate-x, 0),var(--tw-exit-translate-y, 0),0) scale3d(var(--tw-exit-scale, 1),var(--tw-exit-scale, 1),var(--tw-exit-scale, 1)) rotate(var(--tw-exit-rotate, 0))}}.shade .animate-in{animation-name:enter;animation-duration:.15s;--tw-enter-opacity: initial;--tw-enter-scale: initial;--tw-enter-rotate: initial;--tw-enter-translate-x: initial;--tw-enter-translate-y: initial}.shade .fade-in-0{--tw-enter-opacity: 0}.shade .zoom-in-95{--tw-enter-scale: .95}.shade .duration-200{animation-duration:.2s}.shade .ease-in-out{animation-timing-function:cubic-bezier(.4,0,.2,1)}.shade .ease-linear{animation-timing-function:linear}.shade{line-height:1.5;-ms-text-size-adjust:100%;text-rendering:optimizeLegibility;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;-webkit-text-size-adjust:100%;letter-spacing:unset;height:100vh;width:100%;overflow-x:hidden;overflow-y:auto}@media (max-width: 800px){.shade{height:calc(100vh - 55px)}}.dark .shade{color:#fafafb}.dark .shade .gh-loading-orb-container{background-color:#000}.dark .shade .gh-loading-orb{filter:invert(100%)}.shade .no-scrollbar::-webkit-scrollbar{display:none}.shade .no-scrollbar{-ms-overflow-style:none;scrollbar-width:none}.gh-prose-links a{color:#30cf43}.admin-x-base.shade{animation-name:none}.shade .file\\:border-0::file-selector-button{border-width:0px}.shade .file\\:bg-transparent::file-selector-button{background-color:transparent}.shade .file\\:text-sm::file-selector-button{font-size:1.3rem}.shade .file\\:font-medium::file-selector-button{font-weight:500}.shade .file\\:text-foreground::file-selector-button{color:hsl(var(--foreground))}.shade .placeholder\\:text-muted-foreground::-moz-placeholder{color:hsl(var(--muted-foreground))}.shade .placeholder\\:text-muted-foreground::placeholder{color:hsl(var(--muted-foreground))}.shade .before\\:absolute:before{content:var(--tw-content);position:absolute}.shade .before\\:-inset-x-2:before{content:var(--tw-content);left:-.8rem;right:-.8rem}.shade .before\\:-inset-y-px:before{content:var(--tw-content);top:-1px;bottom:-1px}.shade .before\\:rounded-md:before{content:var(--tw-content);border-radius:calc(var(--radius) - 2px)}.shade .before\\:content-\\[\\"\\"\\]:before{--tw-content: "";content:var(--tw-content)}.shade .after\\:absolute:after{content:var(--tw-content);position:absolute}.shade .after\\:-inset-2:after{content:var(--tw-content);inset:-.8rem}.shade .after\\:inset-y-0:after{content:var(--tw-content);top:0px;bottom:0px}.shade .after\\:left-1\\/2:after{content:var(--tw-content);left:50%}.shade .after\\:w-\\[2px\\]:after{content:var(--tw-content);width:2px}.shade .first\\:mt-0:first-child{margin-top:0}.shade .first-of-type\\:pl-0:first-of-type{padding-left:0}.shade .last-of-type\\:pr-0:last-of-type{padding-right:0}.shade .hover\\:border-transparent:hover{border-color:transparent}.shade .hover\\:bg-accent:hover{background-color:hsl(var(--accent))}.shade .hover\\:bg-destructive\\/90:hover{background-color:hsl(var(--destructive) / .9)}.shade .hover\\:bg-muted\\/50:hover{background-color:hsl(var(--muted) / .5)}.shade .hover\\:bg-primary\\/90:hover{background-color:hsl(var(--primary) / .9)}.shade .hover\\:bg-secondary\\/80:hover{background-color:hsl(var(--secondary) / .8)}.shade .hover\\:bg-sidebar-accent:hover{background-color:hsl(var(--sidebar-accent))}.shade .hover\\:text-accent-foreground:hover{color:hsl(var(--accent-foreground))}.shade .hover\\:text-foreground:hover{color:hsl(var(--foreground))}.shade .hover\\:text-sidebar-accent-foreground:hover{color:hsl(var(--sidebar-accent-foreground))}.shade .hover\\:underline:hover{text-decoration-line:underline}.shade .hover\\:opacity-100:hover{opacity:1}.shade .hover\\:shadow-\\[0_0_0_1px_hsl\\(var\\(--sidebar-accent\\)\\)\\]:hover{--tw-shadow: 0 0 0 1px hsl(var(--sidebar-accent));--tw-shadow-colored: 0 0 0 1px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000),var(--tw-ring-shadow, 0 0 #0000),var(--tw-shadow)}.shade .hover\\:before\\:bg-muted\\/50:hover:before{content:var(--tw-content);background-color:hsl(var(--muted) / .5)}.shade .hover\\:after\\:bg-sidebar-border:hover:after{content:var(--tw-content);background-color:hsl(var(--sidebar-border))}.shade .focus\\:bg-accent:focus{background-color:hsl(var(--accent))}.shade .focus\\:text-accent-foreground:focus{color:hsl(var(--accent-foreground))}.shade .focus\\:outline-none:focus{outline:2px solid transparent;outline-offset:2px}.shade .focus\\:ring-2:focus{--tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);--tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(2px + var(--tw-ring-offset-width)) var(--tw-ring-color);box-shadow:var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow, 0 0 #0000)}.shade .focus\\:ring-ring:focus{--tw-ring-color: hsl(var(--ring))}.shade .focus\\:ring-offset-2:focus{--tw-ring-offset-width: 2px}.shade .focus-visible\\:outline-none:focus-visible{outline:2px solid transparent;outline-offset:2px}.shade .focus-visible\\:ring-1:focus-visible{--tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);--tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(1px + var(--tw-ring-offset-width)) var(--tw-ring-color);box-shadow:var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow, 0 0 #0000)}.shade .focus-visible\\:ring-2:focus-visible{--tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);--tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(2px + var(--tw-ring-offset-width)) var(--tw-ring-color);box-shadow:var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow, 0 0 #0000)}.shade .focus-visible\\:ring-ring:focus-visible{--tw-ring-color: hsl(var(--ring))}.shade .focus-visible\\:ring-sidebar-ring:focus-visible{--tw-ring-color: hsl(var(--sidebar-ring))}.shade .focus-visible\\:ring-offset-2:focus-visible{--tw-ring-offset-width: 2px}.shade .active\\:bg-sidebar-accent:active{background-color:hsl(var(--sidebar-accent))}.shade .active\\:text-sidebar-accent-foreground:active{color:hsl(var(--sidebar-accent-foreground))}.shade .disabled\\:pointer-events-none:disabled{pointer-events:none}.shade .disabled\\:cursor-not-allowed:disabled{cursor:not-allowed}.shade .disabled\\:opacity-50:disabled{opacity:.5}.shade :is(.group\\/menu-item:focus-within .group-focus-within\\/menu-item\\:opacity-100){opacity:1}.shade :is(.group\\/menu-item:hover .group-hover\\/menu-item\\:opacity-100){opacity:1}.shade :is(.peer\\/menu-button:hover~.peer-hover\\/menu-button\\:text-sidebar-accent-foreground){color:hsl(var(--sidebar-accent-foreground))}.shade .has-\\[\\[data-variant\\=inset\\]\\]\\:bg-sidebar:has([data-variant=inset]){background-color:hsl(var(--sidebar-background))}.shade :is(.group\\/menu-item:has([data-sidebar=menu-action]) .group-has-\\[\\[data-sidebar\\=menu-action\\]\\]\\/menu-item\\:pr-8){padding-right:3.2rem}.shade .aria-disabled\\:pointer-events-none[aria-disabled=true]{pointer-events:none}.shade .aria-disabled\\:opacity-50[aria-disabled=true]{opacity:.5}.shade .data-\\[disabled\\]\\:pointer-events-none[data-disabled]{pointer-events:none}.shade .data-\\[active\\=true\\]\\:bg-sidebar-accent[data-active=true]{background-color:hsl(var(--sidebar-accent))}.shade .data-\\[state\\=active\\]\\:bg-background[data-state=active]{background-color:hsl(var(--background))}.shade .data-\\[state\\=active\\]\\:bg-muted\\/70[data-state=active]{background-color:hsl(var(--muted) / .7)}.shade .data-\\[state\\=open\\]\\:bg-accent[data-state=open]{background-color:hsl(var(--accent))}.shade .data-\\[state\\=open\\]\\:bg-secondary[data-state=open]{background-color:hsl(var(--secondary))}.shade .data-\\[state\\=selected\\]\\:bg-muted[data-state=selected]{background-color:hsl(var(--muted))}.shade .data-\\[active\\=true\\]\\:font-semibold[data-active=true],.shade .data-\\[state\\=active\\]\\:font-semibold[data-state=active]{font-weight:600}.shade .data-\\[active\\=true\\]\\:text-sidebar-accent-foreground[data-active=true]{color:hsl(var(--sidebar-accent-foreground))}.shade .data-\\[state\\=active\\]\\:text-black[data-state=active]{--tw-text-opacity: 1;color:rgb(21 23 26 / var(--tw-text-opacity))}.shade .data-\\[state\\=active\\]\\:text-foreground[data-state=active]{color:hsl(var(--foreground))}.shade .data-\\[disabled\\]\\:opacity-50[data-disabled]{opacity:.5}.shade .data-\\[state\\=open\\]\\:opacity-100[data-state=open]{opacity:1}.shade .data-\\[state\\=active\\]\\:shadow-md[data-state=active]{--tw-shadow: 0 0 1px rgba(0,0,0,.12), 0 1px 6px rgba(0,0,0,.03), 0 8px 10px -8px rgba(0,0,0,.05), 0px 24px 37px -21px rgba(0, 0, 0, .05);--tw-shadow-colored: 0 0 1px var(--tw-shadow-color), 0 1px 6px var(--tw-shadow-color), 0 8px 10px -8px var(--tw-shadow-color), 0px 24px 37px -21px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000),var(--tw-ring-shadow, 0 0 #0000),var(--tw-shadow)}.shade .data-\\[state\\=open\\]\\:backdrop-blur-\\[3px\\][data-state=open]{--tw-backdrop-blur: blur(3px);-webkit-backdrop-filter:var(--tw-backdrop-blur) var(--tw-backdrop-brightness) var(--tw-backdrop-contrast) var(--tw-backdrop-grayscale) var(--tw-backdrop-hue-rotate) var(--tw-backdrop-invert) var(--tw-backdrop-opacity) var(--tw-backdrop-saturate) var(--tw-backdrop-sepia);backdrop-filter:var(--tw-backdrop-blur) var(--tw-backdrop-brightness) var(--tw-backdrop-contrast) var(--tw-backdrop-grayscale) var(--tw-backdrop-hue-rotate) var(--tw-backdrop-invert) var(--tw-backdrop-opacity) var(--tw-backdrop-saturate) var(--tw-backdrop-sepia)}.shade .data-\\[state\\=closed\\]\\:duration-300[data-state=closed]{transition-duration:.3s}.shade .data-\\[state\\=open\\]\\:duration-500[data-state=open]{transition-duration:.5s}.shade .data-\\[state\\=open\\]\\:animate-in[data-state=open]{animation-name:enter;animation-duration:.15s;--tw-enter-opacity: initial;--tw-enter-scale: initial;--tw-enter-rotate: initial;--tw-enter-translate-x: initial;--tw-enter-translate-y: initial}.shade .data-\\[state\\=closed\\]\\:animate-out[data-state=closed]{animation-name:exit;animation-duration:.15s;--tw-exit-opacity: initial;--tw-exit-scale: initial;--tw-exit-rotate: initial;--tw-exit-translate-x: initial;--tw-exit-translate-y: initial}.shade .data-\\[state\\=closed\\]\\:fade-out-0[data-state=closed]{--tw-exit-opacity: 0}.shade .data-\\[state\\=open\\]\\:fade-in-0[data-state=open]{--tw-enter-opacity: 0}.shade .data-\\[state\\=closed\\]\\:zoom-out-95[data-state=closed]{--tw-exit-scale: .95}.shade .data-\\[state\\=open\\]\\:zoom-in-95[data-state=open]{--tw-enter-scale: .95}.shade .data-\\[side\\=bottom\\]\\:slide-in-from-top-2[data-side=bottom]{--tw-enter-translate-y: -.8rem}.shade .data-\\[side\\=left\\]\\:slide-in-from-right-2[data-side=left]{--tw-enter-translate-x: .8rem}.shade .data-\\[side\\=right\\]\\:slide-in-from-left-2[data-side=right]{--tw-enter-translate-x: -.8rem}.shade .data-\\[side\\=top\\]\\:slide-in-from-bottom-2[data-side=top]{--tw-enter-translate-y: .8rem}.shade .data-\\[state\\=closed\\]\\:slide-out-to-bottom[data-state=closed]{--tw-exit-translate-y: 100%}.shade .data-\\[state\\=closed\\]\\:slide-out-to-left[data-state=closed]{--tw-exit-translate-x: -100%}.shade .data-\\[state\\=closed\\]\\:slide-out-to-left-1\\/2[data-state=closed]{--tw-exit-translate-x: -50%}.shade .data-\\[state\\=closed\\]\\:slide-out-to-right[data-state=closed]{--tw-exit-translate-x: 100%}.shade .data-\\[state\\=closed\\]\\:slide-out-to-top[data-state=closed]{--tw-exit-translate-y: -100%}.shade .data-\\[state\\=closed\\]\\:slide-out-to-top-\\[48\\%\\][data-state=closed]{--tw-exit-translate-y: -48%}.shade .data-\\[state\\=open\\]\\:slide-in-from-bottom[data-state=open]{--tw-enter-translate-y: 100%}.shade .data-\\[state\\=open\\]\\:slide-in-from-left[data-state=open]{--tw-enter-translate-x: -100%}.shade .data-\\[state\\=open\\]\\:slide-in-from-left-1\\/2[data-state=open]{--tw-enter-translate-x: -50%}.shade .data-\\[state\\=open\\]\\:slide-in-from-right[data-state=open]{--tw-enter-translate-x: 100%}.shade .data-\\[state\\=open\\]\\:slide-in-from-top[data-state=open]{--tw-enter-translate-y: -100%}.shade .data-\\[state\\=open\\]\\:slide-in-from-top-\\[48\\%\\][data-state=open]{--tw-enter-translate-y: -48%}.shade .data-\\[state\\=closed\\]\\:duration-300[data-state=closed]{animation-duration:.3s}.shade .data-\\[state\\=open\\]\\:duration-500[data-state=open]{animation-duration:.5s}.shade .data-\\[state\\=active\\]\\:after\\:absolute[data-state=active]:after{content:var(--tw-content);position:absolute}.shade .data-\\[state\\=active\\]\\:after\\:inset-x-0[data-state=active]:after{content:var(--tw-content);left:0px;right:0px}.shade .data-\\[state\\=active\\]\\:after\\:bottom-\\[-5px\\][data-state=active]:after{content:var(--tw-content);bottom:-5px}.shade .data-\\[state\\=active\\]\\:after\\:h-0\\.5[data-state=active]:after{content:var(--tw-content);height:.2rem}.shade .data-\\[state\\=active\\]\\:after\\:bg-black[data-state=active]:after{content:var(--tw-content);--tw-bg-opacity: 1;background-color:rgb(21 23 26 / var(--tw-bg-opacity))}.shade .data-\\[state\\=active\\]\\:after\\:content-\\[\\"\\"\\][data-state=active]:after{--tw-content: "";content:var(--tw-content)}.shade .data-\\[state\\=open\\]\\:hover\\:bg-sidebar-accent:hover[data-state=open]{background-color:hsl(var(--sidebar-accent))}.shade .data-\\[state\\=open\\]\\:hover\\:text-sidebar-accent-foreground:hover[data-state=open]{color:hsl(var(--sidebar-accent-foreground))}.shade :is(.group[data-collapsible=offcanvas] .group-data-\\[collapsible\\=offcanvas\\]\\:left-\\[calc\\(var\\(--sidebar-width\\)\\*-1\\)\\]){left:calc(var(--sidebar-width) * -1)}.shade :is(.group[data-collapsible=offcanvas] .group-data-\\[collapsible\\=offcanvas\\]\\:right-\\[calc\\(var\\(--sidebar-width\\)\\*-1\\)\\]){right:calc(var(--sidebar-width) * -1)}.shade :is(.group[data-side=left] .group-data-\\[side\\=left\\]\\:-right-4){right:-1.6rem}.shade :is(.group[data-side=right] .group-data-\\[side\\=right\\]\\:left-0){left:0px}.shade :is(.group[data-collapsible=icon] .group-data-\\[collapsible\\=icon\\]\\:-mt-8){margin-top:-3.2rem}.shade :is(.group[data-collapsible=icon] .group-data-\\[collapsible\\=icon\\]\\:hidden){display:none}.shade :is(.group[data-collapsible=icon] .group-data-\\[collapsible\\=icon\\]\\:\\!size-8){width:3.2rem!important;height:3.2rem!important}.shade :is(.group[data-collapsible=icon] .group-data-\\[collapsible\\=icon\\]\\:w-\\[--sidebar-width-icon\\]){width:var(--sidebar-width-icon)}.shade :is(.group[data-collapsible=icon] .group-data-\\[collapsible\\=icon\\]\\:w-\\[calc\\(var\\(--sidebar-width-icon\\)_\\+_theme\\(spacing\\.4\\)\\)\\]){width:calc(var(--sidebar-width-icon) + 1.6rem)}.shade :is(.group[data-collapsible=icon] .group-data-\\[collapsible\\=icon\\]\\:w-\\[calc\\(var\\(--sidebar-width-icon\\)_\\+_theme\\(spacing\\.4\\)_\\+2px\\)\\]){width:calc(var(--sidebar-width-icon) + 1.6rem + 2px)}.shade :is(.group[data-collapsible=offcanvas] .group-data-\\[collapsible\\=offcanvas\\]\\:w-0){width:0px}.shade :is(.group[data-collapsible=offcanvas] .group-data-\\[collapsible\\=offcanvas\\]\\:translate-x-0){--tw-translate-x: 0px;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.shade :is(.group[data-side=right] .group-data-\\[side\\=right\\]\\:rotate-180){--tw-rotate: 180deg;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.shade :is(.group[data-collapsible=icon] .group-data-\\[collapsible\\=icon\\]\\:overflow-hidden){overflow:hidden}.shade :is(.group[data-variant=floating] .group-data-\\[variant\\=floating\\]\\:rounded-lg){border-radius:var(--radius)}.shade :is(.group[data-variant=floating] .group-data-\\[variant\\=floating\\]\\:border){border-width:1px}.shade :is(.group[data-side=left] .group-data-\\[side\\=left\\]\\:border-r){border-right-width:1px}.shade :is(.group[data-side=right] .group-data-\\[side\\=right\\]\\:border-l){border-left-width:1px}.shade :is(.group[data-variant=floating] .group-data-\\[variant\\=floating\\]\\:border-sidebar-border){border-color:hsl(var(--sidebar-border))}.shade :is(.group[data-collapsible=icon] .group-data-\\[collapsible\\=icon\\]\\:\\!p-0){padding:0!important}.shade :is(.group[data-collapsible=icon] .group-data-\\[collapsible\\=icon\\]\\:\\!p-2){padding:.8rem!important}.shade :is(.group[data-collapsible=icon] .group-data-\\[collapsible\\=icon\\]\\:opacity-0){opacity:0}.shade :is(.group[data-variant=floating] .group-data-\\[variant\\=floating\\]\\:shadow){--tw-shadow: 0 0 1px rgba(0,0,0,.05), 0 5px 18px rgba(0,0,0,.08);--tw-shadow-colored: 0 0 1px var(--tw-shadow-color), 0 5px 18px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000),var(--tw-ring-shadow, 0 0 #0000),var(--tw-shadow)}.shade :is(.group[data-collapsible=offcanvas] .group-data-\\[collapsible\\=offcanvas\\]\\:after\\:left-full):after{content:var(--tw-content);left:100%}.shade :is(.group[data-collapsible=offcanvas] .group-data-\\[collapsible\\=offcanvas\\]\\:hover\\:bg-sidebar:hover){background-color:hsl(var(--sidebar-background))}.shade :is(.peer\\/menu-button[data-size=default]~.peer-data-\\[size\\=default\\]\\/menu-button\\:top-1\\.5){top:.6rem}.shade :is(.peer\\/menu-button[data-size=default]~.peer-data-\\[size\\=default\\]\\/menu-button\\:top-2){top:.8rem}.shade :is(.peer\\/menu-button[data-size=lg]~.peer-data-\\[size\\=lg\\]\\/menu-button\\:top-2\\.5){top:1rem}.shade :is(.peer\\/menu-button[data-size=lg]~.peer-data-\\[size\\=lg\\]\\/menu-button\\:top-3){top:1.2rem}.shade :is(.peer\\/menu-button[data-size=sm]~.peer-data-\\[size\\=sm\\]\\/menu-button\\:top-1){top:.4rem}.shade :is(.peer\\/menu-button[data-size=sm]~.peer-data-\\[size\\=sm\\]\\/menu-button\\:top-1\\.5){top:.6rem}.shade :is(.peer[data-variant=inset]~.peer-data-\\[variant\\=inset\\]\\:min-h-\\[calc\\(100svh-theme\\(spacing\\.4\\)\\)\\]){min-height:calc(100svh - 1.6rem)}.shade :is(.peer\\/menu-button[data-active=true]~.peer-data-\\[active\\=true\\]\\/menu-button\\:text-sidebar-accent-foreground){color:hsl(var(--sidebar-accent-foreground))}@media (min-width: 480px){.shade .sm\\:mt-0{margin-top:0}.shade .sm\\:flex{display:flex}.shade .sm\\:max-w-sm{max-width:38.4rem}.shade .sm\\:flex-row{flex-direction:row}.shade .sm\\:justify-end{justify-content:flex-end}.shade .sm\\:gap-2\\.5{gap:1rem}.shade :is(.sm\\:space-x-2>:not([hidden])~:not([hidden])){--tw-space-x-reverse: 0;margin-right:calc(.8rem * var(--tw-space-x-reverse));margin-left:calc(.8rem * calc(1 - var(--tw-space-x-reverse)))}.shade .sm\\:rounded-lg{border-radius:var(--radius)}.shade .sm\\:text-left{text-align:left}}@media (min-width: 640px){.shade .md\\:block{display:block}.shade .md\\:flex{display:flex}.shade .md\\:text-sm{font-size:1.3rem}.shade .md\\:opacity-0{opacity:0}.shade .after\\:md\\:hidden:after{content:var(--tw-content);display:none}.shade :is(.peer[data-variant=inset]~.md\\:peer-data-\\[variant\\=inset\\]\\:m-2){margin:.8rem}.shade :is(.peer[data-state=collapsed][data-variant=inset]~.md\\:peer-data-\\[state\\=collapsed\\]\\:peer-data-\\[variant\\=inset\\]\\:ml-2){margin-left:.8rem}.shade :is(.peer[data-variant=inset]~.md\\:peer-data-\\[variant\\=inset\\]\\:ml-0){margin-left:0}.shade :is(.peer[data-variant=inset]~.md\\:peer-data-\\[variant\\=inset\\]\\:rounded-xl){border-radius:1.2rem}.shade :is(.peer[data-variant=inset]~.md\\:peer-data-\\[variant\\=inset\\]\\:shadow){--tw-shadow: 0 0 1px rgba(0,0,0,.05), 0 5px 18px rgba(0,0,0,.08);--tw-shadow-colored: 0 0 1px var(--tw-shadow-color), 0 5px 18px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000),var(--tw-ring-shadow, 0 0 #0000),var(--tw-shadow)}}.shade .dark\\:bg-\\[\\#101114\\]:where(.dark,.dark *){--tw-bg-opacity: 1;background-color:rgb(16 17 20 / var(--tw-bg-opacity))}.shade .dark\\:bg-gray-950:where(.dark,.dark *){--tw-bg-opacity: 1;background-color:rgb(34 36 39 / var(--tw-bg-opacity))}.shade .\\[\\&\\:has\\(\\[role\\=checkbox\\]\\)\\]\\:pr-0:has([role=checkbox]){padding-right:0}.shade :is(.\\[\\&\\>\\[role\\=checkbox\\]\\]\\:translate-y-\\[2px\\]>[role=checkbox]){--tw-translate-y: 2px;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.shade :is(.\\[\\&\\>button\\]\\:hidden>button){display:none}.shade :is(.\\[\\&\\>span\\:last-child\\]\\:truncate>span:last-child){overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.shade :is(.\\[\\&\\>svg\\]\\:size-4>svg){width:1.6rem;height:1.6rem}.shade :is(.\\[\\&\\>svg\\]\\:h-2\\.5>svg){height:1rem}.shade :is(.\\[\\&\\>svg\\]\\:h-3>svg){height:1.2rem}.shade :is(.\\[\\&\\>svg\\]\\:h-3\\.5>svg){height:1.4rem}.shade :is(.\\[\\&\\>svg\\]\\:w-2\\.5>svg){width:1rem}.shade :is(.\\[\\&\\>svg\\]\\:w-3>svg){width:1.2rem}.shade :is(.\\[\\&\\>svg\\]\\:w-3\\.5>svg){width:1.4rem}.shade :is(.\\[\\&\\>svg\\]\\:shrink-0>svg){flex-shrink:0}.shade :is(.\\[\\&\\>svg\\]\\:text-muted-foreground>svg){color:hsl(var(--muted-foreground))}.shade :is(.\\[\\&\\>svg\\]\\:text-sidebar-accent-foreground>svg){color:hsl(var(--sidebar-accent-foreground))}.shade :is(.\\[\\&\\>tr\\]\\:last\\:border-b-0:last-child>tr){border-bottom-width:0px}.shade :is(.\\[\\&_\\.recharts-cartesian-axis-tick_text\\]\\:fill-muted-foreground .recharts-cartesian-axis-tick text){fill:hsl(var(--muted-foreground))}.shade :is(.\\[\\&_\\.recharts-cartesian-grid_line\\[stroke\\=\\'\\#ccc\\'\\]\\]\\:stroke-border\\/50 .recharts-cartesian-grid line[stroke="#ccc"]){stroke:hsl(var(--border) / .5)}.shade :is(.\\[\\&_\\.recharts-curve\\.recharts-tooltip-cursor\\]\\:stroke-border .recharts-curve.recharts-tooltip-cursor){stroke:hsl(var(--border))}.shade :is(.\\[\\&_\\.recharts-dot\\[stroke\\=\\'\\#fff\\'\\]\\]\\:stroke-transparent .recharts-dot[stroke="#fff"]){stroke:transparent}.shade :is(.\\[\\&_\\.recharts-layer\\]\\:outline-none .recharts-layer){outline:2px solid transparent;outline-offset:2px}.shade :is(.\\[\\&_\\.recharts-polar-grid_\\[stroke\\=\\'\\#ccc\\'\\]\\]\\:stroke-border .recharts-polar-grid [stroke="#ccc"]){stroke:hsl(var(--border))}.shade :is(.\\[\\&_\\.recharts-radial-bar-background-sector\\]\\:fill-muted .recharts-radial-bar-background-sector){fill:hsl(var(--muted))}.shade :is(.\\[\\&_\\.recharts-rectangle\\.recharts-tooltip-cursor\\]\\:fill-muted .recharts-rectangle.recharts-tooltip-cursor){fill:hsl(var(--muted))}.shade :is(.\\[\\&_\\.recharts-reference-line_\\[stroke\\=\\'\\#ccc\\'\\]\\]\\:stroke-border .recharts-reference-line [stroke="#ccc"]){stroke:hsl(var(--border))}.shade :is(.\\[\\&_\\.recharts-sector\\[stroke\\=\\'\\#fff\\'\\]\\]\\:stroke-transparent .recharts-sector[stroke="#fff"]){stroke:transparent}.shade :is(.\\[\\&_\\.recharts-sector\\]\\:outline-none .recharts-sector){outline:2px solid transparent;outline-offset:2px}.shade :is(.\\[\\&_\\.recharts-surface\\]\\:outline-none .recharts-surface){outline:2px solid transparent;outline-offset:2px}.shade :is(.\\[\\&_svg\\]\\:pointer-events-none svg){pointer-events:none}.shade :is(.\\[\\&_svg\\]\\:size-3 svg){width:1.2rem;height:1.2rem}.shade :is(.\\[\\&_svg\\]\\:size-4 svg){width:1.6rem;height:1.6rem}.shade :is(.\\[\\&_svg\\]\\:shrink-0 svg){flex-shrink:0}.shade :is(.\\[\\&_tr\\:hover\\:before\\]\\:bg-transparent tr:hover):before{background-color:transparent}.shade :is(.\\[\\&_tr\\]\\:border-transparent tr){border-color:transparent}.shade :is(:hover+.\\[\\:hover_\\+_\\&\\]\\:border-transparent){border-color:transparent}.shade :is([data-side=left][data-collapsible=offcanvas] .\\[\\[data-side\\=left\\]\\[data-collapsible\\=offcanvas\\]_\\&\\]\\:-right-2){right:-.8rem}.shade :is([data-side=left][data-state=collapsed] .\\[\\[data-side\\=left\\]\\[data-state\\=collapsed\\]_\\&\\]\\:cursor-e-resize){cursor:e-resize}.shade :is([data-side=left] .\\[\\[data-side\\=left\\]_\\&\\]\\:cursor-w-resize){cursor:w-resize}.shade :is([data-side=right][data-collapsible=offcanvas] .\\[\\[data-side\\=right\\]\\[data-collapsible\\=offcanvas\\]_\\&\\]\\:-left-2){left:-.8rem}.shade :is([data-side=right][data-state=collapsed] .\\[\\[data-side\\=right\\]\\[data-state\\=collapsed\\]_\\&\\]\\:cursor-w-resize){cursor:w-resize}.shade :is([data-side=right] .\\[\\[data-side\\=right\\]_\\&\\]\\:cursor-e-resize){cursor:e-resize}`)),document.head.appendChild(e)}}catch(a){console.error("vite-plugin-css-injected-by-js",a)}})();
function dl(e) {
  if (e.__esModule)
    return e;
  var t = e.default;
  if (typeof t == "function") {
    var r = function n() {
      return this instanceof n ? Reflect.construct(t, arguments, this.constructor) : t.apply(this, arguments);
    };
    r.prototype = t.prototype;
  } else
    r = {};
  return Object.defineProperty(r, "__esModule", { value: !0 }), Object.keys(e).forEach(function(n) {
    var o = Object.getOwnPropertyDescriptor(e, n);
    Object.defineProperty(r, n, o.get ? o : {
      enumerable: !0,
      get: function() {
        return e[n];
      }
    });
  }), r;
}
var ta = { exports: {} }, Qr = {};
const fl = React.Children, oo = React.Component, Ct = React.Fragment, hl = React.Profiler, pl = React.PureComponent, ml = React.StrictMode, gl = React.Suspense, yl = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, vl = React.act, bl = React.cloneElement, pe = React.createContext, O = React.createElement, wl = React.createFactory, _l = React.createRef, he = React, Je = React.forwardRef, ra = React.isValidElement, El = React.lazy, io = React.memo, kn = React.startTransition, xl = React.unstable_act, ae = React.useCallback, H = React.useContext, Sl = React.useDebugValue, Rl = React.useDeferredValue, se = React.useEffect, Cl = React.useId, Pl = React.useImperativeHandle, Tl = React.useInsertionEffect, ao = React.useLayoutEffect, _e = React.useMemo, na = React.useReducer, zt = React.useRef, be = React.useState, Dl = React.useSyncExternalStore, Ol = React.useTransition, oa = React.version, Ml = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Children: fl,
  Component: oo,
  Fragment: Ct,
  Profiler: hl,
  PureComponent: pl,
  StrictMode: ml,
  Suspense: gl,
  __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: yl,
  act: vl,
  cloneElement: bl,
  createContext: pe,
  createElement: O,
  createFactory: wl,
  createRef: _l,
  default: he,
  forwardRef: Je,
  isValidElement: ra,
  lazy: El,
  memo: io,
  startTransition: kn,
  unstable_act: xl,
  useCallback: ae,
  useContext: H,
  useDebugValue: Sl,
  useDeferredValue: Rl,
  useEffect: se,
  useId: Cl,
  useImperativeHandle: Pl,
  useInsertionEffect: Tl,
  useLayoutEffect: ao,
  useMemo: _e,
  useReducer: na,
  useRef: zt,
  useState: be,
  useSyncExternalStore: Dl,
  useTransition: Ol,
  version: oa
}, Symbol.toStringTag, { value: "Module" })), Il = /* @__PURE__ */ dl(Ml);
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Ll = Il, kl = Symbol.for("react.element"), Nl = Symbol.for("react.fragment"), $l = Object.prototype.hasOwnProperty, Fl = Ll.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, Al = { key: !0, ref: !0, __self: !0, __source: !0 };
function ia(e, t, r) {
  var n, o = {}, i = null, a = null;
  r !== void 0 && (i = "" + r), t.key !== void 0 && (i = "" + t.key), t.ref !== void 0 && (a = t.ref);
  for (n in t)
    $l.call(t, n) && !Al.hasOwnProperty(n) && (o[n] = t[n]);
  if (e && e.defaultProps)
    for (n in t = e.defaultProps, t)
      o[n] === void 0 && (o[n] = t[n]);
  return { $$typeof: kl, type: e, key: i, ref: a, props: o, _owner: Fl.current };
}
Qr.Fragment = Nl;
Qr.jsx = ia;
Qr.jsxs = ia;
ta.exports = Qr;
var B = ta.exports;
const jl = ({ children: e, ...t }) => /* @__PURE__ */ B.jsx("div", { className: "h-screen w-full", children: /* @__PURE__ */ B.jsx("div", { className: "relative mx-auto flex max-w-page flex-col", ...t, children: e }) });
function aa(e) {
  var t, r, n = "";
  if (typeof e == "string" || typeof e == "number")
    n += e;
  else if (typeof e == "object")
    if (Array.isArray(e)) {
      var o = e.length;
      for (t = 0; t < o; t++)
        e[t] && (r = aa(e[t])) && (n && (n += " "), n += r);
    } else
      for (r in e)
        e[r] && (n && (n += " "), n += r);
  return n;
}
function sa() {
  for (var e, t, r = 0, n = "", o = arguments.length; r < o; r++)
    (e = arguments[r]) && (t = aa(e)) && (n && (n += " "), n += t);
  return n;
}
const so = "-", Ul = (e) => {
  const t = ql(e), {
    conflictingClassGroups: r,
    conflictingClassGroupModifiers: n
  } = e;
  return {
    getClassGroupId: (a) => {
      const s = a.split(so);
      return s[0] === "" && s.length !== 1 && s.shift(), la(s, t) || Hl(a);
    },
    getConflictingClassGroupIds: (a, s) => {
      const l = r[a] || [];
      return s && n[a] ? [...l, ...n[a]] : l;
    }
  };
}, la = (e, t) => {
  var a;
  if (e.length === 0)
    return t.classGroupId;
  const r = e[0], n = t.nextPart.get(r), o = n ? la(e.slice(1), n) : void 0;
  if (o)
    return o;
  if (t.validators.length === 0)
    return;
  const i = e.join(so);
  return (a = t.validators.find(({
    validator: s
  }) => s(i))) == null ? void 0 : a.classGroupId;
}, Jo = /^\[(.+)\]$/, Hl = (e) => {
  if (Jo.test(e)) {
    const t = Jo.exec(e)[1], r = t == null ? void 0 : t.substring(0, t.indexOf(":"));
    if (r)
      return "arbitrary.." + r;
  }
}, ql = (e) => {
  const {
    theme: t,
    prefix: r
  } = e, n = {
    nextPart: /* @__PURE__ */ new Map(),
    validators: []
  };
  return Bl(Object.entries(e.classGroups), r).forEach(([i, a]) => {
    Nn(a, n, i, t);
  }), n;
}, Nn = (e, t, r, n) => {
  e.forEach((o) => {
    if (typeof o == "string") {
      const i = o === "" ? t : Zo(t, o);
      i.classGroupId = r;
      return;
    }
    if (typeof o == "function") {
      if (zl(o)) {
        Nn(o(n), t, r, n);
        return;
      }
      t.validators.push({
        validator: o,
        classGroupId: r
      });
      return;
    }
    Object.entries(o).forEach(([i, a]) => {
      Nn(a, Zo(t, i), r, n);
    });
  });
}, Zo = (e, t) => {
  let r = e;
  return t.split(so).forEach((n) => {
    r.nextPart.has(n) || r.nextPart.set(n, {
      nextPart: /* @__PURE__ */ new Map(),
      validators: []
    }), r = r.nextPart.get(n);
  }), r;
}, zl = (e) => e.isThemeGetter, Bl = (e, t) => t ? e.map(([r, n]) => {
  const o = n.map((i) => typeof i == "string" ? t + i : typeof i == "object" ? Object.fromEntries(Object.entries(i).map(([a, s]) => [t + a, s])) : i);
  return [r, o];
}) : e, Gl = (e) => {
  if (e < 1)
    return {
      get: () => {
      },
      set: () => {
      }
    };
  let t = 0, r = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Map();
  const o = (i, a) => {
    r.set(i, a), t++, t > e && (t = 0, n = r, r = /* @__PURE__ */ new Map());
  };
  return {
    get(i) {
      let a = r.get(i);
      if (a !== void 0)
        return a;
      if ((a = n.get(i)) !== void 0)
        return o(i, a), a;
    },
    set(i, a) {
      r.has(i) ? r.set(i, a) : o(i, a);
    }
  };
}, ua = "!", Wl = (e) => {
  const {
    separator: t,
    experimentalParseClassName: r
  } = e, n = t.length === 1, o = t[0], i = t.length, a = (s) => {
    const l = [];
    let u = 0, c = 0, f;
    for (let v = 0; v < s.length; v++) {
      let w = s[v];
      if (u === 0) {
        if (w === o && (n || s.slice(v, v + i) === t)) {
          l.push(s.slice(c, v)), c = v + i;
          continue;
        }
        if (w === "/") {
          f = v;
          continue;
        }
      }
      w === "[" ? u++ : w === "]" && u--;
    }
    const m = l.length === 0 ? s : s.substring(c), p = m.startsWith(ua), b = p ? m.substring(1) : m, _ = f && f > c ? f - c : void 0;
    return {
      modifiers: l,
      hasImportantModifier: p,
      baseClassName: b,
      maybePostfixModifierPosition: _
    };
  };
  return r ? (s) => r({
    className: s,
    parseClassName: a
  }) : a;
}, Vl = (e) => {
  if (e.length <= 1)
    return e;
  const t = [];
  let r = [];
  return e.forEach((n) => {
    n[0] === "[" ? (t.push(...r.sort(), n), r = []) : r.push(n);
  }), t.push(...r.sort()), t;
}, Kl = (e) => ({
  cache: Gl(e.cacheSize),
  parseClassName: Wl(e),
  ...Ul(e)
}), Yl = /\s+/, Ql = (e, t) => {
  const {
    parseClassName: r,
    getClassGroupId: n,
    getConflictingClassGroupIds: o
  } = t, i = [], a = e.trim().split(Yl);
  let s = "";
  for (let l = a.length - 1; l >= 0; l -= 1) {
    const u = a[l], {
      modifiers: c,
      hasImportantModifier: f,
      baseClassName: m,
      maybePostfixModifierPosition: p
    } = r(u);
    let b = !!p, _ = n(b ? m.substring(0, p) : m);
    if (!_) {
      if (!b) {
        s = u + (s.length > 0 ? " " + s : s);
        continue;
      }
      if (_ = n(m), !_) {
        s = u + (s.length > 0 ? " " + s : s);
        continue;
      }
      b = !1;
    }
    const v = Vl(c).join(":"), w = f ? v + ua : v, S = w + _;
    if (i.includes(S))
      continue;
    i.push(S);
    const x = o(_, b);
    for (let I = 0; I < x.length; ++I) {
      const g = x[I];
      i.push(w + g);
    }
    s = u + (s.length > 0 ? " " + s : s);
  }
  return s;
};
function Xl() {
  let e = 0, t, r, n = "";
  for (; e < arguments.length; )
    (t = arguments[e++]) && (r = ca(t)) && (n && (n += " "), n += r);
  return n;
}
const ca = (e) => {
  if (typeof e == "string")
    return e;
  let t, r = "";
  for (let n = 0; n < e.length; n++)
    e[n] && (t = ca(e[n])) && (r && (r += " "), r += t);
  return r;
};
function Jl(e, ...t) {
  let r, n, o, i = a;
  function a(l) {
    const u = t.reduce((c, f) => f(c), e());
    return r = Kl(u), n = r.cache.get, o = r.cache.set, i = s, s(l);
  }
  function s(l) {
    const u = n(l);
    if (u)
      return u;
    const c = Ql(l, r);
    return o(l, c), c;
  }
  return function() {
    return i(Xl.apply(null, arguments));
  };
}
const Q = (e) => {
  const t = (r) => r[e] || [];
  return t.isThemeGetter = !0, t;
}, da = /^\[(?:([a-z-]+):)?(.+)\]$/i, Zl = /^\d+\/\d+$/, eu = /* @__PURE__ */ new Set(["px", "full", "screen"]), tu = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/, ru = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/, nu = /^(rgba?|hsla?|hwb|(ok)?(lab|lch))\(.+\)$/, ou = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/, iu = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/, We = (e) => jt(e) || eu.has(e) || Zl.test(e), rt = (e) => Bt(e, "length", hu), jt = (e) => !!e && !Number.isNaN(Number(e)), xn = (e) => Bt(e, "number", jt), Zt = (e) => !!e && Number.isInteger(Number(e)), au = (e) => e.endsWith("%") && jt(e.slice(0, -1)), j = (e) => da.test(e), nt = (e) => tu.test(e), su = /* @__PURE__ */ new Set(["length", "size", "percentage"]), lu = (e) => Bt(e, su, fa), uu = (e) => Bt(e, "position", fa), cu = /* @__PURE__ */ new Set(["image", "url"]), du = (e) => Bt(e, cu, mu), fu = (e) => Bt(e, "", pu), er = () => !0, Bt = (e, t, r) => {
  const n = da.exec(e);
  return n ? n[1] ? typeof t == "string" ? n[1] === t : t.has(n[1]) : r(n[2]) : !1;
}, hu = (e) => (
  // `colorFunctionRegex` check is necessary because color functions can have percentages in them which which would be incorrectly classified as lengths.
  // For example, `hsl(0 0% 0%)` would be classified as a length without this check.
  // I could also use lookbehind assertion in `lengthUnitRegex` but that isn't supported widely enough.
  ru.test(e) && !nu.test(e)
), fa = () => !1, pu = (e) => ou.test(e), mu = (e) => iu.test(e), gu = () => {
  const e = Q("colors"), t = Q("spacing"), r = Q("blur"), n = Q("brightness"), o = Q("borderColor"), i = Q("borderRadius"), a = Q("borderSpacing"), s = Q("borderWidth"), l = Q("contrast"), u = Q("grayscale"), c = Q("hueRotate"), f = Q("invert"), m = Q("gap"), p = Q("gradientColorStops"), b = Q("gradientColorStopPositions"), _ = Q("inset"), v = Q("margin"), w = Q("opacity"), S = Q("padding"), x = Q("saturate"), I = Q("scale"), g = Q("sepia"), C = Q("skew"), D = Q("space"), T = Q("translate"), A = () => ["auto", "contain", "none"], K = () => ["auto", "hidden", "clip", "visible", "scroll"], ee = () => ["auto", j, t], q = () => [j, t], Re = () => ["", We, rt], He = () => ["auto", jt, j], Z = () => ["bottom", "center", "left", "left-bottom", "left-top", "right", "right-bottom", "right-top", "top"], qe = () => ["solid", "dashed", "dotted", "double", "none"], Ze = () => ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity"], ke = () => ["start", "end", "center", "between", "around", "evenly", "stretch"], me = () => ["", "0", j], ze = () => ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"], ge = () => [jt, j];
  return {
    cacheSize: 500,
    separator: ":",
    theme: {
      colors: [er],
      spacing: [We, rt],
      blur: ["none", "", nt, j],
      brightness: ge(),
      borderColor: [e],
      borderRadius: ["none", "", "full", nt, j],
      borderSpacing: q(),
      borderWidth: Re(),
      contrast: ge(),
      grayscale: me(),
      hueRotate: ge(),
      invert: me(),
      gap: q(),
      gradientColorStops: [e],
      gradientColorStopPositions: [au, rt],
      inset: ee(),
      margin: ee(),
      opacity: ge(),
      padding: q(),
      saturate: ge(),
      scale: ge(),
      sepia: me(),
      skew: ge(),
      space: q(),
      translate: q()
    },
    classGroups: {
      // Layout
      /**
       * Aspect Ratio
       * @see https://tailwindcss.com/docs/aspect-ratio
       */
      aspect: [{
        aspect: ["auto", "square", "video", j]
      }],
      /**
       * Container
       * @see https://tailwindcss.com/docs/container
       */
      container: ["container"],
      /**
       * Columns
       * @see https://tailwindcss.com/docs/columns
       */
      columns: [{
        columns: [nt]
      }],
      /**
       * Break After
       * @see https://tailwindcss.com/docs/break-after
       */
      "break-after": [{
        "break-after": ze()
      }],
      /**
       * Break Before
       * @see https://tailwindcss.com/docs/break-before
       */
      "break-before": [{
        "break-before": ze()
      }],
      /**
       * Break Inside
       * @see https://tailwindcss.com/docs/break-inside
       */
      "break-inside": [{
        "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"]
      }],
      /**
       * Box Decoration Break
       * @see https://tailwindcss.com/docs/box-decoration-break
       */
      "box-decoration": [{
        "box-decoration": ["slice", "clone"]
      }],
      /**
       * Box Sizing
       * @see https://tailwindcss.com/docs/box-sizing
       */
      box: [{
        box: ["border", "content"]
      }],
      /**
       * Display
       * @see https://tailwindcss.com/docs/display
       */
      display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"],
      /**
       * Floats
       * @see https://tailwindcss.com/docs/float
       */
      float: [{
        float: ["right", "left", "none", "start", "end"]
      }],
      /**
       * Clear
       * @see https://tailwindcss.com/docs/clear
       */
      clear: [{
        clear: ["left", "right", "both", "none", "start", "end"]
      }],
      /**
       * Isolation
       * @see https://tailwindcss.com/docs/isolation
       */
      isolation: ["isolate", "isolation-auto"],
      /**
       * Object Fit
       * @see https://tailwindcss.com/docs/object-fit
       */
      "object-fit": [{
        object: ["contain", "cover", "fill", "none", "scale-down"]
      }],
      /**
       * Object Position
       * @see https://tailwindcss.com/docs/object-position
       */
      "object-position": [{
        object: [...Z(), j]
      }],
      /**
       * Overflow
       * @see https://tailwindcss.com/docs/overflow
       */
      overflow: [{
        overflow: K()
      }],
      /**
       * Overflow X
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-x": [{
        "overflow-x": K()
      }],
      /**
       * Overflow Y
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-y": [{
        "overflow-y": K()
      }],
      /**
       * Overscroll Behavior
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      overscroll: [{
        overscroll: A()
      }],
      /**
       * Overscroll Behavior X
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-x": [{
        "overscroll-x": A()
      }],
      /**
       * Overscroll Behavior Y
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-y": [{
        "overscroll-y": A()
      }],
      /**
       * Position
       * @see https://tailwindcss.com/docs/position
       */
      position: ["static", "fixed", "absolute", "relative", "sticky"],
      /**
       * Top / Right / Bottom / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      inset: [{
        inset: [_]
      }],
      /**
       * Right / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-x": [{
        "inset-x": [_]
      }],
      /**
       * Top / Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-y": [{
        "inset-y": [_]
      }],
      /**
       * Start
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      start: [{
        start: [_]
      }],
      /**
       * End
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      end: [{
        end: [_]
      }],
      /**
       * Top
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      top: [{
        top: [_]
      }],
      /**
       * Right
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      right: [{
        right: [_]
      }],
      /**
       * Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      bottom: [{
        bottom: [_]
      }],
      /**
       * Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      left: [{
        left: [_]
      }],
      /**
       * Visibility
       * @see https://tailwindcss.com/docs/visibility
       */
      visibility: ["visible", "invisible", "collapse"],
      /**
       * Z-Index
       * @see https://tailwindcss.com/docs/z-index
       */
      z: [{
        z: ["auto", Zt, j]
      }],
      // Flexbox and Grid
      /**
       * Flex Basis
       * @see https://tailwindcss.com/docs/flex-basis
       */
      basis: [{
        basis: ee()
      }],
      /**
       * Flex Direction
       * @see https://tailwindcss.com/docs/flex-direction
       */
      "flex-direction": [{
        flex: ["row", "row-reverse", "col", "col-reverse"]
      }],
      /**
       * Flex Wrap
       * @see https://tailwindcss.com/docs/flex-wrap
       */
      "flex-wrap": [{
        flex: ["wrap", "wrap-reverse", "nowrap"]
      }],
      /**
       * Flex
       * @see https://tailwindcss.com/docs/flex
       */
      flex: [{
        flex: ["1", "auto", "initial", "none", j]
      }],
      /**
       * Flex Grow
       * @see https://tailwindcss.com/docs/flex-grow
       */
      grow: [{
        grow: me()
      }],
      /**
       * Flex Shrink
       * @see https://tailwindcss.com/docs/flex-shrink
       */
      shrink: [{
        shrink: me()
      }],
      /**
       * Order
       * @see https://tailwindcss.com/docs/order
       */
      order: [{
        order: ["first", "last", "none", Zt, j]
      }],
      /**
       * Grid Template Columns
       * @see https://tailwindcss.com/docs/grid-template-columns
       */
      "grid-cols": [{
        "grid-cols": [er]
      }],
      /**
       * Grid Column Start / End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start-end": [{
        col: ["auto", {
          span: ["full", Zt, j]
        }, j]
      }],
      /**
       * Grid Column Start
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start": [{
        "col-start": He()
      }],
      /**
       * Grid Column End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-end": [{
        "col-end": He()
      }],
      /**
       * Grid Template Rows
       * @see https://tailwindcss.com/docs/grid-template-rows
       */
      "grid-rows": [{
        "grid-rows": [er]
      }],
      /**
       * Grid Row Start / End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start-end": [{
        row: ["auto", {
          span: [Zt, j]
        }, j]
      }],
      /**
       * Grid Row Start
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start": [{
        "row-start": He()
      }],
      /**
       * Grid Row End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-end": [{
        "row-end": He()
      }],
      /**
       * Grid Auto Flow
       * @see https://tailwindcss.com/docs/grid-auto-flow
       */
      "grid-flow": [{
        "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"]
      }],
      /**
       * Grid Auto Columns
       * @see https://tailwindcss.com/docs/grid-auto-columns
       */
      "auto-cols": [{
        "auto-cols": ["auto", "min", "max", "fr", j]
      }],
      /**
       * Grid Auto Rows
       * @see https://tailwindcss.com/docs/grid-auto-rows
       */
      "auto-rows": [{
        "auto-rows": ["auto", "min", "max", "fr", j]
      }],
      /**
       * Gap
       * @see https://tailwindcss.com/docs/gap
       */
      gap: [{
        gap: [m]
      }],
      /**
       * Gap X
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-x": [{
        "gap-x": [m]
      }],
      /**
       * Gap Y
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-y": [{
        "gap-y": [m]
      }],
      /**
       * Justify Content
       * @see https://tailwindcss.com/docs/justify-content
       */
      "justify-content": [{
        justify: ["normal", ...ke()]
      }],
      /**
       * Justify Items
       * @see https://tailwindcss.com/docs/justify-items
       */
      "justify-items": [{
        "justify-items": ["start", "end", "center", "stretch"]
      }],
      /**
       * Justify Self
       * @see https://tailwindcss.com/docs/justify-self
       */
      "justify-self": [{
        "justify-self": ["auto", "start", "end", "center", "stretch"]
      }],
      /**
       * Align Content
       * @see https://tailwindcss.com/docs/align-content
       */
      "align-content": [{
        content: ["normal", ...ke(), "baseline"]
      }],
      /**
       * Align Items
       * @see https://tailwindcss.com/docs/align-items
       */
      "align-items": [{
        items: ["start", "end", "center", "baseline", "stretch"]
      }],
      /**
       * Align Self
       * @see https://tailwindcss.com/docs/align-self
       */
      "align-self": [{
        self: ["auto", "start", "end", "center", "stretch", "baseline"]
      }],
      /**
       * Place Content
       * @see https://tailwindcss.com/docs/place-content
       */
      "place-content": [{
        "place-content": [...ke(), "baseline"]
      }],
      /**
       * Place Items
       * @see https://tailwindcss.com/docs/place-items
       */
      "place-items": [{
        "place-items": ["start", "end", "center", "baseline", "stretch"]
      }],
      /**
       * Place Self
       * @see https://tailwindcss.com/docs/place-self
       */
      "place-self": [{
        "place-self": ["auto", "start", "end", "center", "stretch"]
      }],
      // Spacing
      /**
       * Padding
       * @see https://tailwindcss.com/docs/padding
       */
      p: [{
        p: [S]
      }],
      /**
       * Padding X
       * @see https://tailwindcss.com/docs/padding
       */
      px: [{
        px: [S]
      }],
      /**
       * Padding Y
       * @see https://tailwindcss.com/docs/padding
       */
      py: [{
        py: [S]
      }],
      /**
       * Padding Start
       * @see https://tailwindcss.com/docs/padding
       */
      ps: [{
        ps: [S]
      }],
      /**
       * Padding End
       * @see https://tailwindcss.com/docs/padding
       */
      pe: [{
        pe: [S]
      }],
      /**
       * Padding Top
       * @see https://tailwindcss.com/docs/padding
       */
      pt: [{
        pt: [S]
      }],
      /**
       * Padding Right
       * @see https://tailwindcss.com/docs/padding
       */
      pr: [{
        pr: [S]
      }],
      /**
       * Padding Bottom
       * @see https://tailwindcss.com/docs/padding
       */
      pb: [{
        pb: [S]
      }],
      /**
       * Padding Left
       * @see https://tailwindcss.com/docs/padding
       */
      pl: [{
        pl: [S]
      }],
      /**
       * Margin
       * @see https://tailwindcss.com/docs/margin
       */
      m: [{
        m: [v]
      }],
      /**
       * Margin X
       * @see https://tailwindcss.com/docs/margin
       */
      mx: [{
        mx: [v]
      }],
      /**
       * Margin Y
       * @see https://tailwindcss.com/docs/margin
       */
      my: [{
        my: [v]
      }],
      /**
       * Margin Start
       * @see https://tailwindcss.com/docs/margin
       */
      ms: [{
        ms: [v]
      }],
      /**
       * Margin End
       * @see https://tailwindcss.com/docs/margin
       */
      me: [{
        me: [v]
      }],
      /**
       * Margin Top
       * @see https://tailwindcss.com/docs/margin
       */
      mt: [{
        mt: [v]
      }],
      /**
       * Margin Right
       * @see https://tailwindcss.com/docs/margin
       */
      mr: [{
        mr: [v]
      }],
      /**
       * Margin Bottom
       * @see https://tailwindcss.com/docs/margin
       */
      mb: [{
        mb: [v]
      }],
      /**
       * Margin Left
       * @see https://tailwindcss.com/docs/margin
       */
      ml: [{
        ml: [v]
      }],
      /**
       * Space Between X
       * @see https://tailwindcss.com/docs/space
       */
      "space-x": [{
        "space-x": [D]
      }],
      /**
       * Space Between X Reverse
       * @see https://tailwindcss.com/docs/space
       */
      "space-x-reverse": ["space-x-reverse"],
      /**
       * Space Between Y
       * @see https://tailwindcss.com/docs/space
       */
      "space-y": [{
        "space-y": [D]
      }],
      /**
       * Space Between Y Reverse
       * @see https://tailwindcss.com/docs/space
       */
      "space-y-reverse": ["space-y-reverse"],
      // Sizing
      /**
       * Width
       * @see https://tailwindcss.com/docs/width
       */
      w: [{
        w: ["auto", "min", "max", "fit", "svw", "lvw", "dvw", j, t]
      }],
      /**
       * Min-Width
       * @see https://tailwindcss.com/docs/min-width
       */
      "min-w": [{
        "min-w": [j, t, "min", "max", "fit"]
      }],
      /**
       * Max-Width
       * @see https://tailwindcss.com/docs/max-width
       */
      "max-w": [{
        "max-w": [j, t, "none", "full", "min", "max", "fit", "prose", {
          screen: [nt]
        }, nt]
      }],
      /**
       * Height
       * @see https://tailwindcss.com/docs/height
       */
      h: [{
        h: [j, t, "auto", "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Min-Height
       * @see https://tailwindcss.com/docs/min-height
       */
      "min-h": [{
        "min-h": [j, t, "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Max-Height
       * @see https://tailwindcss.com/docs/max-height
       */
      "max-h": [{
        "max-h": [j, t, "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Size
       * @see https://tailwindcss.com/docs/size
       */
      size: [{
        size: [j, t, "auto", "min", "max", "fit"]
      }],
      // Typography
      /**
       * Font Size
       * @see https://tailwindcss.com/docs/font-size
       */
      "font-size": [{
        text: ["base", nt, rt]
      }],
      /**
       * Font Smoothing
       * @see https://tailwindcss.com/docs/font-smoothing
       */
      "font-smoothing": ["antialiased", "subpixel-antialiased"],
      /**
       * Font Style
       * @see https://tailwindcss.com/docs/font-style
       */
      "font-style": ["italic", "not-italic"],
      /**
       * Font Weight
       * @see https://tailwindcss.com/docs/font-weight
       */
      "font-weight": [{
        font: ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black", xn]
      }],
      /**
       * Font Family
       * @see https://tailwindcss.com/docs/font-family
       */
      "font-family": [{
        font: [er]
      }],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-normal": ["normal-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-ordinal": ["ordinal"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-slashed-zero": ["slashed-zero"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-figure": ["lining-nums", "oldstyle-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-spacing": ["proportional-nums", "tabular-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-fraction": ["diagonal-fractions", "stacked-fractions"],
      /**
       * Letter Spacing
       * @see https://tailwindcss.com/docs/letter-spacing
       */
      tracking: [{
        tracking: ["tighter", "tight", "normal", "wide", "wider", "widest", j]
      }],
      /**
       * Line Clamp
       * @see https://tailwindcss.com/docs/line-clamp
       */
      "line-clamp": [{
        "line-clamp": ["none", jt, xn]
      }],
      /**
       * Line Height
       * @see https://tailwindcss.com/docs/line-height
       */
      leading: [{
        leading: ["none", "tight", "snug", "normal", "relaxed", "loose", We, j]
      }],
      /**
       * List Style Image
       * @see https://tailwindcss.com/docs/list-style-image
       */
      "list-image": [{
        "list-image": ["none", j]
      }],
      /**
       * List Style Type
       * @see https://tailwindcss.com/docs/list-style-type
       */
      "list-style-type": [{
        list: ["none", "disc", "decimal", j]
      }],
      /**
       * List Style Position
       * @see https://tailwindcss.com/docs/list-style-position
       */
      "list-style-position": [{
        list: ["inside", "outside"]
      }],
      /**
       * Placeholder Color
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/placeholder-color
       */
      "placeholder-color": [{
        placeholder: [e]
      }],
      /**
       * Placeholder Opacity
       * @see https://tailwindcss.com/docs/placeholder-opacity
       */
      "placeholder-opacity": [{
        "placeholder-opacity": [w]
      }],
      /**
       * Text Alignment
       * @see https://tailwindcss.com/docs/text-align
       */
      "text-alignment": [{
        text: ["left", "center", "right", "justify", "start", "end"]
      }],
      /**
       * Text Color
       * @see https://tailwindcss.com/docs/text-color
       */
      "text-color": [{
        text: [e]
      }],
      /**
       * Text Opacity
       * @see https://tailwindcss.com/docs/text-opacity
       */
      "text-opacity": [{
        "text-opacity": [w]
      }],
      /**
       * Text Decoration
       * @see https://tailwindcss.com/docs/text-decoration
       */
      "text-decoration": ["underline", "overline", "line-through", "no-underline"],
      /**
       * Text Decoration Style
       * @see https://tailwindcss.com/docs/text-decoration-style
       */
      "text-decoration-style": [{
        decoration: [...qe(), "wavy"]
      }],
      /**
       * Text Decoration Thickness
       * @see https://tailwindcss.com/docs/text-decoration-thickness
       */
      "text-decoration-thickness": [{
        decoration: ["auto", "from-font", We, rt]
      }],
      /**
       * Text Underline Offset
       * @see https://tailwindcss.com/docs/text-underline-offset
       */
      "underline-offset": [{
        "underline-offset": ["auto", We, j]
      }],
      /**
       * Text Decoration Color
       * @see https://tailwindcss.com/docs/text-decoration-color
       */
      "text-decoration-color": [{
        decoration: [e]
      }],
      /**
       * Text Transform
       * @see https://tailwindcss.com/docs/text-transform
       */
      "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"],
      /**
       * Text Overflow
       * @see https://tailwindcss.com/docs/text-overflow
       */
      "text-overflow": ["truncate", "text-ellipsis", "text-clip"],
      /**
       * Text Wrap
       * @see https://tailwindcss.com/docs/text-wrap
       */
      "text-wrap": [{
        text: ["wrap", "nowrap", "balance", "pretty"]
      }],
      /**
       * Text Indent
       * @see https://tailwindcss.com/docs/text-indent
       */
      indent: [{
        indent: q()
      }],
      /**
       * Vertical Alignment
       * @see https://tailwindcss.com/docs/vertical-align
       */
      "vertical-align": [{
        align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", j]
      }],
      /**
       * Whitespace
       * @see https://tailwindcss.com/docs/whitespace
       */
      whitespace: [{
        whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"]
      }],
      /**
       * Word Break
       * @see https://tailwindcss.com/docs/word-break
       */
      break: [{
        break: ["normal", "words", "all", "keep"]
      }],
      /**
       * Hyphens
       * @see https://tailwindcss.com/docs/hyphens
       */
      hyphens: [{
        hyphens: ["none", "manual", "auto"]
      }],
      /**
       * Content
       * @see https://tailwindcss.com/docs/content
       */
      content: [{
        content: ["none", j]
      }],
      // Backgrounds
      /**
       * Background Attachment
       * @see https://tailwindcss.com/docs/background-attachment
       */
      "bg-attachment": [{
        bg: ["fixed", "local", "scroll"]
      }],
      /**
       * Background Clip
       * @see https://tailwindcss.com/docs/background-clip
       */
      "bg-clip": [{
        "bg-clip": ["border", "padding", "content", "text"]
      }],
      /**
       * Background Opacity
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/background-opacity
       */
      "bg-opacity": [{
        "bg-opacity": [w]
      }],
      /**
       * Background Origin
       * @see https://tailwindcss.com/docs/background-origin
       */
      "bg-origin": [{
        "bg-origin": ["border", "padding", "content"]
      }],
      /**
       * Background Position
       * @see https://tailwindcss.com/docs/background-position
       */
      "bg-position": [{
        bg: [...Z(), uu]
      }],
      /**
       * Background Repeat
       * @see https://tailwindcss.com/docs/background-repeat
       */
      "bg-repeat": [{
        bg: ["no-repeat", {
          repeat: ["", "x", "y", "round", "space"]
        }]
      }],
      /**
       * Background Size
       * @see https://tailwindcss.com/docs/background-size
       */
      "bg-size": [{
        bg: ["auto", "cover", "contain", lu]
      }],
      /**
       * Background Image
       * @see https://tailwindcss.com/docs/background-image
       */
      "bg-image": [{
        bg: ["none", {
          "gradient-to": ["t", "tr", "r", "br", "b", "bl", "l", "tl"]
        }, du]
      }],
      /**
       * Background Color
       * @see https://tailwindcss.com/docs/background-color
       */
      "bg-color": [{
        bg: [e]
      }],
      /**
       * Gradient Color Stops From Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from-pos": [{
        from: [b]
      }],
      /**
       * Gradient Color Stops Via Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via-pos": [{
        via: [b]
      }],
      /**
       * Gradient Color Stops To Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to-pos": [{
        to: [b]
      }],
      /**
       * Gradient Color Stops From
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from": [{
        from: [p]
      }],
      /**
       * Gradient Color Stops Via
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via": [{
        via: [p]
      }],
      /**
       * Gradient Color Stops To
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to": [{
        to: [p]
      }],
      // Borders
      /**
       * Border Radius
       * @see https://tailwindcss.com/docs/border-radius
       */
      rounded: [{
        rounded: [i]
      }],
      /**
       * Border Radius Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-s": [{
        "rounded-s": [i]
      }],
      /**
       * Border Radius End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-e": [{
        "rounded-e": [i]
      }],
      /**
       * Border Radius Top
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-t": [{
        "rounded-t": [i]
      }],
      /**
       * Border Radius Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-r": [{
        "rounded-r": [i]
      }],
      /**
       * Border Radius Bottom
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-b": [{
        "rounded-b": [i]
      }],
      /**
       * Border Radius Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-l": [{
        "rounded-l": [i]
      }],
      /**
       * Border Radius Start Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ss": [{
        "rounded-ss": [i]
      }],
      /**
       * Border Radius Start End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-se": [{
        "rounded-se": [i]
      }],
      /**
       * Border Radius End End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ee": [{
        "rounded-ee": [i]
      }],
      /**
       * Border Radius End Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-es": [{
        "rounded-es": [i]
      }],
      /**
       * Border Radius Top Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tl": [{
        "rounded-tl": [i]
      }],
      /**
       * Border Radius Top Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tr": [{
        "rounded-tr": [i]
      }],
      /**
       * Border Radius Bottom Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-br": [{
        "rounded-br": [i]
      }],
      /**
       * Border Radius Bottom Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-bl": [{
        "rounded-bl": [i]
      }],
      /**
       * Border Width
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w": [{
        border: [s]
      }],
      /**
       * Border Width X
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-x": [{
        "border-x": [s]
      }],
      /**
       * Border Width Y
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-y": [{
        "border-y": [s]
      }],
      /**
       * Border Width Start
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-s": [{
        "border-s": [s]
      }],
      /**
       * Border Width End
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-e": [{
        "border-e": [s]
      }],
      /**
       * Border Width Top
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-t": [{
        "border-t": [s]
      }],
      /**
       * Border Width Right
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-r": [{
        "border-r": [s]
      }],
      /**
       * Border Width Bottom
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-b": [{
        "border-b": [s]
      }],
      /**
       * Border Width Left
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-l": [{
        "border-l": [s]
      }],
      /**
       * Border Opacity
       * @see https://tailwindcss.com/docs/border-opacity
       */
      "border-opacity": [{
        "border-opacity": [w]
      }],
      /**
       * Border Style
       * @see https://tailwindcss.com/docs/border-style
       */
      "border-style": [{
        border: [...qe(), "hidden"]
      }],
      /**
       * Divide Width X
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-x": [{
        "divide-x": [s]
      }],
      /**
       * Divide Width X Reverse
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-x-reverse": ["divide-x-reverse"],
      /**
       * Divide Width Y
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-y": [{
        "divide-y": [s]
      }],
      /**
       * Divide Width Y Reverse
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-y-reverse": ["divide-y-reverse"],
      /**
       * Divide Opacity
       * @see https://tailwindcss.com/docs/divide-opacity
       */
      "divide-opacity": [{
        "divide-opacity": [w]
      }],
      /**
       * Divide Style
       * @see https://tailwindcss.com/docs/divide-style
       */
      "divide-style": [{
        divide: qe()
      }],
      /**
       * Border Color
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color": [{
        border: [o]
      }],
      /**
       * Border Color X
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-x": [{
        "border-x": [o]
      }],
      /**
       * Border Color Y
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-y": [{
        "border-y": [o]
      }],
      /**
       * Border Color S
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-s": [{
        "border-s": [o]
      }],
      /**
       * Border Color E
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-e": [{
        "border-e": [o]
      }],
      /**
       * Border Color Top
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-t": [{
        "border-t": [o]
      }],
      /**
       * Border Color Right
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-r": [{
        "border-r": [o]
      }],
      /**
       * Border Color Bottom
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-b": [{
        "border-b": [o]
      }],
      /**
       * Border Color Left
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-l": [{
        "border-l": [o]
      }],
      /**
       * Divide Color
       * @see https://tailwindcss.com/docs/divide-color
       */
      "divide-color": [{
        divide: [o]
      }],
      /**
       * Outline Style
       * @see https://tailwindcss.com/docs/outline-style
       */
      "outline-style": [{
        outline: ["", ...qe()]
      }],
      /**
       * Outline Offset
       * @see https://tailwindcss.com/docs/outline-offset
       */
      "outline-offset": [{
        "outline-offset": [We, j]
      }],
      /**
       * Outline Width
       * @see https://tailwindcss.com/docs/outline-width
       */
      "outline-w": [{
        outline: [We, rt]
      }],
      /**
       * Outline Color
       * @see https://tailwindcss.com/docs/outline-color
       */
      "outline-color": [{
        outline: [e]
      }],
      /**
       * Ring Width
       * @see https://tailwindcss.com/docs/ring-width
       */
      "ring-w": [{
        ring: Re()
      }],
      /**
       * Ring Width Inset
       * @see https://tailwindcss.com/docs/ring-width
       */
      "ring-w-inset": ["ring-inset"],
      /**
       * Ring Color
       * @see https://tailwindcss.com/docs/ring-color
       */
      "ring-color": [{
        ring: [e]
      }],
      /**
       * Ring Opacity
       * @see https://tailwindcss.com/docs/ring-opacity
       */
      "ring-opacity": [{
        "ring-opacity": [w]
      }],
      /**
       * Ring Offset Width
       * @see https://tailwindcss.com/docs/ring-offset-width
       */
      "ring-offset-w": [{
        "ring-offset": [We, rt]
      }],
      /**
       * Ring Offset Color
       * @see https://tailwindcss.com/docs/ring-offset-color
       */
      "ring-offset-color": [{
        "ring-offset": [e]
      }],
      // Effects
      /**
       * Box Shadow
       * @see https://tailwindcss.com/docs/box-shadow
       */
      shadow: [{
        shadow: ["", "inner", "none", nt, fu]
      }],
      /**
       * Box Shadow Color
       * @see https://tailwindcss.com/docs/box-shadow-color
       */
      "shadow-color": [{
        shadow: [er]
      }],
      /**
       * Opacity
       * @see https://tailwindcss.com/docs/opacity
       */
      opacity: [{
        opacity: [w]
      }],
      /**
       * Mix Blend Mode
       * @see https://tailwindcss.com/docs/mix-blend-mode
       */
      "mix-blend": [{
        "mix-blend": [...Ze(), "plus-lighter", "plus-darker"]
      }],
      /**
       * Background Blend Mode
       * @see https://tailwindcss.com/docs/background-blend-mode
       */
      "bg-blend": [{
        "bg-blend": Ze()
      }],
      // Filters
      /**
       * Filter
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/filter
       */
      filter: [{
        filter: ["", "none"]
      }],
      /**
       * Blur
       * @see https://tailwindcss.com/docs/blur
       */
      blur: [{
        blur: [r]
      }],
      /**
       * Brightness
       * @see https://tailwindcss.com/docs/brightness
       */
      brightness: [{
        brightness: [n]
      }],
      /**
       * Contrast
       * @see https://tailwindcss.com/docs/contrast
       */
      contrast: [{
        contrast: [l]
      }],
      /**
       * Drop Shadow
       * @see https://tailwindcss.com/docs/drop-shadow
       */
      "drop-shadow": [{
        "drop-shadow": ["", "none", nt, j]
      }],
      /**
       * Grayscale
       * @see https://tailwindcss.com/docs/grayscale
       */
      grayscale: [{
        grayscale: [u]
      }],
      /**
       * Hue Rotate
       * @see https://tailwindcss.com/docs/hue-rotate
       */
      "hue-rotate": [{
        "hue-rotate": [c]
      }],
      /**
       * Invert
       * @see https://tailwindcss.com/docs/invert
       */
      invert: [{
        invert: [f]
      }],
      /**
       * Saturate
       * @see https://tailwindcss.com/docs/saturate
       */
      saturate: [{
        saturate: [x]
      }],
      /**
       * Sepia
       * @see https://tailwindcss.com/docs/sepia
       */
      sepia: [{
        sepia: [g]
      }],
      /**
       * Backdrop Filter
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/backdrop-filter
       */
      "backdrop-filter": [{
        "backdrop-filter": ["", "none"]
      }],
      /**
       * Backdrop Blur
       * @see https://tailwindcss.com/docs/backdrop-blur
       */
      "backdrop-blur": [{
        "backdrop-blur": [r]
      }],
      /**
       * Backdrop Brightness
       * @see https://tailwindcss.com/docs/backdrop-brightness
       */
      "backdrop-brightness": [{
        "backdrop-brightness": [n]
      }],
      /**
       * Backdrop Contrast
       * @see https://tailwindcss.com/docs/backdrop-contrast
       */
      "backdrop-contrast": [{
        "backdrop-contrast": [l]
      }],
      /**
       * Backdrop Grayscale
       * @see https://tailwindcss.com/docs/backdrop-grayscale
       */
      "backdrop-grayscale": [{
        "backdrop-grayscale": [u]
      }],
      /**
       * Backdrop Hue Rotate
       * @see https://tailwindcss.com/docs/backdrop-hue-rotate
       */
      "backdrop-hue-rotate": [{
        "backdrop-hue-rotate": [c]
      }],
      /**
       * Backdrop Invert
       * @see https://tailwindcss.com/docs/backdrop-invert
       */
      "backdrop-invert": [{
        "backdrop-invert": [f]
      }],
      /**
       * Backdrop Opacity
       * @see https://tailwindcss.com/docs/backdrop-opacity
       */
      "backdrop-opacity": [{
        "backdrop-opacity": [w]
      }],
      /**
       * Backdrop Saturate
       * @see https://tailwindcss.com/docs/backdrop-saturate
       */
      "backdrop-saturate": [{
        "backdrop-saturate": [x]
      }],
      /**
       * Backdrop Sepia
       * @see https://tailwindcss.com/docs/backdrop-sepia
       */
      "backdrop-sepia": [{
        "backdrop-sepia": [g]
      }],
      // Tables
      /**
       * Border Collapse
       * @see https://tailwindcss.com/docs/border-collapse
       */
      "border-collapse": [{
        border: ["collapse", "separate"]
      }],
      /**
       * Border Spacing
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing": [{
        "border-spacing": [a]
      }],
      /**
       * Border Spacing X
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-x": [{
        "border-spacing-x": [a]
      }],
      /**
       * Border Spacing Y
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-y": [{
        "border-spacing-y": [a]
      }],
      /**
       * Table Layout
       * @see https://tailwindcss.com/docs/table-layout
       */
      "table-layout": [{
        table: ["auto", "fixed"]
      }],
      /**
       * Caption Side
       * @see https://tailwindcss.com/docs/caption-side
       */
      caption: [{
        caption: ["top", "bottom"]
      }],
      // Transitions and Animation
      /**
       * Tranisition Property
       * @see https://tailwindcss.com/docs/transition-property
       */
      transition: [{
        transition: ["none", "all", "", "colors", "opacity", "shadow", "transform", j]
      }],
      /**
       * Transition Duration
       * @see https://tailwindcss.com/docs/transition-duration
       */
      duration: [{
        duration: ge()
      }],
      /**
       * Transition Timing Function
       * @see https://tailwindcss.com/docs/transition-timing-function
       */
      ease: [{
        ease: ["linear", "in", "out", "in-out", j]
      }],
      /**
       * Transition Delay
       * @see https://tailwindcss.com/docs/transition-delay
       */
      delay: [{
        delay: ge()
      }],
      /**
       * Animation
       * @see https://tailwindcss.com/docs/animation
       */
      animate: [{
        animate: ["none", "spin", "ping", "pulse", "bounce", j]
      }],
      // Transforms
      /**
       * Transform
       * @see https://tailwindcss.com/docs/transform
       */
      transform: [{
        transform: ["", "gpu", "none"]
      }],
      /**
       * Scale
       * @see https://tailwindcss.com/docs/scale
       */
      scale: [{
        scale: [I]
      }],
      /**
       * Scale X
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-x": [{
        "scale-x": [I]
      }],
      /**
       * Scale Y
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-y": [{
        "scale-y": [I]
      }],
      /**
       * Rotate
       * @see https://tailwindcss.com/docs/rotate
       */
      rotate: [{
        rotate: [Zt, j]
      }],
      /**
       * Translate X
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-x": [{
        "translate-x": [T]
      }],
      /**
       * Translate Y
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-y": [{
        "translate-y": [T]
      }],
      /**
       * Skew X
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-x": [{
        "skew-x": [C]
      }],
      /**
       * Skew Y
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-y": [{
        "skew-y": [C]
      }],
      /**
       * Transform Origin
       * @see https://tailwindcss.com/docs/transform-origin
       */
      "transform-origin": [{
        origin: ["center", "top", "top-right", "right", "bottom-right", "bottom", "bottom-left", "left", "top-left", j]
      }],
      // Interactivity
      /**
       * Accent Color
       * @see https://tailwindcss.com/docs/accent-color
       */
      accent: [{
        accent: ["auto", e]
      }],
      /**
       * Appearance
       * @see https://tailwindcss.com/docs/appearance
       */
      appearance: [{
        appearance: ["none", "auto"]
      }],
      /**
       * Cursor
       * @see https://tailwindcss.com/docs/cursor
       */
      cursor: [{
        cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", j]
      }],
      /**
       * Caret Color
       * @see https://tailwindcss.com/docs/just-in-time-mode#caret-color-utilities
       */
      "caret-color": [{
        caret: [e]
      }],
      /**
       * Pointer Events
       * @see https://tailwindcss.com/docs/pointer-events
       */
      "pointer-events": [{
        "pointer-events": ["none", "auto"]
      }],
      /**
       * Resize
       * @see https://tailwindcss.com/docs/resize
       */
      resize: [{
        resize: ["none", "y", "x", ""]
      }],
      /**
       * Scroll Behavior
       * @see https://tailwindcss.com/docs/scroll-behavior
       */
      "scroll-behavior": [{
        scroll: ["auto", "smooth"]
      }],
      /**
       * Scroll Margin
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-m": [{
        "scroll-m": q()
      }],
      /**
       * Scroll Margin X
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mx": [{
        "scroll-mx": q()
      }],
      /**
       * Scroll Margin Y
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-my": [{
        "scroll-my": q()
      }],
      /**
       * Scroll Margin Start
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ms": [{
        "scroll-ms": q()
      }],
      /**
       * Scroll Margin End
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-me": [{
        "scroll-me": q()
      }],
      /**
       * Scroll Margin Top
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mt": [{
        "scroll-mt": q()
      }],
      /**
       * Scroll Margin Right
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mr": [{
        "scroll-mr": q()
      }],
      /**
       * Scroll Margin Bottom
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mb": [{
        "scroll-mb": q()
      }],
      /**
       * Scroll Margin Left
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ml": [{
        "scroll-ml": q()
      }],
      /**
       * Scroll Padding
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-p": [{
        "scroll-p": q()
      }],
      /**
       * Scroll Padding X
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-px": [{
        "scroll-px": q()
      }],
      /**
       * Scroll Padding Y
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-py": [{
        "scroll-py": q()
      }],
      /**
       * Scroll Padding Start
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-ps": [{
        "scroll-ps": q()
      }],
      /**
       * Scroll Padding End
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pe": [{
        "scroll-pe": q()
      }],
      /**
       * Scroll Padding Top
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pt": [{
        "scroll-pt": q()
      }],
      /**
       * Scroll Padding Right
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pr": [{
        "scroll-pr": q()
      }],
      /**
       * Scroll Padding Bottom
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pb": [{
        "scroll-pb": q()
      }],
      /**
       * Scroll Padding Left
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pl": [{
        "scroll-pl": q()
      }],
      /**
       * Scroll Snap Align
       * @see https://tailwindcss.com/docs/scroll-snap-align
       */
      "snap-align": [{
        snap: ["start", "end", "center", "align-none"]
      }],
      /**
       * Scroll Snap Stop
       * @see https://tailwindcss.com/docs/scroll-snap-stop
       */
      "snap-stop": [{
        snap: ["normal", "always"]
      }],
      /**
       * Scroll Snap Type
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-type": [{
        snap: ["none", "x", "y", "both"]
      }],
      /**
       * Scroll Snap Type Strictness
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-strictness": [{
        snap: ["mandatory", "proximity"]
      }],
      /**
       * Touch Action
       * @see https://tailwindcss.com/docs/touch-action
       */
      touch: [{
        touch: ["auto", "none", "manipulation"]
      }],
      /**
       * Touch Action X
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-x": [{
        "touch-pan": ["x", "left", "right"]
      }],
      /**
       * Touch Action Y
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-y": [{
        "touch-pan": ["y", "up", "down"]
      }],
      /**
       * Touch Action Pinch Zoom
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-pz": ["touch-pinch-zoom"],
      /**
       * User Select
       * @see https://tailwindcss.com/docs/user-select
       */
      select: [{
        select: ["none", "text", "all", "auto"]
      }],
      /**
       * Will Change
       * @see https://tailwindcss.com/docs/will-change
       */
      "will-change": [{
        "will-change": ["auto", "scroll", "contents", "transform", j]
      }],
      // SVG
      /**
       * Fill
       * @see https://tailwindcss.com/docs/fill
       */
      fill: [{
        fill: [e, "none"]
      }],
      /**
       * Stroke Width
       * @see https://tailwindcss.com/docs/stroke-width
       */
      "stroke-w": [{
        stroke: [We, rt, xn]
      }],
      /**
       * Stroke
       * @see https://tailwindcss.com/docs/stroke
       */
      stroke: [{
        stroke: [e, "none"]
      }],
      // Accessibility
      /**
       * Screen Readers
       * @see https://tailwindcss.com/docs/screen-readers
       */
      sr: ["sr-only", "not-sr-only"],
      /**
       * Forced Color Adjust
       * @see https://tailwindcss.com/docs/forced-color-adjust
       */
      "forced-color-adjust": [{
        "forced-color-adjust": ["auto", "none"]
      }]
    },
    conflictingClassGroups: {
      overflow: ["overflow-x", "overflow-y"],
      overscroll: ["overscroll-x", "overscroll-y"],
      inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"],
      "inset-x": ["right", "left"],
      "inset-y": ["top", "bottom"],
      flex: ["basis", "grow", "shrink"],
      gap: ["gap-x", "gap-y"],
      p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"],
      px: ["pr", "pl"],
      py: ["pt", "pb"],
      m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"],
      mx: ["mr", "ml"],
      my: ["mt", "mb"],
      size: ["w", "h"],
      "font-size": ["leading"],
      "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"],
      "fvn-ordinal": ["fvn-normal"],
      "fvn-slashed-zero": ["fvn-normal"],
      "fvn-figure": ["fvn-normal"],
      "fvn-spacing": ["fvn-normal"],
      "fvn-fraction": ["fvn-normal"],
      "line-clamp": ["display", "overflow"],
      rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"],
      "rounded-s": ["rounded-ss", "rounded-es"],
      "rounded-e": ["rounded-se", "rounded-ee"],
      "rounded-t": ["rounded-tl", "rounded-tr"],
      "rounded-r": ["rounded-tr", "rounded-br"],
      "rounded-b": ["rounded-br", "rounded-bl"],
      "rounded-l": ["rounded-tl", "rounded-bl"],
      "border-spacing": ["border-spacing-x", "border-spacing-y"],
      "border-w": ["border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"],
      "border-w-x": ["border-w-r", "border-w-l"],
      "border-w-y": ["border-w-t", "border-w-b"],
      "border-color": ["border-color-s", "border-color-e", "border-color-t", "border-color-r", "border-color-b", "border-color-l"],
      "border-color-x": ["border-color-r", "border-color-l"],
      "border-color-y": ["border-color-t", "border-color-b"],
      "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"],
      "scroll-mx": ["scroll-mr", "scroll-ml"],
      "scroll-my": ["scroll-mt", "scroll-mb"],
      "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"],
      "scroll-px": ["scroll-pr", "scroll-pl"],
      "scroll-py": ["scroll-pt", "scroll-pb"],
      touch: ["touch-x", "touch-y", "touch-pz"],
      "touch-x": ["touch"],
      "touch-y": ["touch"],
      "touch-pz": ["touch"]
    },
    conflictingClassGroupModifiers: {
      "font-size": ["leading"]
    }
  };
}, yu = /* @__PURE__ */ Jl(gu);
function fr(...e) {
  return yu(sa(e));
}
const ha = Je(
  ({ className: e, ...t }, r) => /* @__PURE__ */ B.jsx(
    "div",
    {
      ref: r,
      className: fr("max-w-page mx-auto w-full min-h-full px-8 flex flex-col", e),
      ...t,
      children: /* @__PURE__ */ B.jsx("h1", { children: "Error" })
    }
  )
);
ha.displayName = "ErrorPage";
const pa = Je(
  ({ className: e, ...t }, r) => /* @__PURE__ */ B.jsx(
    "h1",
    {
      ref: r,
      className: fr("scroll-m-20 text-3xl leading-supertight tracking-tight font-bold", e),
      ...t
    }
  )
);
pa.displayName = "H1";
const vu = Je(
  ({ className: e, ...t }, r) => /* @__PURE__ */ B.jsx(
    "h2",
    {
      ref: r,
      className: fr("scroll-m-20 text-2xl font-bold tracking-tight first:mt-0", e),
      ...t
    }
  )
);
vu.displayName = "H2";
const bu = Je(
  ({ className: e, ...t }, r) => /* @__PURE__ */ B.jsx(
    "h3",
    {
      ref: r,
      className: fr("scroll-m-20 text-xl font-semibold tracking-tight", e),
      ...t
    }
  )
);
bu.displayName = "H3";
const wu = Je(
  ({ className: e, ...t }, r) => /* @__PURE__ */ B.jsx(
    "h4",
    {
      ref: r,
      className: fr("scroll-m-20 text-lg font-semibold tracking-tight", e),
      ...t
    }
  )
);
wu.displayName = "H4";
const _u = he.createContext({ isDirty: !1, setGlobalDirtyState: () => {
} }), Eu = ({ children: e }) => {
  const [t, r] = be([]), n = ae((o, i) => {
    r((a) => i && !a.includes(o) ? [...a, o] : !i && a.includes(o) ? a.filter((s) => s !== o) : a);
  }, []);
  return /* @__PURE__ */ B.jsx(_u.Provider, { value: { isDirty: t.length > 0, setGlobalDirtyState: n }, children: e });
};
var oe = globalThis && globalThis.__assign || function() {
  return oe = Object.assign || function(e) {
    for (var t, r = 1, n = arguments.length; r < n; r++) {
      t = arguments[r];
      for (var o in t)
        Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);
    }
    return e;
  }, oe.apply(this, arguments);
}, ma = globalThis && globalThis.__rest || function(e, t) {
  var r = {};
  for (var n in e)
    Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var o = 0, n = Object.getOwnPropertySymbols(e); o < n.length; o++)
      t.indexOf(n[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[o]) && (r[n[o]] = e[n[o]]);
  return r;
}, Sn = Symbol("NiceModalId"), lo = {}, Gt = he.createContext(lo), ga = he.createContext(null), Me = {}, ur = {}, xu = 0, Wt = function() {
  throw new Error("No dispatch method detected, did you embed your app with NiceModal.Provider?");
}, ya = function() {
  return "_nice_modal_" + xu++;
}, va = function(e, t) {
  var r, n, o;
  switch (e === void 0 && (e = lo), t.type) {
    case "nice-modal/show": {
      var i = t.payload, a = i.modalId, s = i.args;
      return oe(oe({}, e), (r = {}, r[a] = oe(oe({}, e[a]), {
        id: a,
        args: s,
        // If modal is not mounted, mount it first then make it visible.
        // There is logic inside HOC wrapper to make it visible after its first mount.
        // This mechanism ensures the entering transition.
        visible: !!ur[a],
        delayVisible: !ur[a]
      }), r));
    }
    case "nice-modal/hide": {
      var a = t.payload.modalId;
      return e[a] ? oe(oe({}, e), (n = {}, n[a] = oe(oe({}, e[a]), { visible: !1 }), n)) : e;
    }
    case "nice-modal/remove": {
      var a = t.payload.modalId, l = oe({}, e);
      return delete l[a], l;
    }
    case "nice-modal/set-flags": {
      var u = t.payload, a = u.modalId, c = u.flags;
      return oe(oe({}, e), (o = {}, o[a] = oe(oe({}, e[a]), c), o));
    }
    default:
      return e;
  }
};
function Su(e) {
  var t;
  return (t = Me[e]) === null || t === void 0 ? void 0 : t.comp;
}
function Ru(e, t) {
  return {
    type: "nice-modal/show",
    payload: {
      modalId: e,
      args: t
    }
  };
}
function Cu(e, t) {
  return {
    type: "nice-modal/set-flags",
    payload: {
      modalId: e,
      flags: t
    }
  };
}
function Pu(e) {
  return {
    type: "nice-modal/hide",
    payload: {
      modalId: e
    }
  };
}
function Tu(e) {
  return {
    type: "nice-modal/remove",
    payload: {
      modalId: e
    }
  };
}
var Ye = {}, Ut = {}, Xr = function(e) {
  return typeof e == "string" ? e : (e[Sn] || (e[Sn] = ya()), e[Sn]);
};
function uo(e, t) {
  var r = Xr(e);
  if (typeof e != "string" && !Me[r] && Jr(r, e), Wt(Ru(r, t)), !Ye[r]) {
    var n, o, i = new Promise(function(a, s) {
      n = a, o = s;
    });
    Ye[r] = {
      resolve: n,
      reject: o,
      promise: i
    };
  }
  return Ye[r].promise;
}
function co(e) {
  var t = Xr(e);
  if (Wt(Pu(t)), delete Ye[t], !Ut[t]) {
    var r, n, o = new Promise(function(i, a) {
      r = i, n = a;
    });
    Ut[t] = {
      resolve: r,
      reject: n,
      promise: o
    };
  }
  return Ut[t].promise;
}
var ba = function(e) {
  var t = Xr(e);
  Wt(Tu(t)), delete Ye[t], delete Ut[t];
}, Du = function(e, t) {
  Wt(Cu(e, t));
};
function wa(e, t) {
  var r = H(Gt), n = H(ga), o = null, i = e && typeof e != "string";
  if (e ? o = Xr(e) : o = n, !o)
    throw new Error("No modal id found in NiceModal.useModal.");
  var a = o;
  se(function() {
    i && !Me[a] && Jr(a, e, t);
  }, [i, a, e, t]);
  var s = r[a], l = ae(function(b) {
    return uo(a, b);
  }, [a]), u = ae(function() {
    return co(a);
  }, [a]), c = ae(function() {
    return ba(a);
  }, [a]), f = ae(function(b) {
    var _;
    (_ = Ye[a]) === null || _ === void 0 || _.resolve(b), delete Ye[a];
  }, [a]), m = ae(function(b) {
    var _;
    (_ = Ye[a]) === null || _ === void 0 || _.reject(b), delete Ye[a];
  }, [a]), p = ae(function(b) {
    var _;
    (_ = Ut[a]) === null || _ === void 0 || _.resolve(b), delete Ut[a];
  }, [a]);
  return _e(function() {
    return {
      id: a,
      args: s == null ? void 0 : s.args,
      visible: !!(s != null && s.visible),
      keepMounted: !!(s != null && s.keepMounted),
      show: l,
      hide: u,
      remove: c,
      resolve: f,
      reject: m,
      resolveHide: p
    };
  }, [
    a,
    s == null ? void 0 : s.args,
    s == null ? void 0 : s.visible,
    s == null ? void 0 : s.keepMounted,
    l,
    u,
    c,
    f,
    m,
    p
  ]);
}
var Ou = function(e) {
  return function(t) {
    var r, n = t.defaultVisible, o = t.keepMounted, i = t.id, a = ma(t, ["defaultVisible", "keepMounted", "id"]), s = wa(i), l = s.args, u = s.show, c = H(Gt), f = !!c[i];
    se(function() {
      return n && u(), ur[i] = !0, function() {
        delete ur[i];
      };
    }, [i, u, n]), se(function() {
      o && Du(i, { keepMounted: !0 });
    }, [i, o]);
    var m = (r = c[i]) === null || r === void 0 ? void 0 : r.delayVisible;
    return se(function() {
      m && u(l);
    }, [m, l, u]), f ? he.createElement(
      ga.Provider,
      { value: i },
      he.createElement(e, oe({}, a, l))
    ) : null;
  };
}, Jr = function(e, t, r) {
  Me[e] ? Me[e].props = r : Me[e] = { comp: t, props: r };
}, Mu = function(e) {
  delete Me[e];
}, _a = function() {
  var e = H(Gt), t = Object.keys(e).filter(function(n) {
    return !!e[n];
  });
  t.forEach(function(n) {
    if (!Me[n] && !ur[n]) {
      console.warn("No modal found for id: " + n + ". Please check the id or if it is registered or declared via JSX.");
      return;
    }
  });
  var r = t.filter(function(n) {
    return Me[n];
  }).map(function(n) {
    return oe({ id: n }, Me[n]);
  });
  return he.createElement(he.Fragment, null, r.map(function(n) {
    return he.createElement(n.comp, oe({ key: n.id, id: n.id }, n.props));
  }));
}, Iu = function(e) {
  var t = e.children, r = na(va, lo), n = r[0];
  return Wt = r[1], he.createElement(
    Gt.Provider,
    { value: n },
    t,
    he.createElement(_a, null)
  );
}, Lu = function(e) {
  var t = e.children, r = e.dispatch, n = e.modals;
  return !r || !n ? he.createElement(Iu, null, t) : (Wt = r, he.createElement(
    Gt.Provider,
    { value: n },
    t,
    he.createElement(_a, null)
  ));
}, ku = function(e) {
  var t = e.id, r = e.component;
  return se(function() {
    return Jr(t, r), function() {
      Mu(t);
    };
  }, [t, r]), null;
}, Nu = function(e) {
  var t, r = e.modal, n = e.handler, o = n === void 0 ? {} : n, i = ma(e, ["modal", "handler"]), a = _e(function() {
    return ya();
  }, []), s = typeof r == "string" ? (t = Me[r]) === null || t === void 0 ? void 0 : t.comp : r;
  if (!o)
    throw new Error("No handler found in NiceModal.ModalHolder.");
  if (!s)
    throw new Error("No modal found for id: " + r + " in NiceModal.ModalHolder.");
  return o.show = ae(function(l) {
    return uo(a, l);
  }, [a]), o.hide = ae(function() {
    return co(a);
  }, [a]), he.createElement(s, oe({ id: a }, i));
}, $u = function(e) {
  return {
    visible: e.visible,
    onOk: function() {
      return e.hide();
    },
    onCancel: function() {
      return e.hide();
    },
    afterClose: function() {
      e.resolveHide(), e.keepMounted || e.remove();
    }
  };
}, Fu = function(e) {
  return {
    visible: e.visible,
    onClose: function() {
      return e.hide();
    },
    afterVisibleChange: function(t) {
      t || e.resolveHide(), !t && !e.keepMounted && e.remove();
    }
  };
}, Au = function(e) {
  return {
    open: e.visible,
    onClose: function() {
      return e.hide();
    },
    onExited: function() {
      e.resolveHide(), !e.keepMounted && e.remove();
    }
  };
}, ju = function(e) {
  return {
    show: e.visible,
    onHide: function() {
      return e.hide();
    },
    onExited: function() {
      e.resolveHide(), !e.keepMounted && e.remove();
    }
  };
}, Uu = {
  Provider: Lu,
  ModalDef: ku,
  ModalHolder: Nu,
  NiceModalContext: Gt,
  create: Ou,
  register: Jr,
  getModal: Su,
  show: uo,
  hide: co,
  remove: ba,
  useModal: wa,
  reducer: va,
  antdModal: $u,
  antdDrawer: Fu,
  muiDialog: Au,
  bootstrapDialog: ju
};
let Hu = { data: "" }, qu = (e) => typeof window == "object" ? ((e ? e.querySelector("#_goober") : window._goober) || Object.assign((e || document.head).appendChild(document.createElement("style")), { innerHTML: " ", id: "_goober" })).firstChild : e || Hu, zu = /(?:([\u0080-\uFFFF\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\s*)/g, Bu = /\/\*[^]*?\*\/|  +/g, ei = /\n+/g, st = (e, t) => {
  let r = "", n = "", o = "";
  for (let i in e) {
    let a = e[i];
    i[0] == "@" ? i[1] == "i" ? r = i + " " + a + ";" : n += i[1] == "f" ? st(a, i) : i + "{" + st(a, i[1] == "k" ? "" : t) + "}" : typeof a == "object" ? n += st(a, t ? t.replace(/([^,])+/g, (s) => i.replace(/([^,]*:\S+\([^)]*\))|([^,])+/g, (l) => /&/.test(l) ? l.replace(/&/g, s) : s ? s + " " + l : l)) : i) : a != null && (i = /^--/.test(i) ? i : i.replace(/[A-Z]/g, "-$&").toLowerCase(), o += st.p ? st.p(i, a) : i + ":" + a + ";");
  }
  return r + (t && o ? t + "{" + o + "}" : o) + n;
}, Ve = {}, Ea = (e) => {
  if (typeof e == "object") {
    let t = "";
    for (let r in e)
      t += r + Ea(e[r]);
    return t;
  }
  return e;
}, Gu = (e, t, r, n, o) => {
  let i = Ea(e), a = Ve[i] || (Ve[i] = ((l) => {
    let u = 0, c = 11;
    for (; u < l.length; )
      c = 101 * c + l.charCodeAt(u++) >>> 0;
    return "go" + c;
  })(i));
  if (!Ve[a]) {
    let l = i !== e ? e : ((u) => {
      let c, f, m = [{}];
      for (; c = zu.exec(u.replace(Bu, "")); )
        c[4] ? m.shift() : c[3] ? (f = c[3].replace(ei, " ").trim(), m.unshift(m[0][f] = m[0][f] || {})) : m[0][c[1]] = c[2].replace(ei, " ").trim();
      return m[0];
    })(e);
    Ve[a] = st(o ? { ["@keyframes " + a]: l } : l, r ? "" : "." + a);
  }
  let s = r && Ve.g ? Ve.g : null;
  return r && (Ve.g = Ve[a]), ((l, u, c, f) => {
    f ? u.data = u.data.replace(f, l) : u.data.indexOf(l) === -1 && (u.data = c ? l + u.data : u.data + l);
  })(Ve[a], t, n, s), a;
}, Wu = (e, t, r) => e.reduce((n, o, i) => {
  let a = t[i];
  if (a && a.call) {
    let s = a(r), l = s && s.props && s.props.className || /^go/.test(s) && s;
    a = l ? "." + l : s && typeof s == "object" ? s.props ? "" : st(s, "") : s === !1 ? "" : s;
  }
  return n + o + (a ?? "");
}, "");
function Zr(e) {
  let t = this || {}, r = e.call ? e(t.p) : e;
  return Gu(r.unshift ? r.raw ? Wu(r, [].slice.call(arguments, 1), t.p) : r.reduce((n, o) => Object.assign(n, o && o.call ? o(t.p) : o), {}) : r, qu(t.target), t.g, t.o, t.k);
}
let xa, $n, Fn;
Zr.bind({ g: 1 });
let Xe = Zr.bind({ k: 1 });
function Vu(e, t, r, n) {
  st.p = t, xa = e, $n = r, Fn = n;
}
function ft(e, t) {
  let r = this || {};
  return function() {
    let n = arguments;
    function o(i, a) {
      let s = Object.assign({}, i), l = s.className || o.className;
      r.p = Object.assign({ theme: $n && $n() }, s), r.o = / *go\d+/.test(l), s.className = Zr.apply(r, n) + (l ? " " + l : ""), t && (s.ref = a);
      let u = e;
      return e[0] && (u = s.as || e, delete s.as), Fn && u[0] && Fn(s), xa(u, s);
    }
    return t ? t(o) : o;
  };
}
var Ku = (e) => typeof e == "function", Ur = (e, t) => Ku(e) ? e(t) : e, Yu = (() => {
  let e = 0;
  return () => (++e).toString();
})(), Sa = (() => {
  let e;
  return () => {
    if (e === void 0 && typeof window < "u") {
      let t = matchMedia("(prefers-reduced-motion: reduce)");
      e = !t || t.matches;
    }
    return e;
  };
})(), Qu = 20, Ra = (e, t) => {
  switch (t.type) {
    case 0:
      return { ...e, toasts: [t.toast, ...e.toasts].slice(0, Qu) };
    case 1:
      return { ...e, toasts: e.toasts.map((i) => i.id === t.toast.id ? { ...i, ...t.toast } : i) };
    case 2:
      let { toast: r } = t;
      return Ra(e, { type: e.toasts.find((i) => i.id === r.id) ? 1 : 0, toast: r });
    case 3:
      let { toastId: n } = t;
      return { ...e, toasts: e.toasts.map((i) => i.id === n || n === void 0 ? { ...i, dismissed: !0, visible: !1 } : i) };
    case 4:
      return t.toastId === void 0 ? { ...e, toasts: [] } : { ...e, toasts: e.toasts.filter((i) => i.id !== t.toastId) };
    case 5:
      return { ...e, pausedAt: t.time };
    case 6:
      let o = t.time - (e.pausedAt || 0);
      return { ...e, pausedAt: void 0, toasts: e.toasts.map((i) => ({ ...i, pauseDuration: i.pauseDuration + o })) };
  }
}, Nr = [], _t = { toasts: [], pausedAt: void 0 }, Dt = (e) => {
  _t = Ra(_t, e), Nr.forEach((t) => {
    t(_t);
  });
}, Xu = { blank: 4e3, error: 4e3, success: 2e3, loading: 1 / 0, custom: 4e3 }, Ju = (e = {}) => {
  let [t, r] = be(_t), n = zt(_t);
  se(() => (n.current !== _t && r(_t), Nr.push(r), () => {
    let i = Nr.indexOf(r);
    i > -1 && Nr.splice(i, 1);
  }), []);
  let o = t.toasts.map((i) => {
    var a, s, l;
    return { ...e, ...e[i.type], ...i, removeDelay: i.removeDelay || ((a = e[i.type]) == null ? void 0 : a.removeDelay) || (e == null ? void 0 : e.removeDelay), duration: i.duration || ((s = e[i.type]) == null ? void 0 : s.duration) || (e == null ? void 0 : e.duration) || Xu[i.type], style: { ...e.style, ...(l = e[i.type]) == null ? void 0 : l.style, ...i.style } };
  });
  return { ...t, toasts: o };
}, Zu = (e, t = "blank", r) => ({ createdAt: Date.now(), visible: !0, dismissed: !1, type: t, ariaProps: { role: "status", "aria-live": "polite" }, message: e, pauseDuration: 0, ...r, id: (r == null ? void 0 : r.id) || Yu() }), hr = (e) => (t, r) => {
  let n = Zu(t, e, r);
  return Dt({ type: 2, toast: n }), n.id;
}, we = (e, t) => hr("blank")(e, t);
we.error = hr("error");
we.success = hr("success");
we.loading = hr("loading");
we.custom = hr("custom");
we.dismiss = (e) => {
  Dt({ type: 3, toastId: e });
};
we.remove = (e) => Dt({ type: 4, toastId: e });
we.promise = (e, t, r) => {
  let n = we.loading(t.loading, { ...r, ...r == null ? void 0 : r.loading });
  return typeof e == "function" && (e = e()), e.then((o) => {
    let i = t.success ? Ur(t.success, o) : void 0;
    return i ? we.success(i, { id: n, ...r, ...r == null ? void 0 : r.success }) : we.dismiss(n), o;
  }).catch((o) => {
    let i = t.error ? Ur(t.error, o) : void 0;
    i ? we.error(i, { id: n, ...r, ...r == null ? void 0 : r.error }) : we.dismiss(n);
  }), e;
};
var ec = (e, t) => {
  Dt({ type: 1, toast: { id: e, height: t } });
}, tc = () => {
  Dt({ type: 5, time: Date.now() });
}, lr = /* @__PURE__ */ new Map(), rc = 1e3, nc = (e, t = rc) => {
  if (lr.has(e))
    return;
  let r = setTimeout(() => {
    lr.delete(e), Dt({ type: 4, toastId: e });
  }, t);
  lr.set(e, r);
}, oc = (e) => {
  let { toasts: t, pausedAt: r } = Ju(e);
  se(() => {
    if (r)
      return;
    let i = Date.now(), a = t.map((s) => {
      if (s.duration === 1 / 0)
        return;
      let l = (s.duration || 0) + s.pauseDuration - (i - s.createdAt);
      if (l < 0) {
        s.visible && we.dismiss(s.id);
        return;
      }
      return setTimeout(() => we.dismiss(s.id), l);
    });
    return () => {
      a.forEach((s) => s && clearTimeout(s));
    };
  }, [t, r]);
  let n = ae(() => {
    r && Dt({ type: 6, time: Date.now() });
  }, [r]), o = ae((i, a) => {
    let { reverseOrder: s = !1, gutter: l = 8, defaultPosition: u } = a || {}, c = t.filter((p) => (p.position || u) === (i.position || u) && p.height), f = c.findIndex((p) => p.id === i.id), m = c.filter((p, b) => b < f && p.visible).length;
    return c.filter((p) => p.visible).slice(...s ? [m + 1] : [0, m]).reduce((p, b) => p + (b.height || 0) + l, 0);
  }, [t]);
  return se(() => {
    t.forEach((i) => {
      if (i.dismissed)
        nc(i.id, i.removeDelay);
      else {
        let a = lr.get(i.id);
        a && (clearTimeout(a), lr.delete(i.id));
      }
    });
  }, [t]), { toasts: t, handlers: { updateHeight: ec, startPause: tc, endPause: n, calculateOffset: o } };
}, ic = Xe`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
 transform: scale(1) rotate(45deg);
  opacity: 1;
}`, ac = Xe`
from {
  transform: scale(0);
  opacity: 0;
}
to {
  transform: scale(1);
  opacity: 1;
}`, sc = Xe`
from {
  transform: scale(0) rotate(90deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(90deg);
	opacity: 1;
}`, lc = ft("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#ff4b4b"};
  position: relative;
  transform: rotate(45deg);

  animation: ${ic} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;

  &:after,
  &:before {
    content: '';
    animation: ${ac} 0.15s ease-out forwards;
    animation-delay: 150ms;
    position: absolute;
    border-radius: 3px;
    opacity: 0;
    background: ${(e) => e.secondary || "#fff"};
    bottom: 9px;
    left: 4px;
    height: 2px;
    width: 12px;
  }

  &:before {
    animation: ${sc} 0.15s ease-out forwards;
    animation-delay: 180ms;
    transform: rotate(90deg);
  }
`, uc = Xe`
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
`, cc = ft("div")`
  width: 12px;
  height: 12px;
  box-sizing: border-box;
  border: 2px solid;
  border-radius: 100%;
  border-color: ${(e) => e.secondary || "#e0e0e0"};
  border-right-color: ${(e) => e.primary || "#616161"};
  animation: ${uc} 1s linear infinite;
`, dc = Xe`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(45deg);
	opacity: 1;
}`, fc = Xe`
0% {
	height: 0;
	width: 0;
	opacity: 0;
}
40% {
  height: 0;
	width: 6px;
	opacity: 1;
}
100% {
  opacity: 1;
  height: 10px;
}`, hc = ft("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#61d345"};
  position: relative;
  transform: rotate(45deg);

  animation: ${dc} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;
  &:after {
    content: '';
    box-sizing: border-box;
    animation: ${fc} 0.2s ease-out forwards;
    opacity: 0;
    animation-delay: 200ms;
    position: absolute;
    border-right: 2px solid;
    border-bottom: 2px solid;
    border-color: ${(e) => e.secondary || "#fff"};
    bottom: 6px;
    left: 6px;
    height: 10px;
    width: 6px;
  }
`, pc = ft("div")`
  position: absolute;
`, mc = ft("div")`
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
  min-width: 20px;
  min-height: 20px;
`, gc = Xe`
from {
  transform: scale(0.6);
  opacity: 0.4;
}
to {
  transform: scale(1);
  opacity: 1;
}`, yc = ft("div")`
  position: relative;
  transform: scale(0.6);
  opacity: 0.4;
  min-width: 20px;
  animation: ${gc} 0.3s 0.12s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
`, vc = ({ toast: e }) => {
  let { icon: t, type: r, iconTheme: n } = e;
  return t !== void 0 ? typeof t == "string" ? O(yc, null, t) : t : r === "blank" ? null : O(mc, null, O(cc, { ...n }), r !== "loading" && O(pc, null, r === "error" ? O(lc, { ...n }) : O(hc, { ...n })));
}, bc = (e) => `
0% {transform: translate3d(0,${e * -200}%,0) scale(.6); opacity:.5;}
100% {transform: translate3d(0,0,0) scale(1); opacity:1;}
`, wc = (e) => `
0% {transform: translate3d(0,0,-1px) scale(1); opacity:1;}
100% {transform: translate3d(0,${e * -150}%,-1px) scale(.6); opacity:0;}
`, _c = "0%{opacity:0;} 100%{opacity:1;}", Ec = "0%{opacity:1;} 100%{opacity:0;}", xc = ft("div")`
  display: flex;
  align-items: center;
  background: #fff;
  color: #363636;
  line-height: 1.3;
  will-change: transform;
  box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1), 0 3px 3px rgba(0, 0, 0, 0.05);
  max-width: 350px;
  pointer-events: auto;
  padding: 8px 10px;
  border-radius: 8px;
`, Sc = ft("div")`
  display: flex;
  justify-content: center;
  margin: 4px 10px;
  color: inherit;
  flex: 1 1 auto;
  white-space: pre-line;
`, Rc = (e, t) => {
  let r = e.includes("top") ? 1 : -1, [n, o] = Sa() ? [_c, Ec] : [bc(r), wc(r)];
  return { animation: t ? `${Xe(n)} 0.35s cubic-bezier(.21,1.02,.73,1) forwards` : `${Xe(o)} 0.4s forwards cubic-bezier(.06,.71,.55,1)` };
}, Cc = io(({ toast: e, position: t, style: r, children: n }) => {
  let o = e.height ? Rc(e.position || t || "top-center", e.visible) : { opacity: 0 }, i = O(vc, { toast: e }), a = O(Sc, { ...e.ariaProps }, Ur(e.message, e));
  return O(xc, { className: e.className, style: { ...o, ...r, ...e.style } }, typeof n == "function" ? n({ icon: i, message: a }) : O(Ct, null, i, a));
});
Vu(O);
var Pc = ({ id: e, className: t, style: r, onHeightUpdate: n, children: o }) => {
  let i = ae((a) => {
    if (a) {
      let s = () => {
        let l = a.getBoundingClientRect().height;
        n(e, l);
      };
      s(), new MutationObserver(s).observe(a, { subtree: !0, childList: !0, characterData: !0 });
    }
  }, [e, n]);
  return O("div", { ref: i, className: t, style: r }, o);
}, Tc = (e, t) => {
  let r = e.includes("top"), n = r ? { top: 0 } : { bottom: 0 }, o = e.includes("center") ? { justifyContent: "center" } : e.includes("right") ? { justifyContent: "flex-end" } : {};
  return { left: 0, right: 0, display: "flex", position: "absolute", transition: Sa() ? void 0 : "all 230ms cubic-bezier(.21,1.02,.73,1)", transform: `translateY(${t * (r ? 1 : -1)}px)`, ...n, ...o };
}, Dc = Zr`
  z-index: 9999;
  > * {
    pointer-events: auto;
  }
`, Rr = 16, Oc = ({ reverseOrder: e, position: t = "top-center", toastOptions: r, gutter: n, children: o, containerStyle: i, containerClassName: a }) => {
  let { toasts: s, handlers: l } = oc(r);
  return O("div", { id: "_rht_toaster", style: { position: "fixed", zIndex: 9999, top: Rr, left: Rr, right: Rr, bottom: Rr, pointerEvents: "none", ...i }, className: a, onMouseEnter: l.startPause, onMouseLeave: l.endPause }, s.map((u) => {
    let c = u.position || t, f = l.calculateOffset(u, { reverseOrder: e, gutter: n, defaultPosition: t }), m = Tc(c, f);
    return O(Pc, { id: u.id, key: u.id, onHeightUpdate: l.updateHeight, className: u.visible ? Dc : "", style: m }, u.type === "custom" ? Ur(u.message, u) : o ? o(u) : O(Cc, { toast: u, position: c }));
  }));
};
const Mc = pe({
  isAnyTextFieldFocused: !1,
  setFocusState: () => {
  },
  // fetchKoenigLexical: async () => {},
  darkMode: !1
}), Ic = ({ darkMode: e, children: t }) => {
  const [r, n] = be(!1), o = (i) => {
    n(i);
  };
  return /* @__PURE__ */ B.jsx(Mc.Provider, { value: { isAnyTextFieldFocused: r, setFocusState: o, darkMode: e }, children: /* @__PURE__ */ B.jsxs(Eu, { children: [
    /* @__PURE__ */ B.jsx(Oc, {}),
    /* @__PURE__ */ B.jsx(Uu.Provider, { children: t })
  ] }) });
}, Lc = ({ darkMode: e, fetchKoenigLexical: t, className: r, children: n, ...o }) => {
  const i = sa(
    "shade",
    r
  );
  return /* @__PURE__ */ B.jsx("div", { className: i, ...o, children: /* @__PURE__ */ B.jsx(Ic, { darkMode: e, children: n }) });
}, kc = () => /* @__PURE__ */ B.jsx(jl, { children: /* @__PURE__ */ B.jsx("header", { className: "flex h-[102px] items-center justify-between px-8", children: /* @__PURE__ */ B.jsx(pa, { children: "Stats" }) }) }), Nc = "/stats-x", $c = [
  {
    path: "",
    index: !0,
    element: /* @__PURE__ */ B.jsx(kc, {})
  }
], Ca = Object.prototype.toString;
function fo(e) {
  switch (Ca.call(e)) {
    case "[object Error]":
    case "[object Exception]":
    case "[object DOMException]":
      return !0;
    default:
      return Pt(e, Error);
  }
}
function Vt(e, t) {
  return Ca.call(e) === `[object ${t}]`;
}
function ho(e) {
  return Vt(e, "ErrorEvent");
}
function ti(e) {
  return Vt(e, "DOMError");
}
function Fc(e) {
  return Vt(e, "DOMException");
}
function Qe(e) {
  return Vt(e, "String");
}
function Pa(e) {
  return typeof e == "object" && e !== null && "__sentry_template_string__" in e && "__sentry_template_values__" in e;
}
function Ta(e) {
  return e === null || Pa(e) || typeof e != "object" && typeof e != "function";
}
function en(e) {
  return Vt(e, "Object");
}
function tn(e) {
  return typeof Event < "u" && Pt(e, Event);
}
function Ac(e) {
  return typeof Element < "u" && Pt(e, Element);
}
function jc(e) {
  return Vt(e, "RegExp");
}
function po(e) {
  return !!(e && e.then && typeof e.then == "function");
}
function Uc(e) {
  return en(e) && "nativeEvent" in e && "preventDefault" in e && "stopPropagation" in e;
}
function Hc(e) {
  return typeof e == "number" && e !== e;
}
function Pt(e, t) {
  try {
    return e instanceof t;
  } catch {
    return !1;
  }
}
function Da(e) {
  return !!(typeof e == "object" && e !== null && (e.__isVue || e._isVue));
}
function An(e, t = 0) {
  return typeof e != "string" || t === 0 || e.length <= t ? e : `${e.slice(0, t)}...`;
}
function ri(e, t) {
  if (!Array.isArray(e))
    return "";
  const r = [];
  for (let n = 0; n < e.length; n++) {
    const o = e[n];
    try {
      Da(o) ? r.push("[VueViewModel]") : r.push(String(o));
    } catch {
      r.push("[value cannot be serialized]");
    }
  }
  return r.join(t);
}
function qc(e, t, r = !1) {
  return Qe(e) ? jc(t) ? t.test(e) : Qe(t) ? r ? e === t : e.includes(t) : !1 : !1;
}
function rn(e, t = [], r = !1) {
  return t.some((n) => qc(e, n, r));
}
function zc(e, t, r = 250, n, o, i, a) {
  if (!i.exception || !i.exception.values || !a || !Pt(a.originalException, Error))
    return;
  const s = i.exception.values.length > 0 ? i.exception.values[i.exception.values.length - 1] : void 0;
  s && (i.exception.values = Bc(
    jn(
      e,
      t,
      o,
      a.originalException,
      n,
      i.exception.values,
      s,
      0
    ),
    r
  ));
}
function jn(e, t, r, n, o, i, a, s) {
  if (i.length >= r + 1)
    return i;
  let l = [...i];
  if (Pt(n[o], Error)) {
    ni(a, s);
    const u = e(t, n[o]), c = l.length;
    oi(u, o, c, s), l = jn(
      e,
      t,
      r,
      n[o],
      o,
      [u, ...l],
      u,
      c
    );
  }
  return Array.isArray(n.errors) && n.errors.forEach((u, c) => {
    if (Pt(u, Error)) {
      ni(a, s);
      const f = e(t, u), m = l.length;
      oi(f, `errors[${c}]`, m, s), l = jn(
        e,
        t,
        r,
        u,
        o,
        [f, ...l],
        f,
        m
      );
    }
  }), l;
}
function ni(e, t) {
  e.mechanism = e.mechanism || { type: "generic", handled: !0 }, e.mechanism = {
    ...e.mechanism,
    ...e.type === "AggregateError" && { is_exception_group: !0 },
    exception_id: t
  };
}
function oi(e, t, r, n) {
  e.mechanism = e.mechanism || { type: "generic", handled: !0 }, e.mechanism = {
    ...e.mechanism,
    type: "chained",
    source: t,
    exception_id: r,
    parent_id: n
  };
}
function Bc(e, t) {
  return e.map((r) => (r.value && (r.value = An(r.value, t)), r));
}
function Cr(e) {
  return e && e.Math == Math ? e : void 0;
}
const V = typeof globalThis == "object" && Cr(globalThis) || // eslint-disable-next-line no-restricted-globals
typeof window == "object" && Cr(window) || typeof self == "object" && Cr(self) || typeof global == "object" && Cr(global) || function() {
  return this;
}() || {};
function mo() {
  return V;
}
function Oa(e, t, r) {
  const n = r || V, o = n.__SENTRY__ = n.__SENTRY__ || {};
  return o[e] || (o[e] = t());
}
const go = mo(), Gc = 80;
function Ma(e, t = {}) {
  if (!e)
    return "<unknown>";
  try {
    let r = e;
    const n = 5, o = [];
    let i = 0, a = 0;
    const s = " > ", l = s.length;
    let u;
    const c = Array.isArray(t) ? t : t.keyAttrs, f = !Array.isArray(t) && t.maxStringLength || Gc;
    for (; r && i++ < n && (u = Wc(r, c), !(u === "html" || i > 1 && a + o.length * l + u.length >= f)); )
      o.push(u), a += u.length, r = r.parentNode;
    return o.reverse().join(s);
  } catch {
    return "<unknown>";
  }
}
function Wc(e, t) {
  const r = e, n = [];
  let o, i, a, s, l;
  if (!r || !r.tagName)
    return "";
  if (go.HTMLElement && r instanceof HTMLElement && r.dataset && r.dataset.sentryComponent)
    return r.dataset.sentryComponent;
  n.push(r.tagName.toLowerCase());
  const u = t && t.length ? t.filter((f) => r.getAttribute(f)).map((f) => [f, r.getAttribute(f)]) : null;
  if (u && u.length)
    u.forEach((f) => {
      n.push(`[${f[0]}="${f[1]}"]`);
    });
  else if (r.id && n.push(`#${r.id}`), o = r.className, o && Qe(o))
    for (i = o.split(/\s+/), l = 0; l < i.length; l++)
      n.push(`.${i[l]}`);
  const c = ["aria-label", "type", "name", "title", "alt"];
  for (l = 0; l < c.length; l++)
    a = c[l], s = r.getAttribute(a), s && n.push(`[${a}="${s}"]`);
  return n.join("");
}
function Vc() {
  try {
    return go.document.location.href;
  } catch {
    return "";
  }
}
function Kc(e) {
  if (!go.HTMLElement)
    return null;
  let t = e;
  const r = 5;
  for (let n = 0; n < r; n++) {
    if (!t)
      return null;
    if (t instanceof HTMLElement && t.dataset.sentryComponent)
      return t.dataset.sentryComponent;
    t = t.parentNode;
  }
  return null;
}
const pr = typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__, Yc = "Sentry Logger ", Un = [
  "debug",
  "info",
  "warn",
  "error",
  "log",
  "assert",
  "trace"
], Hr = {};
function yo(e) {
  if (!("console" in V))
    return e();
  const t = V.console, r = {}, n = Object.keys(Hr);
  n.forEach((o) => {
    const i = Hr[o];
    r[o] = t[o], t[o] = i;
  });
  try {
    return e();
  } finally {
    n.forEach((o) => {
      t[o] = r[o];
    });
  }
}
function Qc() {
  let e = !1;
  const t = {
    enable: () => {
      e = !0;
    },
    disable: () => {
      e = !1;
    },
    isEnabled: () => e
  };
  return pr ? Un.forEach((r) => {
    t[r] = (...n) => {
      e && yo(() => {
        V.console[r](`${Yc}[${r}]:`, ...n);
      });
    };
  }) : Un.forEach((r) => {
    t[r] = () => {
    };
  }), t;
}
const G = Qc(), Xc = /^(?:(\w+):)\/\/(?:(\w+)(?::(\w+)?)?@)([\w.-]+)(?::(\d+))?\/(.+)/;
function Jc(e) {
  return e === "http" || e === "https";
}
function Zc(e, t = !1) {
  const { host: r, path: n, pass: o, port: i, projectId: a, protocol: s, publicKey: l } = e;
  return `${s}://${l}${t && o ? `:${o}` : ""}@${r}${i ? `:${i}` : ""}/${n && `${n}/`}${a}`;
}
function ed(e) {
  const t = Xc.exec(e);
  if (!t) {
    yo(() => {
      console.error(`Invalid Sentry Dsn: ${e}`);
    });
    return;
  }
  const [r, n, o = "", i, a = "", s] = t.slice(1);
  let l = "", u = s;
  const c = u.split("/");
  if (c.length > 1 && (l = c.slice(0, -1).join("/"), u = c.pop()), u) {
    const f = u.match(/^\d+/);
    f && (u = f[0]);
  }
  return Ia({ host: i, pass: o, path: l, projectId: u, port: a, protocol: r, publicKey: n });
}
function Ia(e) {
  return {
    protocol: e.protocol,
    publicKey: e.publicKey || "",
    pass: e.pass || "",
    host: e.host,
    port: e.port || "",
    path: e.path || "",
    projectId: e.projectId
  };
}
function td(e) {
  if (!pr)
    return !0;
  const { port: t, projectId: r, protocol: n } = e;
  return ["protocol", "publicKey", "host", "projectId"].find((a) => e[a] ? !1 : (G.error(`Invalid Sentry Dsn: ${a} missing`), !0)) ? !1 : r.match(/^\d+$/) ? Jc(n) ? t && isNaN(parseInt(t, 10)) ? (G.error(`Invalid Sentry Dsn: Invalid port ${t}`), !1) : !0 : (G.error(`Invalid Sentry Dsn: Invalid protocol ${n}`), !1) : (G.error(`Invalid Sentry Dsn: Invalid projectId ${r}`), !1);
}
function rd(e) {
  const t = typeof e == "string" ? ed(e) : Ia(e);
  if (!(!t || !td(t)))
    return t;
}
function ce(e, t, r) {
  if (!(t in e))
    return;
  const n = e[t], o = r(n);
  typeof o == "function" && La(o, n), e[t] = o;
}
function qr(e, t, r) {
  try {
    Object.defineProperty(e, t, {
      // enumerable: false, // the default, so we can save on bundle size by not explicitly setting it
      value: r,
      writable: !0,
      configurable: !0
    });
  } catch {
    pr && G.log(`Failed to add non-enumerable property "${t}" to object`, e);
  }
}
function La(e, t) {
  try {
    const r = t.prototype || {};
    e.prototype = t.prototype = r, qr(e, "__sentry_original__", t);
  } catch {
  }
}
function vo(e) {
  return e.__sentry_original__;
}
function ka(e) {
  if (fo(e))
    return {
      message: e.message,
      name: e.name,
      stack: e.stack,
      ...ai(e)
    };
  if (tn(e)) {
    const t = {
      type: e.type,
      target: ii(e.target),
      currentTarget: ii(e.currentTarget),
      ...ai(e)
    };
    return typeof CustomEvent < "u" && Pt(e, CustomEvent) && (t.detail = e.detail), t;
  } else
    return e;
}
function ii(e) {
  try {
    return Ac(e) ? Ma(e) : Object.prototype.toString.call(e);
  } catch {
    return "<unknown>";
  }
}
function ai(e) {
  if (typeof e == "object" && e !== null) {
    const t = {};
    for (const r in e)
      Object.prototype.hasOwnProperty.call(e, r) && (t[r] = e[r]);
    return t;
  } else
    return {};
}
function nd(e, t = 40) {
  const r = Object.keys(ka(e));
  if (r.sort(), !r.length)
    return "[object has no keys]";
  if (r[0].length >= t)
    return An(r[0], t);
  for (let n = r.length; n > 0; n--) {
    const o = r.slice(0, n).join(", ");
    if (!(o.length > t))
      return n === r.length ? o : An(o, t);
  }
  return "";
}
function Et(e) {
  return Hn(e, /* @__PURE__ */ new Map());
}
function Hn(e, t) {
  if (od(e)) {
    const r = t.get(e);
    if (r !== void 0)
      return r;
    const n = {};
    t.set(e, n);
    for (const o of Object.keys(e))
      typeof e[o] < "u" && (n[o] = Hn(e[o], t));
    return n;
  }
  if (Array.isArray(e)) {
    const r = t.get(e);
    if (r !== void 0)
      return r;
    const n = [];
    return t.set(e, n), e.forEach((o) => {
      n.push(Hn(o, t));
    }), n;
  }
  return e;
}
function od(e) {
  if (!en(e))
    return !1;
  try {
    const t = Object.getPrototypeOf(e).constructor.name;
    return !t || t === "Object";
  } catch {
    return !0;
  }
}
const Rn = "<anonymous>";
function ct(e) {
  try {
    return !e || typeof e != "function" ? Rn : e.name || Rn;
  } catch {
    return Rn;
  }
}
const $r = {}, si = {};
function Ot(e, t) {
  $r[e] = $r[e] || [], $r[e].push(t);
}
function Mt(e, t) {
  si[e] || (t(), si[e] = !0);
}
function Ie(e, t) {
  const r = e && $r[e];
  if (r)
    for (const n of r)
      try {
        n(t);
      } catch (o) {
        pr && G.error(
          `Error while triggering instrumentation handler.
Type: ${e}
Name: ${ct(n)}
Error:`,
          o
        );
      }
}
function id(e) {
  const t = "console";
  Ot(t, e), Mt(t, ad);
}
function ad() {
  "console" in V && Un.forEach(function(e) {
    e in V.console && ce(V.console, e, function(t) {
      return Hr[e] = t, function(...r) {
        Ie("console", { args: r, level: e });
        const o = Hr[e];
        o && o.apply(V.console, r);
      };
    });
  });
}
function Le() {
  const e = V, t = e.crypto || e.msCrypto;
  let r = () => Math.random() * 16;
  try {
    if (t && t.randomUUID)
      return t.randomUUID().replace(/-/g, "");
    t && t.getRandomValues && (r = () => {
      const n = new Uint8Array(1);
      return t.getRandomValues(n), n[0];
    });
  } catch {
  }
  return ([1e7] + 1e3 + 4e3 + 8e3 + 1e11).replace(
    /[018]/g,
    (n) => (
      // eslint-disable-next-line no-bitwise
      (n ^ (r() & 15) >> n / 4).toString(16)
    )
  );
}
function Na(e) {
  return e.exception && e.exception.values ? e.exception.values[0] : void 0;
}
function lt(e) {
  const { message: t, event_id: r } = e;
  if (t)
    return t;
  const n = Na(e);
  return n ? n.type && n.value ? `${n.type}: ${n.value}` : n.type || n.value || r || "<unknown>" : r || "<unknown>";
}
function qn(e, t, r) {
  const n = e.exception = e.exception || {}, o = n.values = n.values || [], i = o[0] = o[0] || {};
  i.value || (i.value = t || ""), i.type || (i.type = r || "Error");
}
function zn(e, t) {
  const r = Na(e);
  if (!r)
    return;
  const n = { type: "generic", handled: !0 }, o = r.mechanism;
  if (r.mechanism = { ...n, ...o, ...t }, t && "data" in t) {
    const i = { ...o && o.data, ...t.data };
    r.mechanism.data = i;
  }
}
function sd(e) {
  return Array.isArray(e) ? e : [e];
}
const At = V, ld = 1e3;
let li, Bn, Gn;
function ud(e) {
  const t = "dom";
  Ot(t, e), Mt(t, cd);
}
function cd() {
  if (!At.document)
    return;
  const e = Ie.bind(null, "dom"), t = ui(e, !0);
  At.document.addEventListener("click", t, !1), At.document.addEventListener("keypress", t, !1), ["EventTarget", "Node"].forEach((r) => {
    const n = At[r] && At[r].prototype;
    !n || !n.hasOwnProperty || !n.hasOwnProperty("addEventListener") || (ce(n, "addEventListener", function(o) {
      return function(i, a, s) {
        if (i === "click" || i == "keypress")
          try {
            const l = this, u = l.__sentry_instrumentation_handlers__ = l.__sentry_instrumentation_handlers__ || {}, c = u[i] = u[i] || { refCount: 0 };
            if (!c.handler) {
              const f = ui(e);
              c.handler = f, o.call(this, i, f, s);
            }
            c.refCount++;
          } catch {
          }
        return o.call(this, i, a, s);
      };
    }), ce(
      n,
      "removeEventListener",
      function(o) {
        return function(i, a, s) {
          if (i === "click" || i == "keypress")
            try {
              const l = this, u = l.__sentry_instrumentation_handlers__ || {}, c = u[i];
              c && (c.refCount--, c.refCount <= 0 && (o.call(this, i, c.handler, s), c.handler = void 0, delete u[i]), Object.keys(u).length === 0 && delete l.__sentry_instrumentation_handlers__);
            } catch {
            }
          return o.call(this, i, a, s);
        };
      }
    ));
  });
}
function dd(e) {
  if (e.type !== Bn)
    return !1;
  try {
    if (!e.target || e.target._sentryId !== Gn)
      return !1;
  } catch {
  }
  return !0;
}
function fd(e, t) {
  return e !== "keypress" ? !1 : !t || !t.tagName ? !0 : !(t.tagName === "INPUT" || t.tagName === "TEXTAREA" || t.isContentEditable);
}
function ui(e, t = !1) {
  return (r) => {
    if (!r || r._sentryCaptured)
      return;
    const n = hd(r);
    if (fd(r.type, n))
      return;
    qr(r, "_sentryCaptured", !0), n && !n._sentryId && qr(n, "_sentryId", Le());
    const o = r.type === "keypress" ? "input" : r.type;
    dd(r) || (e({ event: r, name: o, global: t }), Bn = r.type, Gn = n ? n._sentryId : void 0), clearTimeout(li), li = At.setTimeout(() => {
      Gn = void 0, Bn = void 0;
    }, ld);
  };
}
function hd(e) {
  try {
    return e.target;
  } catch {
    return null;
  }
}
const Wn = mo();
function pd() {
  if (!("fetch" in Wn))
    return !1;
  try {
    return new Headers(), new Request("http://www.example.com"), new Response(), !0;
  } catch {
    return !1;
  }
}
function ci(e) {
  return e && /^function fetch\(\)\s+\{\s+\[native code\]\s+\}$/.test(e.toString());
}
function md() {
  if (typeof EdgeRuntime == "string")
    return !0;
  if (!pd())
    return !1;
  if (ci(Wn.fetch))
    return !0;
  let e = !1;
  const t = Wn.document;
  if (t && typeof t.createElement == "function")
    try {
      const r = t.createElement("iframe");
      r.hidden = !0, t.head.appendChild(r), r.contentWindow && r.contentWindow.fetch && (e = ci(r.contentWindow.fetch)), t.head.removeChild(r);
    } catch (r) {
      pr && G.warn("Could not create sandbox iframe for pure fetch check, bailing to window.fetch: ", r);
    }
  return e;
}
function gd(e) {
  const t = "fetch";
  Ot(t, e), Mt(t, yd);
}
function yd() {
  md() && ce(V, "fetch", function(e) {
    return function(...t) {
      const { method: r, url: n } = vd(t), o = {
        args: t,
        fetchData: {
          method: r,
          url: n
        },
        startTimestamp: Date.now()
      };
      return Ie("fetch", {
        ...o
      }), e.apply(V, t).then(
        (i) => {
          const a = {
            ...o,
            endTimestamp: Date.now(),
            response: i
          };
          return Ie("fetch", a), i;
        },
        (i) => {
          const a = {
            ...o,
            endTimestamp: Date.now(),
            error: i
          };
          throw Ie("fetch", a), i;
        }
      );
    };
  });
}
function Vn(e, t) {
  return !!e && typeof e == "object" && !!e[t];
}
function di(e) {
  return typeof e == "string" ? e : e ? Vn(e, "url") ? e.url : e.toString ? e.toString() : "" : "";
}
function vd(e) {
  if (e.length === 0)
    return { method: "GET", url: "" };
  if (e.length === 2) {
    const [r, n] = e;
    return {
      url: di(r),
      method: Vn(n, "method") ? String(n.method).toUpperCase() : "GET"
    };
  }
  const t = e[0];
  return {
    url: di(t),
    method: Vn(t, "method") ? String(t.method).toUpperCase() : "GET"
  };
}
let Pr = null;
function bd(e) {
  const t = "error";
  Ot(t, e), Mt(t, wd);
}
function wd() {
  Pr = V.onerror, V.onerror = function(e, t, r, n, o) {
    return Ie("error", {
      column: n,
      error: o,
      line: r,
      msg: e,
      url: t
    }), Pr && !Pr.__SENTRY_LOADER__ ? Pr.apply(this, arguments) : !1;
  }, V.onerror.__SENTRY_INSTRUMENTED__ = !0;
}
let Tr = null;
function _d(e) {
  const t = "unhandledrejection";
  Ot(t, e), Mt(t, Ed);
}
function Ed() {
  Tr = V.onunhandledrejection, V.onunhandledrejection = function(e) {
    return Ie("unhandledrejection", e), Tr && !Tr.__SENTRY_LOADER__ ? Tr.apply(this, arguments) : !0;
  }, V.onunhandledrejection.__SENTRY_INSTRUMENTED__ = !0;
}
const Dr = mo();
function xd() {
  const e = Dr.chrome, t = e && e.app && e.app.runtime, r = "history" in Dr && !!Dr.history.pushState && !!Dr.history.replaceState;
  return !t && r;
}
const tr = V;
let Or;
function Sd(e) {
  const t = "history";
  Ot(t, e), Mt(t, Rd);
}
function Rd() {
  if (!xd())
    return;
  const e = tr.onpopstate;
  tr.onpopstate = function(...r) {
    const n = tr.location.href, o = Or;
    if (Or = n, Ie("history", { from: o, to: n }), e)
      try {
        return e.apply(this, r);
      } catch {
      }
  };
  function t(r) {
    return function(...n) {
      const o = n.length > 2 ? n[2] : void 0;
      if (o) {
        const i = Or, a = String(o);
        Or = a, Ie("history", { from: i, to: a });
      }
      return r.apply(this, n);
    };
  }
  ce(tr.history, "pushState", t), ce(tr.history, "replaceState", t);
}
const Cd = V, ir = "__sentry_xhr_v3__";
function Pd(e) {
  const t = "xhr";
  Ot(t, e), Mt(t, Td);
}
function Td() {
  if (!Cd.XMLHttpRequest)
    return;
  const e = XMLHttpRequest.prototype;
  ce(e, "open", function(t) {
    return function(...r) {
      const n = Date.now(), o = Qe(r[0]) ? r[0].toUpperCase() : void 0, i = Dd(r[1]);
      if (!o || !i)
        return t.apply(this, r);
      this[ir] = {
        method: o,
        url: i,
        request_headers: {}
      }, o === "POST" && i.match(/sentry_key/) && (this.__sentry_own_request__ = !0);
      const a = () => {
        const s = this[ir];
        if (s && this.readyState === 4) {
          try {
            s.status_code = this.status;
          } catch {
          }
          const l = {
            args: [o, i],
            endTimestamp: Date.now(),
            startTimestamp: n,
            xhr: this
          };
          Ie("xhr", l);
        }
      };
      return "onreadystatechange" in this && typeof this.onreadystatechange == "function" ? ce(this, "onreadystatechange", function(s) {
        return function(...l) {
          return a(), s.apply(this, l);
        };
      }) : this.addEventListener("readystatechange", a), ce(this, "setRequestHeader", function(s) {
        return function(...l) {
          const [u, c] = l, f = this[ir];
          return f && Qe(u) && Qe(c) && (f.request_headers[u.toLowerCase()] = c), s.apply(this, l);
        };
      }), t.apply(this, r);
    };
  }), ce(e, "send", function(t) {
    return function(...r) {
      const n = this[ir];
      if (!n)
        return t.apply(this, r);
      r[0] !== void 0 && (n.body = r[0]);
      const o = {
        args: [n.method, n.url],
        startTimestamp: Date.now(),
        xhr: this
      };
      return Ie("xhr", o), t.apply(this, r);
    };
  });
}
function Dd(e) {
  if (Qe(e))
    return e;
  try {
    return e.toString();
  } catch {
  }
}
function Od() {
  const e = typeof WeakSet == "function", t = e ? /* @__PURE__ */ new WeakSet() : [];
  function r(o) {
    if (e)
      return t.has(o) ? !0 : (t.add(o), !1);
    for (let i = 0; i < t.length; i++)
      if (t[i] === o)
        return !0;
    return t.push(o), !1;
  }
  function n(o) {
    if (e)
      t.delete(o);
    else
      for (let i = 0; i < t.length; i++)
        if (t[i] === o) {
          t.splice(i, 1);
          break;
        }
  }
  return [r, n];
}
function Md(e, t = 100, r = 1 / 0) {
  try {
    return Kn("", e, t, r);
  } catch (n) {
    return { ERROR: `**non-serializable** (${n})` };
  }
}
function $a(e, t = 3, r = 100 * 1024) {
  const n = Md(e, t);
  return Nd(n) > r ? $a(e, t - 1, r) : n;
}
function Kn(e, t, r = 1 / 0, n = 1 / 0, o = Od()) {
  const [i, a] = o;
  if (t == null || // this matches null and undefined -> eqeq not eqeqeq
  ["number", "boolean", "string"].includes(typeof t) && !Hc(t))
    return t;
  const s = Id(e, t);
  if (!s.startsWith("[object "))
    return s;
  if (t.__sentry_skip_normalization__)
    return t;
  const l = typeof t.__sentry_override_normalization_depth__ == "number" ? t.__sentry_override_normalization_depth__ : r;
  if (l === 0)
    return s.replace("object ", "");
  if (i(t))
    return "[Circular ~]";
  const u = t;
  if (u && typeof u.toJSON == "function")
    try {
      const p = u.toJSON();
      return Kn("", p, l - 1, n, o);
    } catch {
    }
  const c = Array.isArray(t) ? [] : {};
  let f = 0;
  const m = ka(t);
  for (const p in m) {
    if (!Object.prototype.hasOwnProperty.call(m, p))
      continue;
    if (f >= n) {
      c[p] = "[MaxProperties ~]";
      break;
    }
    const b = m[p];
    c[p] = Kn(p, b, l - 1, n, o), f++;
  }
  return a(t), c;
}
function Id(e, t) {
  try {
    if (e === "domain" && t && typeof t == "object" && t._events)
      return "[Domain]";
    if (e === "domainEmitter")
      return "[DomainEmitter]";
    if (typeof global < "u" && t === global)
      return "[Global]";
    if (typeof window < "u" && t === window)
      return "[Window]";
    if (typeof document < "u" && t === document)
      return "[Document]";
    if (Da(t))
      return "[VueViewModel]";
    if (Uc(t))
      return "[SyntheticEvent]";
    if (typeof t == "number" && t !== t)
      return "[NaN]";
    if (typeof t == "function")
      return `[Function: ${ct(t)}]`;
    if (typeof t == "symbol")
      return `[${String(t)}]`;
    if (typeof t == "bigint")
      return `[BigInt: ${String(t)}]`;
    const r = Ld(t);
    return /^HTML(\w*)Element$/.test(r) ? `[HTMLElement: ${r}]` : `[object ${r}]`;
  } catch (r) {
    return `**non-serializable** (${r})`;
  }
}
function Ld(e) {
  const t = Object.getPrototypeOf(e);
  return t ? t.constructor.name : "null prototype";
}
function kd(e) {
  return ~-encodeURI(e).split(/%..|./).length;
}
function Nd(e) {
  return kd(JSON.stringify(e));
}
var Ke;
(function(e) {
  e[e.PENDING = 0] = "PENDING";
  const r = 1;
  e[e.RESOLVED = r] = "RESOLVED";
  const n = 2;
  e[e.REJECTED = n] = "REJECTED";
})(Ke || (Ke = {}));
class it {
  constructor(t) {
    it.prototype.__init.call(this), it.prototype.__init2.call(this), it.prototype.__init3.call(this), it.prototype.__init4.call(this), this._state = Ke.PENDING, this._handlers = [];
    try {
      t(this._resolve, this._reject);
    } catch (r) {
      this._reject(r);
    }
  }
  /** JSDoc */
  then(t, r) {
    return new it((n, o) => {
      this._handlers.push([
        !1,
        (i) => {
          if (!t)
            n(i);
          else
            try {
              n(t(i));
            } catch (a) {
              o(a);
            }
        },
        (i) => {
          if (!r)
            o(i);
          else
            try {
              n(r(i));
            } catch (a) {
              o(a);
            }
        }
      ]), this._executeHandlers();
    });
  }
  /** JSDoc */
  catch(t) {
    return this.then((r) => r, t);
  }
  /** JSDoc */
  finally(t) {
    return new it((r, n) => {
      let o, i;
      return this.then(
        (a) => {
          i = !1, o = a, t && t();
        },
        (a) => {
          i = !0, o = a, t && t();
        }
      ).then(() => {
        if (i) {
          n(o);
          return;
        }
        r(o);
      });
    });
  }
  /** JSDoc */
  __init() {
    this._resolve = (t) => {
      this._setResult(Ke.RESOLVED, t);
    };
  }
  /** JSDoc */
  __init2() {
    this._reject = (t) => {
      this._setResult(Ke.REJECTED, t);
    };
  }
  /** JSDoc */
  __init3() {
    this._setResult = (t, r) => {
      if (this._state === Ke.PENDING) {
        if (po(r)) {
          r.then(this._resolve, this._reject);
          return;
        }
        this._state = t, this._value = r, this._executeHandlers();
      }
    };
  }
  /** JSDoc */
  __init4() {
    this._executeHandlers = () => {
      if (this._state === Ke.PENDING)
        return;
      const t = this._handlers.slice();
      this._handlers = [], t.forEach((r) => {
        r[0] || (this._state === Ke.RESOLVED && r[1](this._value), this._state === Ke.REJECTED && r[2](this._value), r[0] = !0);
      });
    };
  }
}
function Cn(e) {
  if (!e)
    return {};
  const t = e.match(/^(([^:/?#]+):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?$/);
  if (!t)
    return {};
  const r = t[6] || "", n = t[8] || "";
  return {
    host: t[4],
    path: t[5],
    protocol: t[2],
    search: r,
    hash: n,
    relative: t[5] + r + n
    // everything minus origin
  };
}
const $d = ["fatal", "error", "warning", "log", "info", "debug"];
function Fd(e) {
  return e === "warn" ? "warning" : $d.includes(e) ? e : "log";
}
const Fa = 1e3;
function bo() {
  return Date.now() / Fa;
}
function Ad() {
  const { performance: e } = V;
  if (!e || !e.now)
    return bo;
  const t = Date.now() - e.now(), r = e.timeOrigin == null ? t : e.timeOrigin;
  return () => (r + e.now()) / Fa;
}
const Aa = Ad();
(() => {
  const { performance: e } = V;
  if (!e || !e.now)
    return;
  const t = 3600 * 1e3, r = e.now(), n = Date.now(), o = e.timeOrigin ? Math.abs(e.timeOrigin + r - n) : t, i = o < t, a = e.timing && e.timing.navigationStart, l = typeof a == "number" ? Math.abs(a + r - n) : t, u = l < t;
  return i || u ? o <= l ? e.timeOrigin : a : n;
})();
const Oe = typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__, ja = "production";
function jd() {
  return Oa("globalEventProcessors", () => []);
}
function Yn(e, t, r, n = 0) {
  return new it((o, i) => {
    const a = e[n];
    if (t === null || typeof a != "function")
      o(t);
    else {
      const s = a({ ...t }, r);
      Oe && a.id && s === null && G.log(`Event processor "${a.id}" dropped event`), po(s) ? s.then((l) => Yn(e, l, r, n + 1).then(o)).then(null, i) : Yn(e, s, r, n + 1).then(o).then(null, i);
    }
  });
}
function Ud(e) {
  const t = Aa(), r = {
    sid: Le(),
    init: !0,
    timestamp: t,
    started: t,
    duration: 0,
    status: "ok",
    errors: 0,
    ignoreDuration: !1,
    toJSON: () => qd(r)
  };
  return e && nn(r, e), r;
}
function nn(e, t = {}) {
  if (t.user && (!e.ipAddress && t.user.ip_address && (e.ipAddress = t.user.ip_address), !e.did && !t.did && (e.did = t.user.id || t.user.email || t.user.username)), e.timestamp = t.timestamp || Aa(), t.abnormal_mechanism && (e.abnormal_mechanism = t.abnormal_mechanism), t.ignoreDuration && (e.ignoreDuration = t.ignoreDuration), t.sid && (e.sid = t.sid.length === 32 ? t.sid : Le()), t.init !== void 0 && (e.init = t.init), !e.did && t.did && (e.did = `${t.did}`), typeof t.started == "number" && (e.started = t.started), e.ignoreDuration)
    e.duration = void 0;
  else if (typeof t.duration == "number")
    e.duration = t.duration;
  else {
    const r = e.timestamp - e.started;
    e.duration = r >= 0 ? r : 0;
  }
  t.release && (e.release = t.release), t.environment && (e.environment = t.environment), !e.ipAddress && t.ipAddress && (e.ipAddress = t.ipAddress), !e.userAgent && t.userAgent && (e.userAgent = t.userAgent), typeof t.errors == "number" && (e.errors = t.errors), t.status && (e.status = t.status);
}
function Hd(e, t) {
  let r = {};
  t ? r = { status: t } : e.status === "ok" && (r = { status: "exited" }), nn(e, r);
}
function qd(e) {
  return Et({
    sid: `${e.sid}`,
    init: e.init,
    // Make sure that sec is converted to ms for date constructor
    started: new Date(e.started * 1e3).toISOString(),
    timestamp: new Date(e.timestamp * 1e3).toISOString(),
    status: e.status,
    errors: e.errors,
    did: typeof e.did == "number" || typeof e.did == "string" ? `${e.did}` : void 0,
    duration: e.duration,
    abnormal_mechanism: e.abnormal_mechanism,
    attrs: {
      release: e.release,
      environment: e.environment,
      ip_address: e.ipAddress,
      user_agent: e.userAgent
    }
  });
}
const zd = 1;
function Bd(e) {
  const { spanId: t, traceId: r } = e.spanContext(), { data: n, op: o, parent_span_id: i, status: a, tags: s, origin: l } = zr(e);
  return Et({
    data: n,
    op: o,
    parent_span_id: i,
    span_id: t,
    status: a,
    tags: s,
    trace_id: r,
    origin: l
  });
}
function zr(e) {
  return Gd(e) ? e.getSpanJSON() : typeof e.toJSON == "function" ? e.toJSON() : {};
}
function Gd(e) {
  return typeof e.getSpanJSON == "function";
}
function Wd(e) {
  const { traceFlags: t } = e.spanContext();
  return !!(t & zd);
}
function Vd(e) {
  if (e)
    return Kd(e) ? { captureContext: e } : Qd(e) ? {
      captureContext: e
    } : e;
}
function Kd(e) {
  return e instanceof Rt || typeof e == "function";
}
const Yd = [
  "user",
  "level",
  "extra",
  "contexts",
  "tags",
  "fingerprint",
  "requestSession",
  "propagationContext"
];
function Qd(e) {
  return Object.keys(e).some((t) => Yd.includes(t));
}
function Ua(e, t) {
  return It().captureException(e, Vd(t));
}
function Ha(e, t) {
  return It().captureEvent(e, t);
}
function Tt(e, t) {
  It().addBreadcrumb(e, t);
}
function qa(...e) {
  const t = It();
  if (e.length === 2) {
    const [r, n] = e;
    return r ? t.withScope(() => (t.getStackTop().scope = r, n(r))) : t.withScope(n);
  }
  return t.withScope(e[0]);
}
function xe() {
  return It().getClient();
}
function Xd() {
  return It().getScope();
}
function za(e) {
  return e.transaction;
}
function Jd(e, t, r) {
  const n = t.getOptions(), { publicKey: o } = t.getDsn() || {}, { segment: i } = r && r.getUser() || {}, a = Et({
    environment: n.environment || ja,
    release: n.release,
    user_segment: i,
    public_key: o,
    trace_id: e
  });
  return t.emit && t.emit("createDsc", a), a;
}
function Zd(e) {
  const t = xe();
  if (!t)
    return {};
  const r = Jd(zr(e).trace_id || "", t, Xd()), n = za(e);
  if (!n)
    return r;
  const o = n && n._frozenDynamicSamplingContext;
  if (o)
    return o;
  const { sampleRate: i, source: a } = n.metadata;
  i != null && (r.sample_rate = `${i}`);
  const s = zr(n);
  return a && a !== "url" && (r.transaction = s.description), r.sampled = String(Wd(n)), t.emit && t.emit("createDsc", r), r;
}
function ef(e, t) {
  const { fingerprint: r, span: n, breadcrumbs: o, sdkProcessingMetadata: i } = t;
  tf(e, t), n && of(e, n), af(e, r), rf(e, o), nf(e, i);
}
function tf(e, t) {
  const {
    extra: r,
    tags: n,
    user: o,
    contexts: i,
    level: a,
    // eslint-disable-next-line deprecation/deprecation
    transactionName: s
  } = t, l = Et(r);
  l && Object.keys(l).length && (e.extra = { ...l, ...e.extra });
  const u = Et(n);
  u && Object.keys(u).length && (e.tags = { ...u, ...e.tags });
  const c = Et(o);
  c && Object.keys(c).length && (e.user = { ...c, ...e.user });
  const f = Et(i);
  f && Object.keys(f).length && (e.contexts = { ...f, ...e.contexts }), a && (e.level = a), s && (e.transaction = s);
}
function rf(e, t) {
  const r = [...e.breadcrumbs || [], ...t];
  e.breadcrumbs = r.length ? r : void 0;
}
function nf(e, t) {
  e.sdkProcessingMetadata = {
    ...e.sdkProcessingMetadata,
    ...t
  };
}
function of(e, t) {
  e.contexts = { trace: Bd(t), ...e.contexts };
  const r = za(t);
  if (r) {
    e.sdkProcessingMetadata = {
      dynamicSamplingContext: Zd(t),
      ...e.sdkProcessingMetadata
    };
    const n = zr(r).description;
    n && (e.tags = { transaction: n, ...e.tags });
  }
}
function af(e, t) {
  e.fingerprint = e.fingerprint ? sd(e.fingerprint) : [], t && (e.fingerprint = e.fingerprint.concat(t)), e.fingerprint && !e.fingerprint.length && delete e.fingerprint;
}
const sf = 100;
class Rt {
  /** Flag if notifying is happening. */
  /** Callback for client to receive scope changes. */
  /** Callback list that will be called after {@link applyToEvent}. */
  /** Array of breadcrumbs. */
  /** User */
  /** Tags */
  /** Extra */
  /** Contexts */
  /** Attachments */
  /** Propagation Context for distributed tracing */
  /**
   * A place to stash data which is needed at some point in the SDK's event processing pipeline but which shouldn't get
   * sent to Sentry
   */
  /** Fingerprint */
  /** Severity */
  // eslint-disable-next-line deprecation/deprecation
  /**
   * Transaction Name
   */
  /** Span */
  /** Session */
  /** Request Mode Session Status */
  /** The client on this scope */
  // NOTE: Any field which gets added here should get added not only to the constructor but also to the `clone` method.
  constructor() {
    this._notifyingListeners = !1, this._scopeListeners = [], this._eventProcessors = [], this._breadcrumbs = [], this._attachments = [], this._user = {}, this._tags = {}, this._extra = {}, this._contexts = {}, this._sdkProcessingMetadata = {}, this._propagationContext = fi();
  }
  /**
   * Inherit values from the parent scope.
   * @deprecated Use `scope.clone()` and `new Scope()` instead.
   */
  static clone(t) {
    return t ? t.clone() : new Rt();
  }
  /**
   * Clone this scope instance.
   */
  clone() {
    const t = new Rt();
    return t._breadcrumbs = [...this._breadcrumbs], t._tags = { ...this._tags }, t._extra = { ...this._extra }, t._contexts = { ...this._contexts }, t._user = this._user, t._level = this._level, t._span = this._span, t._session = this._session, t._transactionName = this._transactionName, t._fingerprint = this._fingerprint, t._eventProcessors = [...this._eventProcessors], t._requestSession = this._requestSession, t._attachments = [...this._attachments], t._sdkProcessingMetadata = { ...this._sdkProcessingMetadata }, t._propagationContext = { ...this._propagationContext }, t._client = this._client, t;
  }
  /** Update the client on the scope. */
  setClient(t) {
    this._client = t;
  }
  /**
   * Get the client assigned to this scope.
   *
   * It is generally recommended to use the global function `Sentry.getClient()` instead, unless you know what you are doing.
   */
  getClient() {
    return this._client;
  }
  /**
   * Add internal on change listener. Used for sub SDKs that need to store the scope.
   * @hidden
   */
  addScopeListener(t) {
    this._scopeListeners.push(t);
  }
  /**
   * @inheritDoc
   */
  addEventProcessor(t) {
    return this._eventProcessors.push(t), this;
  }
  /**
   * @inheritDoc
   */
  setUser(t) {
    return this._user = t || {
      email: void 0,
      id: void 0,
      ip_address: void 0,
      segment: void 0,
      username: void 0
    }, this._session && nn(this._session, { user: t }), this._notifyScopeListeners(), this;
  }
  /**
   * @inheritDoc
   */
  getUser() {
    return this._user;
  }
  /**
   * @inheritDoc
   */
  getRequestSession() {
    return this._requestSession;
  }
  /**
   * @inheritDoc
   */
  setRequestSession(t) {
    return this._requestSession = t, this;
  }
  /**
   * @inheritDoc
   */
  setTags(t) {
    return this._tags = {
      ...this._tags,
      ...t
    }, this._notifyScopeListeners(), this;
  }
  /**
   * @inheritDoc
   */
  setTag(t, r) {
    return this._tags = { ...this._tags, [t]: r }, this._notifyScopeListeners(), this;
  }
  /**
   * @inheritDoc
   */
  setExtras(t) {
    return this._extra = {
      ...this._extra,
      ...t
    }, this._notifyScopeListeners(), this;
  }
  /**
   * @inheritDoc
   */
  setExtra(t, r) {
    return this._extra = { ...this._extra, [t]: r }, this._notifyScopeListeners(), this;
  }
  /**
   * @inheritDoc
   */
  setFingerprint(t) {
    return this._fingerprint = t, this._notifyScopeListeners(), this;
  }
  /**
   * @inheritDoc
   */
  setLevel(t) {
    return this._level = t, this._notifyScopeListeners(), this;
  }
  /**
   * Sets the transaction name on the scope for future events.
   */
  setTransactionName(t) {
    return this._transactionName = t, this._notifyScopeListeners(), this;
  }
  /**
   * @inheritDoc
   */
  setContext(t, r) {
    return r === null ? delete this._contexts[t] : this._contexts[t] = r, this._notifyScopeListeners(), this;
  }
  /**
   * Sets the Span on the scope.
   * @param span Span
   * @deprecated Instead of setting a span on a scope, use `startSpan()`/`startSpanManual()` instead.
   */
  setSpan(t) {
    return this._span = t, this._notifyScopeListeners(), this;
  }
  /**
   * Returns the `Span` if there is one.
   * @deprecated Use `getActiveSpan()` instead.
   */
  getSpan() {
    return this._span;
  }
  /**
   * Returns the `Transaction` attached to the scope (if there is one).
   * @deprecated You should not rely on the transaction, but just use `startSpan()` APIs instead.
   */
  getTransaction() {
    const t = this._span;
    return t && t.transaction;
  }
  /**
   * @inheritDoc
   */
  setSession(t) {
    return t ? this._session = t : delete this._session, this._notifyScopeListeners(), this;
  }
  /**
   * @inheritDoc
   */
  getSession() {
    return this._session;
  }
  /**
   * @inheritDoc
   */
  update(t) {
    if (!t)
      return this;
    const r = typeof t == "function" ? t(this) : t;
    if (r instanceof Rt) {
      const n = r.getScopeData();
      this._tags = { ...this._tags, ...n.tags }, this._extra = { ...this._extra, ...n.extra }, this._contexts = { ...this._contexts, ...n.contexts }, n.user && Object.keys(n.user).length && (this._user = n.user), n.level && (this._level = n.level), n.fingerprint.length && (this._fingerprint = n.fingerprint), r.getRequestSession() && (this._requestSession = r.getRequestSession()), n.propagationContext && (this._propagationContext = n.propagationContext);
    } else if (en(r)) {
      const n = t;
      this._tags = { ...this._tags, ...n.tags }, this._extra = { ...this._extra, ...n.extra }, this._contexts = { ...this._contexts, ...n.contexts }, n.user && (this._user = n.user), n.level && (this._level = n.level), n.fingerprint && (this._fingerprint = n.fingerprint), n.requestSession && (this._requestSession = n.requestSession), n.propagationContext && (this._propagationContext = n.propagationContext);
    }
    return this;
  }
  /**
   * @inheritDoc
   */
  clear() {
    return this._breadcrumbs = [], this._tags = {}, this._extra = {}, this._user = {}, this._contexts = {}, this._level = void 0, this._transactionName = void 0, this._fingerprint = void 0, this._requestSession = void 0, this._span = void 0, this._session = void 0, this._notifyScopeListeners(), this._attachments = [], this._propagationContext = fi(), this;
  }
  /**
   * @inheritDoc
   */
  addBreadcrumb(t, r) {
    const n = typeof r == "number" ? r : sf;
    if (n <= 0)
      return this;
    const o = {
      timestamp: bo(),
      ...t
    }, i = this._breadcrumbs;
    return i.push(o), this._breadcrumbs = i.length > n ? i.slice(-n) : i, this._notifyScopeListeners(), this;
  }
  /**
   * @inheritDoc
   */
  getLastBreadcrumb() {
    return this._breadcrumbs[this._breadcrumbs.length - 1];
  }
  /**
   * @inheritDoc
   */
  clearBreadcrumbs() {
    return this._breadcrumbs = [], this._notifyScopeListeners(), this;
  }
  /**
   * @inheritDoc
   */
  addAttachment(t) {
    return this._attachments.push(t), this;
  }
  /**
   * @inheritDoc
   * @deprecated Use `getScopeData()` instead.
   */
  getAttachments() {
    return this.getScopeData().attachments;
  }
  /**
   * @inheritDoc
   */
  clearAttachments() {
    return this._attachments = [], this;
  }
  /** @inheritDoc */
  getScopeData() {
    const {
      _breadcrumbs: t,
      _attachments: r,
      _contexts: n,
      _tags: o,
      _extra: i,
      _user: a,
      _level: s,
      _fingerprint: l,
      _eventProcessors: u,
      _propagationContext: c,
      _sdkProcessingMetadata: f,
      _transactionName: m,
      _span: p
    } = this;
    return {
      breadcrumbs: t,
      attachments: r,
      contexts: n,
      tags: o,
      extra: i,
      user: a,
      level: s,
      fingerprint: l || [],
      eventProcessors: u,
      propagationContext: c,
      sdkProcessingMetadata: f,
      transactionName: m,
      span: p
    };
  }
  /**
   * Applies data from the scope to the event and runs all event processors on it.
   *
   * @param event Event
   * @param hint Object containing additional information about the original exception, for use by the event processors.
   * @hidden
   * @deprecated Use `applyScopeDataToEvent()` directly
   */
  applyToEvent(t, r = {}, n = []) {
    ef(t, this.getScopeData());
    const o = [
      ...n,
      // eslint-disable-next-line deprecation/deprecation
      ...jd(),
      ...this._eventProcessors
    ];
    return Yn(o, t, r);
  }
  /**
   * Add data which will be accessible during event processing but won't get sent to Sentry
   */
  setSDKProcessingMetadata(t) {
    return this._sdkProcessingMetadata = { ...this._sdkProcessingMetadata, ...t }, this;
  }
  /**
   * @inheritDoc
   */
  setPropagationContext(t) {
    return this._propagationContext = t, this;
  }
  /**
   * @inheritDoc
   */
  getPropagationContext() {
    return this._propagationContext;
  }
  /**
   * Capture an exception for this scope.
   *
   * @param exception The exception to capture.
   * @param hint Optinal additional data to attach to the Sentry event.
   * @returns the id of the captured Sentry event.
   */
  captureException(t, r) {
    const n = r && r.event_id ? r.event_id : Le();
    if (!this._client)
      return G.warn("No client configured on scope - will not capture exception!"), n;
    const o = new Error("Sentry syntheticException");
    return this._client.captureException(
      t,
      {
        originalException: t,
        syntheticException: o,
        ...r,
        event_id: n
      },
      this
    ), n;
  }
  /**
   * Capture a message for this scope.
   *
   * @param message The message to capture.
   * @param level An optional severity level to report the message with.
   * @param hint Optional additional data to attach to the Sentry event.
   * @returns the id of the captured message.
   */
  captureMessage(t, r, n) {
    const o = n && n.event_id ? n.event_id : Le();
    if (!this._client)
      return G.warn("No client configured on scope - will not capture message!"), o;
    const i = new Error(t);
    return this._client.captureMessage(
      t,
      r,
      {
        originalException: t,
        syntheticException: i,
        ...n,
        event_id: o
      },
      this
    ), o;
  }
  /**
   * Captures a manually created event for this scope and sends it to Sentry.
   *
   * @param exception The event to capture.
   * @param hint Optional additional data to attach to the Sentry event.
   * @returns the id of the captured event.
   */
  captureEvent(t, r) {
    const n = r && r.event_id ? r.event_id : Le();
    return this._client ? (this._client.captureEvent(t, { ...r, event_id: n }, this), n) : (G.warn("No client configured on scope - will not capture event!"), n);
  }
  /**
   * This will be called on every set call.
   */
  _notifyScopeListeners() {
    this._notifyingListeners || (this._notifyingListeners = !0, this._scopeListeners.forEach((t) => {
      t(this);
    }), this._notifyingListeners = !1);
  }
}
function fi() {
  return {
    traceId: Le(),
    spanId: Le().substring(16)
  };
}
const lf = "7.119.2", Ba = parseFloat(lf), uf = 100;
class Ga {
  /** Is a {@link Layer}[] containing the client and scope */
  /** Contains the last event id of a captured event.  */
  /**
   * Creates a new instance of the hub, will push one {@link Layer} into the
   * internal stack on creation.
   *
   * @param client bound to the hub.
   * @param scope bound to the hub.
   * @param version number, higher number means higher priority.
   *
   * @deprecated Instantiation of Hub objects is deprecated and the constructor will be removed in version 8 of the SDK.
   *
   * If you are currently using the Hub for multi-client use like so:
   *
   * ```
   * // OLD
   * const hub = new Hub();
   * hub.bindClient(client);
   * makeMain(hub)
   * ```
   *
   * instead initialize the client as follows:
   *
   * ```
   * // NEW
   * Sentry.withIsolationScope(() => {
   *    Sentry.setCurrentClient(client);
   *    client.init();
   * });
   * ```
   *
   * If you are using the Hub to capture events like so:
   *
   * ```
   * // OLD
   * const client = new Client();
   * const hub = new Hub(client);
   * hub.captureException()
   * ```
   *
   * instead capture isolated events as follows:
   *
   * ```
   * // NEW
   * const client = new Client();
   * const scope = new Scope();
   * scope.setClient(client);
   * scope.captureException();
   * ```
   */
  constructor(t, r, n, o = Ba) {
    this._version = o;
    let i;
    r ? i = r : (i = new Rt(), i.setClient(t));
    let a;
    n ? a = n : (a = new Rt(), a.setClient(t)), this._stack = [{ scope: i }], t && this.bindClient(t), this._isolationScope = a;
  }
  /**
   * Checks if this hub's version is older than the given version.
   *
   * @param version A version number to compare to.
   * @return True if the given version is newer; otherwise false.
   *
   * @deprecated This will be removed in v8.
   */
  isOlderThan(t) {
    return this._version < t;
  }
  /**
   * This binds the given client to the current scope.
   * @param client An SDK client (client) instance.
   *
   * @deprecated Use `initAndBind()` directly, or `setCurrentClient()` and/or `client.init()` instead.
   */
  bindClient(t) {
    const r = this.getStackTop();
    r.client = t, r.scope.setClient(t), t && t.setupIntegrations && t.setupIntegrations();
  }
  /**
   * @inheritDoc
   *
   * @deprecated Use `withScope` instead.
   */
  pushScope() {
    const t = this.getScope().clone();
    return this.getStack().push({
      // eslint-disable-next-line deprecation/deprecation
      client: this.getClient(),
      scope: t
    }), t;
  }
  /**
   * @inheritDoc
   *
   * @deprecated Use `withScope` instead.
   */
  popScope() {
    return this.getStack().length <= 1 ? !1 : !!this.getStack().pop();
  }
  /**
   * @inheritDoc
   *
   * @deprecated Use `Sentry.withScope()` instead.
   */
  withScope(t) {
    const r = this.pushScope();
    let n;
    try {
      n = t(r);
    } catch (o) {
      throw this.popScope(), o;
    }
    return po(n) ? n.then(
      (o) => (this.popScope(), o),
      (o) => {
        throw this.popScope(), o;
      }
    ) : (this.popScope(), n);
  }
  /**
   * @inheritDoc
   *
   * @deprecated Use `Sentry.getClient()` instead.
   */
  getClient() {
    return this.getStackTop().client;
  }
  /**
   * Returns the scope of the top stack.
   *
   * @deprecated Use `Sentry.getCurrentScope()` instead.
   */
  getScope() {
    return this.getStackTop().scope;
  }
  /**
   * @deprecated Use `Sentry.getIsolationScope()` instead.
   */
  getIsolationScope() {
    return this._isolationScope;
  }
  /**
   * Returns the scope stack for domains or the process.
   * @deprecated This will be removed in v8.
   */
  getStack() {
    return this._stack;
  }
  /**
   * Returns the topmost scope layer in the order domain > local > process.
   * @deprecated This will be removed in v8.
   */
  getStackTop() {
    return this._stack[this._stack.length - 1];
  }
  /**
   * @inheritDoc
   *
   * @deprecated Use `Sentry.captureException()` instead.
   */
  captureException(t, r) {
    const n = this._lastEventId = r && r.event_id ? r.event_id : Le(), o = new Error("Sentry syntheticException");
    return this.getScope().captureException(t, {
      originalException: t,
      syntheticException: o,
      ...r,
      event_id: n
    }), n;
  }
  /**
   * @inheritDoc
   *
   * @deprecated Use  `Sentry.captureMessage()` instead.
   */
  captureMessage(t, r, n) {
    const o = this._lastEventId = n && n.event_id ? n.event_id : Le(), i = new Error(t);
    return this.getScope().captureMessage(t, r, {
      originalException: t,
      syntheticException: i,
      ...n,
      event_id: o
    }), o;
  }
  /**
   * @inheritDoc
   *
   * @deprecated Use `Sentry.captureEvent()` instead.
   */
  captureEvent(t, r) {
    const n = r && r.event_id ? r.event_id : Le();
    return t.type || (this._lastEventId = n), this.getScope().captureEvent(t, { ...r, event_id: n }), n;
  }
  /**
   * @inheritDoc
   *
   * @deprecated This will be removed in v8.
   */
  lastEventId() {
    return this._lastEventId;
  }
  /**
   * @inheritDoc
   *
   * @deprecated Use `Sentry.addBreadcrumb()` instead.
   */
  addBreadcrumb(t, r) {
    const { scope: n, client: o } = this.getStackTop();
    if (!o)
      return;
    const { beforeBreadcrumb: i = null, maxBreadcrumbs: a = uf } = o.getOptions && o.getOptions() || {};
    if (a <= 0)
      return;
    const l = { timestamp: bo(), ...t }, u = i ? yo(() => i(l, r)) : l;
    u !== null && (o.emit && o.emit("beforeAddBreadcrumb", u, r), n.addBreadcrumb(u, a));
  }
  /**
   * @inheritDoc
   * @deprecated Use `Sentry.setUser()` instead.
   */
  setUser(t) {
    this.getScope().setUser(t), this.getIsolationScope().setUser(t);
  }
  /**
   * @inheritDoc
   * @deprecated Use `Sentry.setTags()` instead.
   */
  setTags(t) {
    this.getScope().setTags(t), this.getIsolationScope().setTags(t);
  }
  /**
   * @inheritDoc
   * @deprecated Use `Sentry.setExtras()` instead.
   */
  setExtras(t) {
    this.getScope().setExtras(t), this.getIsolationScope().setExtras(t);
  }
  /**
   * @inheritDoc
   * @deprecated Use `Sentry.setTag()` instead.
   */
  setTag(t, r) {
    this.getScope().setTag(t, r), this.getIsolationScope().setTag(t, r);
  }
  /**
   * @inheritDoc
   * @deprecated Use `Sentry.setExtra()` instead.
   */
  setExtra(t, r) {
    this.getScope().setExtra(t, r), this.getIsolationScope().setExtra(t, r);
  }
  /**
   * @inheritDoc
   * @deprecated Use `Sentry.setContext()` instead.
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  setContext(t, r) {
    this.getScope().setContext(t, r), this.getIsolationScope().setContext(t, r);
  }
  /**
   * @inheritDoc
   *
   * @deprecated Use `getScope()` directly.
   */
  configureScope(t) {
    const { scope: r, client: n } = this.getStackTop();
    n && t(r);
  }
  /**
   * @inheritDoc
   */
  // eslint-disable-next-line deprecation/deprecation
  run(t) {
    const r = hi(this);
    try {
      t(this);
    } finally {
      hi(r);
    }
  }
  /**
   * @inheritDoc
   * @deprecated Use `Sentry.getClient().getIntegrationByName()` instead.
   */
  getIntegration(t) {
    const r = this.getClient();
    if (!r)
      return null;
    try {
      return r.getIntegration(t);
    } catch {
      return Oe && G.warn(`Cannot retrieve integration ${t.id} from the current Hub`), null;
    }
  }
  /**
   * Starts a new `Transaction` and returns it. This is the entry point to manual tracing instrumentation.
   *
   * A tree structure can be built by adding child spans to the transaction, and child spans to other spans. To start a
   * new child span within the transaction or any span, call the respective `.startChild()` method.
   *
   * Every child span must be finished before the transaction is finished, otherwise the unfinished spans are discarded.
   *
   * The transaction must be finished with a call to its `.end()` method, at which point the transaction with all its
   * finished child spans will be sent to Sentry.
   *
   * @param context Properties of the new `Transaction`.
   * @param customSamplingContext Information given to the transaction sampling function (along with context-dependent
   * default values). See {@link Options.tracesSampler}.
   *
   * @returns The transaction which was just started
   *
   * @deprecated Use `startSpan()`, `startSpanManual()` or `startInactiveSpan()` instead.
   */
  startTransaction(t, r) {
    const n = this._callExtensionMethod("startTransaction", t, r);
    return Oe && !n && (this.getClient() ? G.warn(`Tracing extension 'startTransaction' has not been added. Call 'addTracingExtensions' before calling 'init':
Sentry.addTracingExtensions();
Sentry.init({...});
`) : G.warn(
      "Tracing extension 'startTransaction' is missing. You should 'init' the SDK before calling 'startTransaction'"
    )), n;
  }
  /**
   * @inheritDoc
   * @deprecated Use `spanToTraceHeader()` instead.
   */
  traceHeaders() {
    return this._callExtensionMethod("traceHeaders");
  }
  /**
   * @inheritDoc
   *
   * @deprecated Use top level `captureSession` instead.
   */
  captureSession(t = !1) {
    if (t)
      return this.endSession();
    this._sendSessionUpdate();
  }
  /**
   * @inheritDoc
   * @deprecated Use top level `endSession` instead.
   */
  endSession() {
    const r = this.getStackTop().scope, n = r.getSession();
    n && Hd(n), this._sendSessionUpdate(), r.setSession();
  }
  /**
   * @inheritDoc
   * @deprecated Use top level `startSession` instead.
   */
  startSession(t) {
    const { scope: r, client: n } = this.getStackTop(), { release: o, environment: i = ja } = n && n.getOptions() || {}, { userAgent: a } = V.navigator || {}, s = Ud({
      release: o,
      environment: i,
      user: r.getUser(),
      ...a && { userAgent: a },
      ...t
    }), l = r.getSession && r.getSession();
    return l && l.status === "ok" && nn(l, { status: "exited" }), this.endSession(), r.setSession(s), s;
  }
  /**
   * Returns if default PII should be sent to Sentry and propagated in ourgoing requests
   * when Tracing is used.
   *
   * @deprecated Use top-level `getClient().getOptions().sendDefaultPii` instead. This function
   * only unnecessarily increased API surface but only wrapped accessing the option.
   */
  shouldSendDefaultPii() {
    const t = this.getClient(), r = t && t.getOptions();
    return !!(r && r.sendDefaultPii);
  }
  /**
   * Sends the current Session on the scope
   */
  _sendSessionUpdate() {
    const { scope: t, client: r } = this.getStackTop(), n = t.getSession();
    n && r && r.captureSession && r.captureSession(n);
  }
  /**
   * Calls global extension method and binding current instance to the function call
   */
  // @ts-expect-error Function lacks ending return statement and return type does not include 'undefined'. ts(2366)
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  _callExtensionMethod(t, ...r) {
    const o = on().__SENTRY__;
    if (o && o.extensions && typeof o.extensions[t] == "function")
      return o.extensions[t].apply(this, r);
    Oe && G.warn(`Extension method ${t} couldn't be found, doing nothing.`);
  }
}
function on() {
  return V.__SENTRY__ = V.__SENTRY__ || {
    extensions: {},
    hub: void 0
  }, V;
}
function hi(e) {
  const t = on(), r = Qn(t);
  return Wa(t, e), r;
}
function It() {
  const e = on();
  if (e.__SENTRY__ && e.__SENTRY__.acs) {
    const t = e.__SENTRY__.acs.getCurrentHub();
    if (t)
      return t;
  }
  return cf(e);
}
function cf(e = on()) {
  return (!df(e) || // eslint-disable-next-line deprecation/deprecation
  Qn(e).isOlderThan(Ba)) && Wa(e, new Ga()), Qn(e);
}
function df(e) {
  return !!(e && e.__SENTRY__ && e.__SENTRY__.hub);
}
function Qn(e) {
  return Oa("hub", () => new Ga(), e);
}
function Wa(e, t) {
  if (!e)
    return !1;
  const r = e.__SENTRY__ = e.__SENTRY__ || {};
  return r.hub = t, !0;
}
function ff(e) {
  const t = e.protocol ? `${e.protocol}:` : "", r = e.port ? `:${e.port}` : "";
  return `${t}//${e.host}${r}${e.path ? `/${e.path}` : ""}/api/`;
}
function hf(e, t) {
  const r = rd(e);
  if (!r)
    return "";
  const n = `${ff(r)}embed/error-page/`;
  let o = `dsn=${Zc(r)}`;
  for (const i in t)
    if (i !== "dsn" && i !== "onClose")
      if (i === "user") {
        const a = t.user;
        if (!a)
          continue;
        a.name && (o += `&name=${encodeURIComponent(a.name)}`), a.email && (o += `&email=${encodeURIComponent(a.email)}`);
      } else
        o += `&${encodeURIComponent(i)}=${encodeURIComponent(t[i])}`;
  return `${n}?${o}`;
}
function ht(e, t) {
  return Object.assign(
    function(...n) {
      return t(...n);
    },
    { id: e }
  );
}
const pf = [
  /^Script error\.?$/,
  /^Javascript error: Script error\.? on line 0$/,
  /^ResizeObserver loop completed with undelivered notifications.$/,
  /^Cannot redefine property: googletag$/
], mf = [
  /^.*\/healthcheck$/,
  /^.*\/healthy$/,
  /^.*\/live$/,
  /^.*\/ready$/,
  /^.*\/heartbeat$/,
  /^.*\/health$/,
  /^.*\/healthz$/
], Va = "InboundFilters", gf = (e = {}) => ({
  name: Va,
  // TODO v8: Remove this
  setupOnce() {
  },
  // eslint-disable-line @typescript-eslint/no-empty-function
  processEvent(t, r, n) {
    const o = n.getOptions(), i = yf(e, o);
    return vf(t, i) ? null : t;
  }
}), Ka = gf;
ht(
  Va,
  Ka
);
function yf(e = {}, t = {}) {
  return {
    allowUrls: [...e.allowUrls || [], ...t.allowUrls || []],
    denyUrls: [...e.denyUrls || [], ...t.denyUrls || []],
    ignoreErrors: [
      ...e.ignoreErrors || [],
      ...t.ignoreErrors || [],
      ...e.disableErrorDefaults ? [] : pf
    ],
    ignoreTransactions: [
      ...e.ignoreTransactions || [],
      ...t.ignoreTransactions || [],
      ...e.disableTransactionDefaults ? [] : mf
    ],
    ignoreInternal: e.ignoreInternal !== void 0 ? e.ignoreInternal : !0
  };
}
function vf(e, t) {
  return t.ignoreInternal && Sf(e) ? (Oe && G.warn(`Event dropped due to being internal Sentry Error.
Event: ${lt(e)}`), !0) : bf(e, t.ignoreErrors) ? (Oe && G.warn(
    `Event dropped due to being matched by \`ignoreErrors\` option.
Event: ${lt(e)}`
  ), !0) : wf(e, t.ignoreTransactions) ? (Oe && G.warn(
    `Event dropped due to being matched by \`ignoreTransactions\` option.
Event: ${lt(e)}`
  ), !0) : _f(e, t.denyUrls) ? (Oe && G.warn(
    `Event dropped due to being matched by \`denyUrls\` option.
Event: ${lt(
      e
    )}.
Url: ${Br(e)}`
  ), !0) : Ef(e, t.allowUrls) ? !1 : (Oe && G.warn(
    `Event dropped due to not being matched by \`allowUrls\` option.
Event: ${lt(
      e
    )}.
Url: ${Br(e)}`
  ), !0);
}
function bf(e, t) {
  return e.type || !t || !t.length ? !1 : xf(e).some((r) => rn(r, t));
}
function wf(e, t) {
  if (e.type !== "transaction" || !t || !t.length)
    return !1;
  const r = e.transaction;
  return r ? rn(r, t) : !1;
}
function _f(e, t) {
  if (!t || !t.length)
    return !1;
  const r = Br(e);
  return r ? rn(r, t) : !1;
}
function Ef(e, t) {
  if (!t || !t.length)
    return !0;
  const r = Br(e);
  return r ? rn(r, t) : !0;
}
function xf(e) {
  const t = [];
  e.message && t.push(e.message);
  let r;
  try {
    r = e.exception.values[e.exception.values.length - 1];
  } catch {
  }
  return r && r.value && (t.push(r.value), r.type && t.push(`${r.type}: ${r.value}`)), Oe && t.length === 0 && G.error(`Could not extract message for event ${lt(e)}`), t;
}
function Sf(e) {
  try {
    return e.exception.values[0].type === "SentryError";
  } catch {
  }
  return !1;
}
function Rf(e = []) {
  for (let t = e.length - 1; t >= 0; t--) {
    const r = e[t];
    if (r && r.filename !== "<anonymous>" && r.filename !== "[native code]")
      return r.filename || null;
  }
  return null;
}
function Br(e) {
  try {
    let t;
    try {
      t = e.exception.values[0].stacktrace.frames;
    } catch {
    }
    return t ? Rf(t) : null;
  } catch {
    return Oe && G.error(`Cannot extract url for event ${lt(e)}`), null;
  }
}
let pi;
const Ya = "FunctionToString", mi = /* @__PURE__ */ new WeakMap(), Cf = () => ({
  name: Ya,
  setupOnce() {
    pi = Function.prototype.toString;
    try {
      Function.prototype.toString = function(...e) {
        const t = vo(this), r = mi.has(xe()) && t !== void 0 ? t : this;
        return pi.apply(r, e);
      };
    } catch {
    }
  },
  setup(e) {
    mi.set(e, !0);
  }
}), Qa = Cf;
ht(
  Ya,
  Qa
);
const ie = V;
let Xn = 0;
function Xa() {
  return Xn > 0;
}
function Pf() {
  Xn++, setTimeout(() => {
    Xn--;
  });
}
function qt(e, t = {}, r) {
  if (typeof e != "function")
    return e;
  try {
    const o = e.__sentry_wrapped__;
    if (o)
      return typeof o == "function" ? o : e;
    if (vo(e))
      return e;
  } catch {
    return e;
  }
  const n = function() {
    const o = Array.prototype.slice.call(arguments);
    try {
      r && typeof r == "function" && r.apply(this, arguments);
      const i = o.map((a) => qt(a, t));
      return e.apply(this, i);
    } catch (i) {
      throw Pf(), qa((a) => {
        a.addEventProcessor((s) => (t.mechanism && (qn(s, void 0, void 0), zn(s, t.mechanism)), s.extra = {
          ...s.extra,
          arguments: o
        }, s)), Ua(i);
      }), i;
    }
  };
  try {
    for (const o in e)
      Object.prototype.hasOwnProperty.call(e, o) && (n[o] = e[o]);
  } catch {
  }
  La(n, e), qr(e, "__sentry_wrapped__", n);
  try {
    Object.getOwnPropertyDescriptor(n, "name").configurable && Object.defineProperty(n, "name", {
      get() {
        return e.name;
      }
    });
  } catch {
  }
  return n;
}
const Ht = typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__;
function Ja(e, t) {
  const r = wo(e, t), n = {
    type: t && t.name,
    value: Mf(t)
  };
  return r.length && (n.stacktrace = { frames: r }), n.type === void 0 && n.value === "" && (n.value = "Unrecoverable error caught"), n;
}
function Tf(e, t, r, n) {
  const o = xe(), i = o && o.getOptions().normalizeDepth, a = {
    exception: {
      values: [
        {
          type: tn(t) ? t.constructor.name : n ? "UnhandledRejection" : "Error",
          value: If(t, { isUnhandledRejection: n })
        }
      ]
    },
    extra: {
      __serialized__: $a(t, i)
    }
  };
  if (r) {
    const s = wo(e, r);
    s.length && (a.exception.values[0].stacktrace = { frames: s });
  }
  return a;
}
function Pn(e, t) {
  return {
    exception: {
      values: [Ja(e, t)]
    }
  };
}
function wo(e, t) {
  const r = t.stacktrace || t.stack || "", n = Of(t);
  try {
    return e(r, n);
  } catch {
  }
  return [];
}
const Df = /Minified React error #\d+;/i;
function Of(e) {
  if (e) {
    if (typeof e.framesToPop == "number")
      return e.framesToPop;
    if (Df.test(e.message))
      return 1;
  }
  return 0;
}
function Mf(e) {
  const t = e && e.message;
  return t ? t.error && typeof t.error.message == "string" ? t.error.message : t : "No error message";
}
function Za(e, t, r, n, o) {
  let i;
  if (ho(t) && t.error)
    return Pn(e, t.error);
  if (ti(t) || Fc(t)) {
    const a = t;
    if ("stack" in t)
      i = Pn(e, t);
    else {
      const s = a.name || (ti(a) ? "DOMError" : "DOMException"), l = a.message ? `${s}: ${a.message}` : s;
      i = gi(e, l, r, n), qn(i, l);
    }
    return "code" in a && (i.tags = { ...i.tags, "DOMException.code": `${a.code}` }), i;
  }
  return fo(t) ? Pn(e, t) : en(t) || tn(t) ? (i = Tf(e, t, r, o), zn(i, {
    synthetic: !0
  }), i) : (i = gi(e, t, r, n), qn(i, `${t}`, void 0), zn(i, {
    synthetic: !0
  }), i);
}
function gi(e, t, r, n) {
  const o = {};
  if (n && r) {
    const i = wo(e, r);
    i.length && (o.exception = {
      values: [{ value: t, stacktrace: { frames: i } }]
    });
  }
  if (Pa(t)) {
    const { __sentry_template_string__: i, __sentry_template_values__: a } = t;
    return o.logentry = {
      message: i,
      params: a
    }, o;
  }
  return o.message = t, o;
}
function If(e, { isUnhandledRejection: t }) {
  const r = nd(e), n = t ? "promise rejection" : "exception";
  return ho(e) ? `Event \`ErrorEvent\` captured as ${n} with message \`${e.message}\`` : tn(e) ? `Event \`${Lf(e)}\` (type=${e.type}) captured as ${n}` : `Object captured as ${n} with keys: ${r}`;
}
function Lf(e) {
  try {
    const t = Object.getPrototypeOf(e);
    return t ? t.constructor.name : void 0;
  } catch {
  }
}
const Mr = 1024, es = "Breadcrumbs", kf = (e = {}) => {
  const t = {
    console: !0,
    dom: !0,
    fetch: !0,
    history: !0,
    sentry: !0,
    xhr: !0,
    ...e
  };
  return {
    name: es,
    // TODO v8: Remove this
    setupOnce() {
    },
    // eslint-disable-line @typescript-eslint/no-empty-function
    setup(r) {
      t.console && id(Ff(r)), t.dom && ud($f(r, t.dom)), t.xhr && Pd(Af(r)), t.fetch && gd(jf(r)), t.history && Sd(Uf(r)), t.sentry && r.on && r.on("beforeSendEvent", Nf(r));
    }
  };
}, ts = kf;
ht(es, ts);
function Nf(e) {
  return function(r) {
    xe() === e && Tt(
      {
        category: `sentry.${r.type === "transaction" ? "transaction" : "event"}`,
        event_id: r.event_id,
        level: r.level,
        message: lt(r)
      },
      {
        event: r
      }
    );
  };
}
function $f(e, t) {
  return function(n) {
    if (xe() !== e)
      return;
    let o, i, a = typeof t == "object" ? t.serializeAttribute : void 0, s = typeof t == "object" && typeof t.maxStringLength == "number" ? t.maxStringLength : void 0;
    s && s > Mr && (Ht && G.warn(
      `\`dom.maxStringLength\` cannot exceed ${Mr}, but a value of ${s} was configured. Sentry will use ${Mr} instead.`
    ), s = Mr), typeof a == "string" && (a = [a]);
    try {
      const u = n.event, c = Hf(u) ? u.target : u;
      o = Ma(c, { keyAttrs: a, maxStringLength: s }), i = Kc(c);
    } catch {
      o = "<unknown>";
    }
    if (o.length === 0)
      return;
    const l = {
      category: `ui.${n.name}`,
      message: o
    };
    i && (l.data = { "ui.component_name": i }), Tt(l, {
      event: n.event,
      name: n.name,
      global: n.global
    });
  };
}
function Ff(e) {
  return function(r) {
    if (xe() !== e)
      return;
    const n = {
      category: "console",
      data: {
        arguments: r.args,
        logger: "console"
      },
      level: Fd(r.level),
      message: ri(r.args, " ")
    };
    if (r.level === "assert")
      if (r.args[0] === !1)
        n.message = `Assertion failed: ${ri(r.args.slice(1), " ") || "console.assert"}`, n.data.arguments = r.args.slice(1);
      else
        return;
    Tt(n, {
      input: r.args,
      level: r.level
    });
  };
}
function Af(e) {
  return function(r) {
    if (xe() !== e)
      return;
    const { startTimestamp: n, endTimestamp: o } = r, i = r.xhr[ir];
    if (!n || !o || !i)
      return;
    const { method: a, url: s, status_code: l, body: u } = i, c = {
      method: a,
      url: s,
      status_code: l
    }, f = {
      xhr: r.xhr,
      input: u,
      startTimestamp: n,
      endTimestamp: o
    };
    Tt(
      {
        category: "xhr",
        data: c,
        type: "http"
      },
      f
    );
  };
}
function jf(e) {
  return function(r) {
    if (xe() !== e)
      return;
    const { startTimestamp: n, endTimestamp: o } = r;
    if (o && !(r.fetchData.url.match(/sentry_key/) && r.fetchData.method === "POST"))
      if (r.error) {
        const i = r.fetchData, a = {
          data: r.error,
          input: r.args,
          startTimestamp: n,
          endTimestamp: o
        };
        Tt(
          {
            category: "fetch",
            data: i,
            level: "error",
            type: "http"
          },
          a
        );
      } else {
        const i = r.response, a = {
          ...r.fetchData,
          status_code: i && i.status
        }, s = {
          input: r.args,
          response: i,
          startTimestamp: n,
          endTimestamp: o
        };
        Tt(
          {
            category: "fetch",
            data: a,
            type: "http"
          },
          s
        );
      }
  };
}
function Uf(e) {
  return function(r) {
    if (xe() !== e)
      return;
    let n = r.from, o = r.to;
    const i = Cn(ie.location.href);
    let a = n ? Cn(n) : void 0;
    const s = Cn(o);
    (!a || !a.path) && (a = i), i.protocol === s.protocol && i.host === s.host && (o = s.relative), i.protocol === a.protocol && i.host === a.host && (n = a.relative), Tt({
      category: "navigation",
      data: {
        from: n,
        to: o
      }
    });
  };
}
function Hf(e) {
  return !!e && !!e.target;
}
const rs = "Dedupe", qf = () => {
  let e;
  return {
    name: rs,
    // TODO v8: Remove this
    setupOnce() {
    },
    // eslint-disable-line @typescript-eslint/no-empty-function
    processEvent(t) {
      if (t.type)
        return t;
      try {
        if (zf(t, e))
          return Ht && G.warn("Event dropped due to being a duplicate of previously captured event."), null;
      } catch {
      }
      return e = t;
    }
  };
}, ns = qf;
ht(rs, ns);
function zf(e, t) {
  return t ? !!(Bf(e, t) || Gf(e, t)) : !1;
}
function Bf(e, t) {
  const r = e.message, n = t.message;
  return !(!r && !n || r && !n || !r && n || r !== n || !is(e, t) || !os(e, t));
}
function Gf(e, t) {
  const r = yi(t), n = yi(e);
  return !(!r || !n || r.type !== n.type || r.value !== n.value || !is(e, t) || !os(e, t));
}
function os(e, t) {
  let r = vi(e), n = vi(t);
  if (!r && !n)
    return !0;
  if (r && !n || !r && n || (r = r, n = n, n.length !== r.length))
    return !1;
  for (let o = 0; o < n.length; o++) {
    const i = n[o], a = r[o];
    if (i.filename !== a.filename || i.lineno !== a.lineno || i.colno !== a.colno || i.function !== a.function)
      return !1;
  }
  return !0;
}
function is(e, t) {
  let r = e.fingerprint, n = t.fingerprint;
  if (!r && !n)
    return !0;
  if (r && !n || !r && n)
    return !1;
  r = r, n = n;
  try {
    return r.join("") === n.join("");
  } catch {
    return !1;
  }
}
function yi(e) {
  return e.exception && e.exception.values && e.exception.values[0];
}
function vi(e) {
  const t = e.exception;
  if (t)
    try {
      return t.values[0].stacktrace.frames;
    } catch {
      return;
    }
}
const as = "GlobalHandlers", Wf = (e = {}) => {
  const t = {
    onerror: !0,
    onunhandledrejection: !0,
    ...e
  };
  return {
    name: as,
    setupOnce() {
      Error.stackTraceLimit = 50;
    },
    setup(r) {
      t.onerror && (Vf(r), bi("onerror")), t.onunhandledrejection && (Kf(r), bi("onunhandledrejection"));
    }
  };
}, ss = Wf;
ht(
  as,
  ss
);
function Vf(e) {
  bd((t) => {
    const { stackParser: r, attachStacktrace: n } = us();
    if (xe() !== e || Xa())
      return;
    const { msg: o, url: i, line: a, column: s, error: l } = t, u = l === void 0 && Qe(o) ? Xf(o, i, a, s) : ls(
      Za(r, l || o, void 0, n, !1),
      i,
      a,
      s
    );
    u.level = "error", Ha(u, {
      originalException: l,
      mechanism: {
        handled: !1,
        type: "onerror"
      }
    });
  });
}
function Kf(e) {
  _d((t) => {
    const { stackParser: r, attachStacktrace: n } = us();
    if (xe() !== e || Xa())
      return;
    const o = Yf(t), i = Ta(o) ? Qf(o) : Za(r, o, void 0, n, !0);
    i.level = "error", Ha(i, {
      originalException: o,
      mechanism: {
        handled: !1,
        type: "onunhandledrejection"
      }
    });
  });
}
function Yf(e) {
  if (Ta(e))
    return e;
  const t = e;
  try {
    if ("reason" in t)
      return t.reason;
    if ("detail" in t && "reason" in t.detail)
      return t.detail.reason;
  } catch {
  }
  return e;
}
function Qf(e) {
  return {
    exception: {
      values: [
        {
          type: "UnhandledRejection",
          // String() is needed because the Primitive type includes symbols (which can't be automatically stringified)
          value: `Non-Error promise rejection captured with value: ${String(e)}`
        }
      ]
    }
  };
}
function Xf(e, t, r, n) {
  const o = /^(?:[Uu]ncaught (?:exception: )?)?(?:((?:Eval|Internal|Range|Reference|Syntax|Type|URI|)Error): )?(.*)$/i;
  let i = ho(e) ? e.message : e, a = "Error";
  const s = i.match(o);
  return s && (a = s[1], i = s[2]), ls({
    exception: {
      values: [
        {
          type: a,
          value: i
        }
      ]
    }
  }, t, r, n);
}
function ls(e, t, r, n) {
  const o = e.exception = e.exception || {}, i = o.values = o.values || [], a = i[0] = i[0] || {}, s = a.stacktrace = a.stacktrace || {}, l = s.frames = s.frames || [], u = isNaN(parseInt(n, 10)) ? void 0 : n, c = isNaN(parseInt(r, 10)) ? void 0 : r, f = Qe(t) && t.length > 0 ? t : Vc();
  return l.length === 0 && l.push({
    colno: u,
    filename: f,
    function: "?",
    in_app: !0,
    lineno: c
  }), e;
}
function bi(e) {
  Ht && G.log(`Global Handler attached: ${e}`);
}
function us() {
  const e = xe();
  return e && e.getOptions() || {
    stackParser: () => [],
    attachStacktrace: !1
  };
}
const cs = "HttpContext", Jf = () => ({
  name: cs,
  // TODO v8: Remove this
  setupOnce() {
  },
  // eslint-disable-line @typescript-eslint/no-empty-function
  preprocessEvent(e) {
    if (!ie.navigator && !ie.location && !ie.document)
      return;
    const t = e.request && e.request.url || ie.location && ie.location.href, { referrer: r } = ie.document || {}, { userAgent: n } = ie.navigator || {}, o = {
      ...e.request && e.request.headers,
      ...r && { Referer: r },
      ...n && { "User-Agent": n }
    }, i = { ...e.request, ...t && { url: t }, headers: o };
    e.request = i;
  }
}), ds = Jf;
ht(cs, ds);
const Zf = "cause", eh = 5, fs = "LinkedErrors", th = (e = {}) => {
  const t = e.limit || eh, r = e.key || Zf;
  return {
    name: fs,
    // TODO v8: Remove this
    setupOnce() {
    },
    // eslint-disable-line @typescript-eslint/no-empty-function
    preprocessEvent(n, o, i) {
      const a = i.getOptions();
      zc(
        // This differs from the LinkedErrors integration in core by using a different exceptionFromError function
        Ja,
        a.stackParser,
        a.maxValueLength,
        r,
        t,
        n,
        o
      );
    }
  };
}, hs = th;
ht(fs, hs);
const rh = [
  "EventTarget",
  "Window",
  "Node",
  "ApplicationCache",
  "AudioTrackList",
  "BroadcastChannel",
  "ChannelMergerNode",
  "CryptoOperation",
  "EventSource",
  "FileReader",
  "HTMLUnknownElement",
  "IDBDatabase",
  "IDBRequest",
  "IDBTransaction",
  "KeyOperation",
  "MediaController",
  "MessagePort",
  "ModalWindow",
  "Notification",
  "SVGElementInstance",
  "Screen",
  "SharedWorker",
  "TextTrack",
  "TextTrackCue",
  "TextTrackList",
  "WebSocket",
  "WebSocketWorker",
  "Worker",
  "XMLHttpRequest",
  "XMLHttpRequestEventTarget",
  "XMLHttpRequestUpload"
], ps = "TryCatch", nh = (e = {}) => {
  const t = {
    XMLHttpRequest: !0,
    eventTarget: !0,
    requestAnimationFrame: !0,
    setInterval: !0,
    setTimeout: !0,
    ...e
  };
  return {
    name: ps,
    // TODO: This currently only works for the first client this is setup
    // We may want to adjust this to check for client etc.
    setupOnce() {
      t.setTimeout && ce(ie, "setTimeout", wi), t.setInterval && ce(ie, "setInterval", wi), t.requestAnimationFrame && ce(ie, "requestAnimationFrame", oh), t.XMLHttpRequest && "XMLHttpRequest" in ie && ce(XMLHttpRequest.prototype, "send", ih);
      const r = t.eventTarget;
      r && (Array.isArray(r) ? r : rh).forEach(ah);
    }
  };
}, ms = nh;
ht(
  ps,
  ms
);
function wi(e) {
  return function(...t) {
    const r = t[0];
    return t[0] = qt(r, {
      mechanism: {
        data: { function: ct(e) },
        handled: !1,
        type: "instrument"
      }
    }), e.apply(this, t);
  };
}
function oh(e) {
  return function(t) {
    return e.apply(this, [
      qt(t, {
        mechanism: {
          data: {
            function: "requestAnimationFrame",
            handler: ct(e)
          },
          handled: !1,
          type: "instrument"
        }
      })
    ]);
  };
}
function ih(e) {
  return function(...t) {
    const r = this;
    return ["onload", "onerror", "onprogress", "onreadystatechange"].forEach((o) => {
      o in r && typeof r[o] == "function" && ce(r, o, function(i) {
        const a = {
          mechanism: {
            data: {
              function: o,
              handler: ct(i)
            },
            handled: !1,
            type: "instrument"
          }
        }, s = vo(i);
        return s && (a.mechanism.data.handler = ct(s)), qt(i, a);
      });
    }), e.apply(this, t);
  };
}
function ah(e) {
  const t = ie, r = t[e] && t[e].prototype;
  !r || !r.hasOwnProperty || !r.hasOwnProperty("addEventListener") || (ce(r, "addEventListener", function(n) {
    return function(o, i, a) {
      try {
        typeof i.handleEvent == "function" && (i.handleEvent = qt(i.handleEvent, {
          mechanism: {
            data: {
              function: "handleEvent",
              handler: ct(i),
              target: e
            },
            handled: !1,
            type: "instrument"
          }
        }));
      } catch {
      }
      return n.apply(this, [
        o,
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        qt(i, {
          mechanism: {
            data: {
              function: "addEventListener",
              handler: ct(i),
              target: e
            },
            handled: !1,
            type: "instrument"
          }
        }),
        a
      ]);
    };
  }), ce(
    r,
    "removeEventListener",
    function(n) {
      return function(o, i, a) {
        const s = i;
        try {
          const l = s && s.__sentry_wrapped__;
          l && n.call(this, o, l, a);
        } catch {
        }
        return n.call(this, o, s, a);
      };
    }
  ));
}
Ka(), Qa(), ms(), ts(), ss(), hs(), ns(), ds();
const _i = (e = {}, t = It()) => {
  if (!ie.document) {
    Ht && G.error("Global document not defined in showReportDialog call");
    return;
  }
  const { client: r, scope: n } = t.getStackTop(), o = e.dsn || r && r.getDsn();
  if (!o) {
    Ht && G.error("DSN not configured for showReportDialog call");
    return;
  }
  n && (e.user = {
    ...n.getUser(),
    ...e.user
  }), e.eventId || (e.eventId = t.lastEventId());
  const i = ie.document.createElement("script");
  i.async = !0, i.crossOrigin = "anonymous", i.src = hf(o, e), e.onLoad && (i.onload = e.onLoad);
  const { onClose: a } = e;
  if (a) {
    const l = (u) => {
      if (u.data === "__sentry_reportdialog_closed__")
        try {
          a();
        } finally {
          ie.removeEventListener("message", l);
        }
    };
    ie.addEventListener("message", l);
  }
  const s = ie.document.head || ie.document.body;
  s ? s.appendChild(i) : Ht && G.error("Not injecting report dialog. No injection point found in HTML");
};
var gs = { exports: {} }, W = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var ue = typeof Symbol == "function" && Symbol.for, _o = ue ? Symbol.for("react.element") : 60103, Eo = ue ? Symbol.for("react.portal") : 60106, an = ue ? Symbol.for("react.fragment") : 60107, sn = ue ? Symbol.for("react.strict_mode") : 60108, ln = ue ? Symbol.for("react.profiler") : 60114, un = ue ? Symbol.for("react.provider") : 60109, cn = ue ? Symbol.for("react.context") : 60110, xo = ue ? Symbol.for("react.async_mode") : 60111, dn = ue ? Symbol.for("react.concurrent_mode") : 60111, fn = ue ? Symbol.for("react.forward_ref") : 60112, hn = ue ? Symbol.for("react.suspense") : 60113, sh = ue ? Symbol.for("react.suspense_list") : 60120, pn = ue ? Symbol.for("react.memo") : 60115, mn = ue ? Symbol.for("react.lazy") : 60116, lh = ue ? Symbol.for("react.block") : 60121, uh = ue ? Symbol.for("react.fundamental") : 60117, ch = ue ? Symbol.for("react.responder") : 60118, dh = ue ? Symbol.for("react.scope") : 60119;
function Se(e) {
  if (typeof e == "object" && e !== null) {
    var t = e.$$typeof;
    switch (t) {
      case _o:
        switch (e = e.type, e) {
          case xo:
          case dn:
          case an:
          case ln:
          case sn:
          case hn:
            return e;
          default:
            switch (e = e && e.$$typeof, e) {
              case cn:
              case fn:
              case mn:
              case pn:
              case un:
                return e;
              default:
                return t;
            }
        }
      case Eo:
        return t;
    }
  }
}
function ys(e) {
  return Se(e) === dn;
}
W.AsyncMode = xo;
W.ConcurrentMode = dn;
W.ContextConsumer = cn;
W.ContextProvider = un;
W.Element = _o;
W.ForwardRef = fn;
W.Fragment = an;
W.Lazy = mn;
W.Memo = pn;
W.Portal = Eo;
W.Profiler = ln;
W.StrictMode = sn;
W.Suspense = hn;
W.isAsyncMode = function(e) {
  return ys(e) || Se(e) === xo;
};
W.isConcurrentMode = ys;
W.isContextConsumer = function(e) {
  return Se(e) === cn;
};
W.isContextProvider = function(e) {
  return Se(e) === un;
};
W.isElement = function(e) {
  return typeof e == "object" && e !== null && e.$$typeof === _o;
};
W.isForwardRef = function(e) {
  return Se(e) === fn;
};
W.isFragment = function(e) {
  return Se(e) === an;
};
W.isLazy = function(e) {
  return Se(e) === mn;
};
W.isMemo = function(e) {
  return Se(e) === pn;
};
W.isPortal = function(e) {
  return Se(e) === Eo;
};
W.isProfiler = function(e) {
  return Se(e) === ln;
};
W.isStrictMode = function(e) {
  return Se(e) === sn;
};
W.isSuspense = function(e) {
  return Se(e) === hn;
};
W.isValidElementType = function(e) {
  return typeof e == "string" || typeof e == "function" || e === an || e === dn || e === ln || e === sn || e === hn || e === sh || typeof e == "object" && e !== null && (e.$$typeof === mn || e.$$typeof === pn || e.$$typeof === un || e.$$typeof === cn || e.$$typeof === fn || e.$$typeof === uh || e.$$typeof === ch || e.$$typeof === dh || e.$$typeof === lh);
};
W.typeOf = Se;
gs.exports = W;
var fh = gs.exports, vs = fh, hh = {
  $$typeof: !0,
  render: !0,
  defaultProps: !0,
  displayName: !0,
  propTypes: !0
}, ph = {
  $$typeof: !0,
  compare: !0,
  defaultProps: !0,
  displayName: !0,
  propTypes: !0,
  type: !0
}, bs = {};
bs[vs.ForwardRef] = hh;
bs[vs.Memo] = ph;
const mh = typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__;
function gh(e) {
  const t = e.match(/^([^.]+)/);
  return t !== null && parseInt(t[0]) >= 17;
}
const Ei = {
  componentStack: null,
  error: null,
  eventId: null
};
function yh(e, t) {
  const r = /* @__PURE__ */ new WeakMap();
  function n(o, i) {
    if (!r.has(o)) {
      if (o.cause)
        return r.set(o, !0), n(o.cause, i);
      o.cause = i;
    }
  }
  n(e, t);
}
class So extends oo {
  constructor(t) {
    super(t), So.prototype.__init.call(this), this.state = Ei, this._openFallbackReportDialog = !0;
    const r = xe();
    r && r.on && t.showDialog && (this._openFallbackReportDialog = !1, r.on("afterSendEvent", (n) => {
      !n.type && n.event_id === this._lastEventId && _i({ ...t.dialogOptions, eventId: this._lastEventId });
    }));
  }
  componentDidCatch(t, { componentStack: r }) {
    const { beforeCapture: n, onError: o, showDialog: i, dialogOptions: a } = this.props;
    qa((s) => {
      if (gh(oa) && fo(t)) {
        const u = new Error(t.message);
        u.name = `React ErrorBoundary ${t.name}`, u.stack = r, yh(t, u);
      }
      n && n(s, t, r);
      const l = Ua(t, {
        captureContext: {
          contexts: { react: { componentStack: r } }
        },
        // If users provide a fallback component we can assume they are handling the error.
        // Therefore, we set the mechanism depending on the presence of the fallback prop.
        mechanism: { handled: !!this.props.fallback }
      });
      o && o(t, r, l), i && (this._lastEventId = l, this._openFallbackReportDialog && _i({ ...a, eventId: l })), this.setState({ error: t, componentStack: r, eventId: l });
    });
  }
  componentDidMount() {
    const { onMount: t } = this.props;
    t && t();
  }
  componentWillUnmount() {
    const { error: t, componentStack: r, eventId: n } = this.state, { onUnmount: o } = this.props;
    o && o(t, r, n);
  }
  __init() {
    this.resetErrorBoundary = () => {
      const { onReset: t } = this.props, { error: r, componentStack: n, eventId: o } = this.state;
      t && t(r, n, o), this.setState(Ei);
    };
  }
  render() {
    const { fallback: t, children: r } = this.props, n = this.state;
    if (n.error) {
      let o;
      return typeof t == "function" ? o = t({
        error: n.error,
        componentStack: n.componentStack,
        resetError: this.resetErrorBoundary,
        eventId: n.eventId
      }) : o = t, ra(o) ? o : (t && mh && G.warn("fallback did not produce a valid ReactElement"), null);
    }
    return typeof r == "function" ? r() : r;
  }
}
class gn {
  constructor() {
    this.listeners = /* @__PURE__ */ new Set(), this.subscribe = this.subscribe.bind(this);
  }
  subscribe(t) {
    const r = {
      listener: t
    };
    return this.listeners.add(r), this.onSubscribe(), () => {
      this.listeners.delete(r), this.onUnsubscribe();
    };
  }
  hasListeners() {
    return this.listeners.size > 0;
  }
  onSubscribe() {
  }
  onUnsubscribe() {
  }
}
const Ro = typeof window > "u" || "Deno" in window;
function Te() {
}
function vh(e, t) {
  return typeof e == "function" ? e(t) : e;
}
function bh(e) {
  return typeof e == "number" && e >= 0 && e !== 1 / 0;
}
function wh(e, t) {
  return Math.max(e + (t || 0) - Date.now(), 0);
}
function Ir(e, t, r) {
  return yn(e) ? typeof t == "function" ? {
    ...r,
    queryKey: e,
    queryFn: t
  } : {
    ...t,
    queryKey: e
  } : e;
}
function at(e, t, r) {
  return yn(e) ? [{
    ...t,
    queryKey: e
  }, r] : [e || {}, t];
}
function xi(e, t) {
  const {
    type: r = "all",
    exact: n,
    fetchStatus: o,
    predicate: i,
    queryKey: a,
    stale: s
  } = e;
  if (yn(a)) {
    if (n) {
      if (t.queryHash !== Co(a, t.options))
        return !1;
    } else if (!Gr(t.queryKey, a))
      return !1;
  }
  if (r !== "all") {
    const l = t.isActive();
    if (r === "active" && !l || r === "inactive" && l)
      return !1;
  }
  return !(typeof s == "boolean" && t.isStale() !== s || typeof o < "u" && o !== t.state.fetchStatus || i && !i(t));
}
function Si(e, t) {
  const {
    exact: r,
    fetching: n,
    predicate: o,
    mutationKey: i
  } = e;
  if (yn(i)) {
    if (!t.options.mutationKey)
      return !1;
    if (r) {
      if (xt(t.options.mutationKey) !== xt(i))
        return !1;
    } else if (!Gr(t.options.mutationKey, i))
      return !1;
  }
  return !(typeof n == "boolean" && t.state.status === "loading" !== n || o && !o(t));
}
function Co(e, t) {
  return ((t == null ? void 0 : t.queryKeyHashFn) || xt)(e);
}
function xt(e) {
  return JSON.stringify(e, (t, r) => Jn(r) ? Object.keys(r).sort().reduce((n, o) => (n[o] = r[o], n), {}) : r);
}
function Gr(e, t) {
  return ws(e, t);
}
function ws(e, t) {
  return e === t ? !0 : typeof e != typeof t ? !1 : e && t && typeof e == "object" && typeof t == "object" ? !Object.keys(t).some((r) => !ws(e[r], t[r])) : !1;
}
function _s(e, t) {
  if (e === t)
    return e;
  const r = Ri(e) && Ri(t);
  if (r || Jn(e) && Jn(t)) {
    const n = r ? e.length : Object.keys(e).length, o = r ? t : Object.keys(t), i = o.length, a = r ? [] : {};
    let s = 0;
    for (let l = 0; l < i; l++) {
      const u = r ? l : o[l];
      a[u] = _s(e[u], t[u]), a[u] === e[u] && s++;
    }
    return n === i && s === n ? e : a;
  }
  return t;
}
function Ri(e) {
  return Array.isArray(e) && e.length === Object.keys(e).length;
}
function Jn(e) {
  if (!Ci(e))
    return !1;
  const t = e.constructor;
  if (typeof t > "u")
    return !0;
  const r = t.prototype;
  return !(!Ci(r) || !r.hasOwnProperty("isPrototypeOf"));
}
function Ci(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function yn(e) {
  return Array.isArray(e);
}
function Es(e) {
  return new Promise((t) => {
    setTimeout(t, e);
  });
}
function Pi(e) {
  Es(0).then(e);
}
function _h() {
  if (typeof AbortController == "function")
    return new AbortController();
}
function Eh(e, t, r) {
  return r.isDataEqual != null && r.isDataEqual(e, t) ? e : typeof r.structuralSharing == "function" ? r.structuralSharing(e, t) : r.structuralSharing !== !1 ? _s(e, t) : t;
}
class xh extends gn {
  constructor() {
    super(), this.setup = (t) => {
      if (!Ro && window.addEventListener) {
        const r = () => t();
        return window.addEventListener("visibilitychange", r, !1), window.addEventListener("focus", r, !1), () => {
          window.removeEventListener("visibilitychange", r), window.removeEventListener("focus", r);
        };
      }
    };
  }
  onSubscribe() {
    this.cleanup || this.setEventListener(this.setup);
  }
  onUnsubscribe() {
    if (!this.hasListeners()) {
      var t;
      (t = this.cleanup) == null || t.call(this), this.cleanup = void 0;
    }
  }
  setEventListener(t) {
    var r;
    this.setup = t, (r = this.cleanup) == null || r.call(this), this.cleanup = t((n) => {
      typeof n == "boolean" ? this.setFocused(n) : this.onFocus();
    });
  }
  setFocused(t) {
    this.focused !== t && (this.focused = t, this.onFocus());
  }
  onFocus() {
    this.listeners.forEach(({
      listener: t
    }) => {
      t();
    });
  }
  isFocused() {
    return typeof this.focused == "boolean" ? this.focused : typeof document > "u" ? !0 : [void 0, "visible", "prerender"].includes(document.visibilityState);
  }
}
const Zn = new xh(), Ti = ["online", "offline"];
class Sh extends gn {
  constructor() {
    super(), this.setup = (t) => {
      if (!Ro && window.addEventListener) {
        const r = () => t();
        return Ti.forEach((n) => {
          window.addEventListener(n, r, !1);
        }), () => {
          Ti.forEach((n) => {
            window.removeEventListener(n, r);
          });
        };
      }
    };
  }
  onSubscribe() {
    this.cleanup || this.setEventListener(this.setup);
  }
  onUnsubscribe() {
    if (!this.hasListeners()) {
      var t;
      (t = this.cleanup) == null || t.call(this), this.cleanup = void 0;
    }
  }
  setEventListener(t) {
    var r;
    this.setup = t, (r = this.cleanup) == null || r.call(this), this.cleanup = t((n) => {
      typeof n == "boolean" ? this.setOnline(n) : this.onOnline();
    });
  }
  setOnline(t) {
    this.online !== t && (this.online = t, this.onOnline());
  }
  onOnline() {
    this.listeners.forEach(({
      listener: t
    }) => {
      t();
    });
  }
  isOnline() {
    return typeof this.online == "boolean" ? this.online : typeof navigator > "u" || typeof navigator.onLine > "u" ? !0 : navigator.onLine;
  }
}
const Wr = new Sh();
function Rh(e) {
  return Math.min(1e3 * 2 ** e, 3e4);
}
function Po(e) {
  return (e ?? "online") === "online" ? Wr.isOnline() : !0;
}
class xs {
  constructor(t) {
    this.revert = t == null ? void 0 : t.revert, this.silent = t == null ? void 0 : t.silent;
  }
}
function Tn(e) {
  return e instanceof xs;
}
function Ss(e) {
  let t = !1, r = 0, n = !1, o, i, a;
  const s = new Promise((v, w) => {
    i = v, a = w;
  }), l = (v) => {
    n || (p(new xs(v)), e.abort == null || e.abort());
  }, u = () => {
    t = !0;
  }, c = () => {
    t = !1;
  }, f = () => !Zn.isFocused() || e.networkMode !== "always" && !Wr.isOnline(), m = (v) => {
    n || (n = !0, e.onSuccess == null || e.onSuccess(v), o == null || o(), i(v));
  }, p = (v) => {
    n || (n = !0, e.onError == null || e.onError(v), o == null || o(), a(v));
  }, b = () => new Promise((v) => {
    o = (w) => {
      const S = n || !f();
      return S && v(w), S;
    }, e.onPause == null || e.onPause();
  }).then(() => {
    o = void 0, n || e.onContinue == null || e.onContinue();
  }), _ = () => {
    if (n)
      return;
    let v;
    try {
      v = e.fn();
    } catch (w) {
      v = Promise.reject(w);
    }
    Promise.resolve(v).then(m).catch((w) => {
      var S, x;
      if (n)
        return;
      const I = (S = e.retry) != null ? S : 3, g = (x = e.retryDelay) != null ? x : Rh, C = typeof g == "function" ? g(r, w) : g, D = I === !0 || typeof I == "number" && r < I || typeof I == "function" && I(r, w);
      if (t || !D) {
        p(w);
        return;
      }
      r++, e.onFail == null || e.onFail(r, w), Es(C).then(() => {
        if (f())
          return b();
      }).then(() => {
        t ? p(w) : _();
      });
    });
  };
  return Po(e.networkMode) ? _() : b().then(_), {
    promise: s,
    cancel: l,
    continue: () => (o == null ? void 0 : o()) ? s : Promise.resolve(),
    cancelRetry: u,
    continueRetry: c
  };
}
const To = console;
function Ch() {
  let e = [], t = 0, r = (c) => {
    c();
  }, n = (c) => {
    c();
  };
  const o = (c) => {
    let f;
    t++;
    try {
      f = c();
    } finally {
      t--, t || s();
    }
    return f;
  }, i = (c) => {
    t ? e.push(c) : Pi(() => {
      r(c);
    });
  }, a = (c) => (...f) => {
    i(() => {
      c(...f);
    });
  }, s = () => {
    const c = e;
    e = [], c.length && Pi(() => {
      n(() => {
        c.forEach((f) => {
          r(f);
        });
      });
    });
  };
  return {
    batch: o,
    batchCalls: a,
    schedule: i,
    setNotifyFunction: (c) => {
      r = c;
    },
    setBatchNotifyFunction: (c) => {
      n = c;
    }
  };
}
const ve = Ch();
class Rs {
  destroy() {
    this.clearGcTimeout();
  }
  scheduleGc() {
    this.clearGcTimeout(), bh(this.cacheTime) && (this.gcTimeout = setTimeout(() => {
      this.optionalRemove();
    }, this.cacheTime));
  }
  updateCacheTime(t) {
    this.cacheTime = Math.max(this.cacheTime || 0, t ?? (Ro ? 1 / 0 : 5 * 60 * 1e3));
  }
  clearGcTimeout() {
    this.gcTimeout && (clearTimeout(this.gcTimeout), this.gcTimeout = void 0);
  }
}
class Ph extends Rs {
  constructor(t) {
    super(), this.abortSignalConsumed = !1, this.defaultOptions = t.defaultOptions, this.setOptions(t.options), this.observers = [], this.cache = t.cache, this.logger = t.logger || To, this.queryKey = t.queryKey, this.queryHash = t.queryHash, this.initialState = t.state || Th(this.options), this.state = this.initialState, this.scheduleGc();
  }
  get meta() {
    return this.options.meta;
  }
  setOptions(t) {
    this.options = {
      ...this.defaultOptions,
      ...t
    }, this.updateCacheTime(this.options.cacheTime);
  }
  optionalRemove() {
    !this.observers.length && this.state.fetchStatus === "idle" && this.cache.remove(this);
  }
  setData(t, r) {
    const n = Eh(this.state.data, t, this.options);
    return this.dispatch({
      data: n,
      type: "success",
      dataUpdatedAt: r == null ? void 0 : r.updatedAt,
      manual: r == null ? void 0 : r.manual
    }), n;
  }
  setState(t, r) {
    this.dispatch({
      type: "setState",
      state: t,
      setStateOptions: r
    });
  }
  cancel(t) {
    var r;
    const n = this.promise;
    return (r = this.retryer) == null || r.cancel(t), n ? n.then(Te).catch(Te) : Promise.resolve();
  }
  destroy() {
    super.destroy(), this.cancel({
      silent: !0
    });
  }
  reset() {
    this.destroy(), this.setState(this.initialState);
  }
  isActive() {
    return this.observers.some((t) => t.options.enabled !== !1);
  }
  isDisabled() {
    return this.getObserversCount() > 0 && !this.isActive();
  }
  isStale() {
    return this.state.isInvalidated || !this.state.dataUpdatedAt || this.observers.some((t) => t.getCurrentResult().isStale);
  }
  isStaleByTime(t = 0) {
    return this.state.isInvalidated || !this.state.dataUpdatedAt || !wh(this.state.dataUpdatedAt, t);
  }
  onFocus() {
    var t;
    const r = this.observers.find((n) => n.shouldFetchOnWindowFocus());
    r && r.refetch({
      cancelRefetch: !1
    }), (t = this.retryer) == null || t.continue();
  }
  onOnline() {
    var t;
    const r = this.observers.find((n) => n.shouldFetchOnReconnect());
    r && r.refetch({
      cancelRefetch: !1
    }), (t = this.retryer) == null || t.continue();
  }
  addObserver(t) {
    this.observers.includes(t) || (this.observers.push(t), this.clearGcTimeout(), this.cache.notify({
      type: "observerAdded",
      query: this,
      observer: t
    }));
  }
  removeObserver(t) {
    this.observers.includes(t) && (this.observers = this.observers.filter((r) => r !== t), this.observers.length || (this.retryer && (this.abortSignalConsumed ? this.retryer.cancel({
      revert: !0
    }) : this.retryer.cancelRetry()), this.scheduleGc()), this.cache.notify({
      type: "observerRemoved",
      query: this,
      observer: t
    }));
  }
  getObserversCount() {
    return this.observers.length;
  }
  invalidate() {
    this.state.isInvalidated || this.dispatch({
      type: "invalidate"
    });
  }
  fetch(t, r) {
    var n, o;
    if (this.state.fetchStatus !== "idle") {
      if (this.state.dataUpdatedAt && r != null && r.cancelRefetch)
        this.cancel({
          silent: !0
        });
      else if (this.promise) {
        var i;
        return (i = this.retryer) == null || i.continueRetry(), this.promise;
      }
    }
    if (t && this.setOptions(t), !this.options.queryFn) {
      const p = this.observers.find((b) => b.options.queryFn);
      p && this.setOptions(p.options);
    }
    const a = _h(), s = {
      queryKey: this.queryKey,
      pageParam: void 0,
      meta: this.meta
    }, l = (p) => {
      Object.defineProperty(p, "signal", {
        enumerable: !0,
        get: () => {
          if (a)
            return this.abortSignalConsumed = !0, a.signal;
        }
      });
    };
    l(s);
    const u = () => this.options.queryFn ? (this.abortSignalConsumed = !1, this.options.queryFn(s)) : Promise.reject("Missing queryFn for queryKey '" + this.options.queryHash + "'"), c = {
      fetchOptions: r,
      options: this.options,
      queryKey: this.queryKey,
      state: this.state,
      fetchFn: u
    };
    if (l(c), (n = this.options.behavior) == null || n.onFetch(c), this.revertState = this.state, this.state.fetchStatus === "idle" || this.state.fetchMeta !== ((o = c.fetchOptions) == null ? void 0 : o.meta)) {
      var f;
      this.dispatch({
        type: "fetch",
        meta: (f = c.fetchOptions) == null ? void 0 : f.meta
      });
    }
    const m = (p) => {
      if (Tn(p) && p.silent || this.dispatch({
        type: "error",
        error: p
      }), !Tn(p)) {
        var b, _, v, w;
        (b = (_ = this.cache.config).onError) == null || b.call(_, p, this), (v = (w = this.cache.config).onSettled) == null || v.call(w, this.state.data, p, this);
      }
      this.isFetchingOptimistic || this.scheduleGc(), this.isFetchingOptimistic = !1;
    };
    return this.retryer = Ss({
      fn: c.fetchFn,
      abort: a == null ? void 0 : a.abort.bind(a),
      onSuccess: (p) => {
        var b, _, v, w;
        if (typeof p > "u") {
          m(new Error(this.queryHash + " data is undefined"));
          return;
        }
        this.setData(p), (b = (_ = this.cache.config).onSuccess) == null || b.call(_, p, this), (v = (w = this.cache.config).onSettled) == null || v.call(w, p, this.state.error, this), this.isFetchingOptimistic || this.scheduleGc(), this.isFetchingOptimistic = !1;
      },
      onError: m,
      onFail: (p, b) => {
        this.dispatch({
          type: "failed",
          failureCount: p,
          error: b
        });
      },
      onPause: () => {
        this.dispatch({
          type: "pause"
        });
      },
      onContinue: () => {
        this.dispatch({
          type: "continue"
        });
      },
      retry: c.options.retry,
      retryDelay: c.options.retryDelay,
      networkMode: c.options.networkMode
    }), this.promise = this.retryer.promise, this.promise;
  }
  dispatch(t) {
    const r = (n) => {
      var o, i;
      switch (t.type) {
        case "failed":
          return {
            ...n,
            fetchFailureCount: t.failureCount,
            fetchFailureReason: t.error
          };
        case "pause":
          return {
            ...n,
            fetchStatus: "paused"
          };
        case "continue":
          return {
            ...n,
            fetchStatus: "fetching"
          };
        case "fetch":
          return {
            ...n,
            fetchFailureCount: 0,
            fetchFailureReason: null,
            fetchMeta: (o = t.meta) != null ? o : null,
            fetchStatus: Po(this.options.networkMode) ? "fetching" : "paused",
            ...!n.dataUpdatedAt && {
              error: null,
              status: "loading"
            }
          };
        case "success":
          return {
            ...n,
            data: t.data,
            dataUpdateCount: n.dataUpdateCount + 1,
            dataUpdatedAt: (i = t.dataUpdatedAt) != null ? i : Date.now(),
            error: null,
            isInvalidated: !1,
            status: "success",
            ...!t.manual && {
              fetchStatus: "idle",
              fetchFailureCount: 0,
              fetchFailureReason: null
            }
          };
        case "error":
          const a = t.error;
          return Tn(a) && a.revert && this.revertState ? {
            ...this.revertState,
            fetchStatus: "idle"
          } : {
            ...n,
            error: a,
            errorUpdateCount: n.errorUpdateCount + 1,
            errorUpdatedAt: Date.now(),
            fetchFailureCount: n.fetchFailureCount + 1,
            fetchFailureReason: a,
            fetchStatus: "idle",
            status: "error"
          };
        case "invalidate":
          return {
            ...n,
            isInvalidated: !0
          };
        case "setState":
          return {
            ...n,
            ...t.state
          };
      }
    };
    this.state = r(this.state), ve.batch(() => {
      this.observers.forEach((n) => {
        n.onQueryUpdate(t);
      }), this.cache.notify({
        query: this,
        type: "updated",
        action: t
      });
    });
  }
}
function Th(e) {
  const t = typeof e.initialData == "function" ? e.initialData() : e.initialData, r = typeof t < "u", n = r ? typeof e.initialDataUpdatedAt == "function" ? e.initialDataUpdatedAt() : e.initialDataUpdatedAt : 0;
  return {
    data: t,
    dataUpdateCount: 0,
    dataUpdatedAt: r ? n ?? Date.now() : 0,
    error: null,
    errorUpdateCount: 0,
    errorUpdatedAt: 0,
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchMeta: null,
    isInvalidated: !1,
    status: r ? "success" : "loading",
    fetchStatus: "idle"
  };
}
class Dh extends gn {
  constructor(t) {
    super(), this.config = t || {}, this.queries = [], this.queriesMap = {};
  }
  build(t, r, n) {
    var o;
    const i = r.queryKey, a = (o = r.queryHash) != null ? o : Co(i, r);
    let s = this.get(a);
    return s || (s = new Ph({
      cache: this,
      logger: t.getLogger(),
      queryKey: i,
      queryHash: a,
      options: t.defaultQueryOptions(r),
      state: n,
      defaultOptions: t.getQueryDefaults(i)
    }), this.add(s)), s;
  }
  add(t) {
    this.queriesMap[t.queryHash] || (this.queriesMap[t.queryHash] = t, this.queries.push(t), this.notify({
      type: "added",
      query: t
    }));
  }
  remove(t) {
    const r = this.queriesMap[t.queryHash];
    r && (t.destroy(), this.queries = this.queries.filter((n) => n !== t), r === t && delete this.queriesMap[t.queryHash], this.notify({
      type: "removed",
      query: t
    }));
  }
  clear() {
    ve.batch(() => {
      this.queries.forEach((t) => {
        this.remove(t);
      });
    });
  }
  get(t) {
    return this.queriesMap[t];
  }
  getAll() {
    return this.queries;
  }
  find(t, r) {
    const [n] = at(t, r);
    return typeof n.exact > "u" && (n.exact = !0), this.queries.find((o) => xi(n, o));
  }
  findAll(t, r) {
    const [n] = at(t, r);
    return Object.keys(n).length > 0 ? this.queries.filter((o) => xi(n, o)) : this.queries;
  }
  notify(t) {
    ve.batch(() => {
      this.listeners.forEach(({
        listener: r
      }) => {
        r(t);
      });
    });
  }
  onFocus() {
    ve.batch(() => {
      this.queries.forEach((t) => {
        t.onFocus();
      });
    });
  }
  onOnline() {
    ve.batch(() => {
      this.queries.forEach((t) => {
        t.onOnline();
      });
    });
  }
}
class Oh extends Rs {
  constructor(t) {
    super(), this.defaultOptions = t.defaultOptions, this.mutationId = t.mutationId, this.mutationCache = t.mutationCache, this.logger = t.logger || To, this.observers = [], this.state = t.state || Mh(), this.setOptions(t.options), this.scheduleGc();
  }
  setOptions(t) {
    this.options = {
      ...this.defaultOptions,
      ...t
    }, this.updateCacheTime(this.options.cacheTime);
  }
  get meta() {
    return this.options.meta;
  }
  setState(t) {
    this.dispatch({
      type: "setState",
      state: t
    });
  }
  addObserver(t) {
    this.observers.includes(t) || (this.observers.push(t), this.clearGcTimeout(), this.mutationCache.notify({
      type: "observerAdded",
      mutation: this,
      observer: t
    }));
  }
  removeObserver(t) {
    this.observers = this.observers.filter((r) => r !== t), this.scheduleGc(), this.mutationCache.notify({
      type: "observerRemoved",
      mutation: this,
      observer: t
    });
  }
  optionalRemove() {
    this.observers.length || (this.state.status === "loading" ? this.scheduleGc() : this.mutationCache.remove(this));
  }
  continue() {
    var t, r;
    return (t = (r = this.retryer) == null ? void 0 : r.continue()) != null ? t : this.execute();
  }
  async execute() {
    const t = () => {
      var D;
      return this.retryer = Ss({
        fn: () => this.options.mutationFn ? this.options.mutationFn(this.state.variables) : Promise.reject("No mutationFn found"),
        onFail: (T, A) => {
          this.dispatch({
            type: "failed",
            failureCount: T,
            error: A
          });
        },
        onPause: () => {
          this.dispatch({
            type: "pause"
          });
        },
        onContinue: () => {
          this.dispatch({
            type: "continue"
          });
        },
        retry: (D = this.options.retry) != null ? D : 0,
        retryDelay: this.options.retryDelay,
        networkMode: this.options.networkMode
      }), this.retryer.promise;
    }, r = this.state.status === "loading";
    try {
      var n, o, i, a, s, l, u, c;
      if (!r) {
        var f, m, p, b;
        this.dispatch({
          type: "loading",
          variables: this.options.variables
        }), await ((f = (m = this.mutationCache.config).onMutate) == null ? void 0 : f.call(m, this.state.variables, this));
        const T = await ((p = (b = this.options).onMutate) == null ? void 0 : p.call(b, this.state.variables));
        T !== this.state.context && this.dispatch({
          type: "loading",
          context: T,
          variables: this.state.variables
        });
      }
      const D = await t();
      return await ((n = (o = this.mutationCache.config).onSuccess) == null ? void 0 : n.call(o, D, this.state.variables, this.state.context, this)), await ((i = (a = this.options).onSuccess) == null ? void 0 : i.call(a, D, this.state.variables, this.state.context)), await ((s = (l = this.mutationCache.config).onSettled) == null ? void 0 : s.call(l, D, null, this.state.variables, this.state.context, this)), await ((u = (c = this.options).onSettled) == null ? void 0 : u.call(c, D, null, this.state.variables, this.state.context)), this.dispatch({
        type: "success",
        data: D
      }), D;
    } catch (D) {
      try {
        var _, v, w, S, x, I, g, C;
        throw await ((_ = (v = this.mutationCache.config).onError) == null ? void 0 : _.call(v, D, this.state.variables, this.state.context, this)), await ((w = (S = this.options).onError) == null ? void 0 : w.call(S, D, this.state.variables, this.state.context)), await ((x = (I = this.mutationCache.config).onSettled) == null ? void 0 : x.call(I, void 0, D, this.state.variables, this.state.context, this)), await ((g = (C = this.options).onSettled) == null ? void 0 : g.call(C, void 0, D, this.state.variables, this.state.context)), D;
      } finally {
        this.dispatch({
          type: "error",
          error: D
        });
      }
    }
  }
  dispatch(t) {
    const r = (n) => {
      switch (t.type) {
        case "failed":
          return {
            ...n,
            failureCount: t.failureCount,
            failureReason: t.error
          };
        case "pause":
          return {
            ...n,
            isPaused: !0
          };
        case "continue":
          return {
            ...n,
            isPaused: !1
          };
        case "loading":
          return {
            ...n,
            context: t.context,
            data: void 0,
            failureCount: 0,
            failureReason: null,
            error: null,
            isPaused: !Po(this.options.networkMode),
            status: "loading",
            variables: t.variables
          };
        case "success":
          return {
            ...n,
            data: t.data,
            failureCount: 0,
            failureReason: null,
            error: null,
            status: "success",
            isPaused: !1
          };
        case "error":
          return {
            ...n,
            data: void 0,
            error: t.error,
            failureCount: n.failureCount + 1,
            failureReason: t.error,
            isPaused: !1,
            status: "error"
          };
        case "setState":
          return {
            ...n,
            ...t.state
          };
      }
    };
    this.state = r(this.state), ve.batch(() => {
      this.observers.forEach((n) => {
        n.onMutationUpdate(t);
      }), this.mutationCache.notify({
        mutation: this,
        type: "updated",
        action: t
      });
    });
  }
}
function Mh() {
  return {
    context: void 0,
    data: void 0,
    error: null,
    failureCount: 0,
    failureReason: null,
    isPaused: !1,
    status: "idle",
    variables: void 0
  };
}
class Ih extends gn {
  constructor(t) {
    super(), this.config = t || {}, this.mutations = [], this.mutationId = 0;
  }
  build(t, r, n) {
    const o = new Oh({
      mutationCache: this,
      logger: t.getLogger(),
      mutationId: ++this.mutationId,
      options: t.defaultMutationOptions(r),
      state: n,
      defaultOptions: r.mutationKey ? t.getMutationDefaults(r.mutationKey) : void 0
    });
    return this.add(o), o;
  }
  add(t) {
    this.mutations.push(t), this.notify({
      type: "added",
      mutation: t
    });
  }
  remove(t) {
    this.mutations = this.mutations.filter((r) => r !== t), this.notify({
      type: "removed",
      mutation: t
    });
  }
  clear() {
    ve.batch(() => {
      this.mutations.forEach((t) => {
        this.remove(t);
      });
    });
  }
  getAll() {
    return this.mutations;
  }
  find(t) {
    return typeof t.exact > "u" && (t.exact = !0), this.mutations.find((r) => Si(t, r));
  }
  findAll(t) {
    return this.mutations.filter((r) => Si(t, r));
  }
  notify(t) {
    ve.batch(() => {
      this.listeners.forEach(({
        listener: r
      }) => {
        r(t);
      });
    });
  }
  resumePausedMutations() {
    var t;
    return this.resuming = ((t = this.resuming) != null ? t : Promise.resolve()).then(() => {
      const r = this.mutations.filter((n) => n.state.isPaused);
      return ve.batch(() => r.reduce((n, o) => n.then(() => o.continue().catch(Te)), Promise.resolve()));
    }).then(() => {
      this.resuming = void 0;
    }), this.resuming;
  }
}
function Lh() {
  return {
    onFetch: (e) => {
      e.fetchFn = () => {
        var t, r, n, o, i, a;
        const s = (t = e.fetchOptions) == null || (r = t.meta) == null ? void 0 : r.refetchPage, l = (n = e.fetchOptions) == null || (o = n.meta) == null ? void 0 : o.fetchMore, u = l == null ? void 0 : l.pageParam, c = (l == null ? void 0 : l.direction) === "forward", f = (l == null ? void 0 : l.direction) === "backward", m = ((i = e.state.data) == null ? void 0 : i.pages) || [], p = ((a = e.state.data) == null ? void 0 : a.pageParams) || [];
        let b = p, _ = !1;
        const v = (C) => {
          Object.defineProperty(C, "signal", {
            enumerable: !0,
            get: () => {
              var D;
              if ((D = e.signal) != null && D.aborted)
                _ = !0;
              else {
                var T;
                (T = e.signal) == null || T.addEventListener("abort", () => {
                  _ = !0;
                });
              }
              return e.signal;
            }
          });
        }, w = e.options.queryFn || (() => Promise.reject("Missing queryFn for queryKey '" + e.options.queryHash + "'")), S = (C, D, T, A) => (b = A ? [D, ...b] : [...b, D], A ? [T, ...C] : [...C, T]), x = (C, D, T, A) => {
          if (_)
            return Promise.reject("Cancelled");
          if (typeof T > "u" && !D && C.length)
            return Promise.resolve(C);
          const K = {
            queryKey: e.queryKey,
            pageParam: T,
            meta: e.options.meta
          };
          v(K);
          const ee = w(K);
          return Promise.resolve(ee).then((Re) => S(C, T, Re, A));
        };
        let I;
        if (!m.length)
          I = x([]);
        else if (c) {
          const C = typeof u < "u", D = C ? u : Di(e.options, m);
          I = x(m, C, D);
        } else if (f) {
          const C = typeof u < "u", D = C ? u : kh(e.options, m);
          I = x(m, C, D, !0);
        } else {
          b = [];
          const C = typeof e.options.getNextPageParam > "u";
          I = (s && m[0] ? s(m[0], 0, m) : !0) ? x([], C, p[0]) : Promise.resolve(S([], p[0], m[0]));
          for (let T = 1; T < m.length; T++)
            I = I.then((A) => {
              if (s && m[T] ? s(m[T], T, m) : !0) {
                const ee = C ? p[T] : Di(e.options, A);
                return x(A, C, ee);
              }
              return Promise.resolve(S(A, p[T], m[T]));
            });
        }
        return I.then((C) => ({
          pages: C,
          pageParams: b
        }));
      };
    }
  };
}
function Di(e, t) {
  return e.getNextPageParam == null ? void 0 : e.getNextPageParam(t[t.length - 1], t);
}
function kh(e, t) {
  return e.getPreviousPageParam == null ? void 0 : e.getPreviousPageParam(t[0], t);
}
class Nh {
  constructor(t = {}) {
    this.queryCache = t.queryCache || new Dh(), this.mutationCache = t.mutationCache || new Ih(), this.logger = t.logger || To, this.defaultOptions = t.defaultOptions || {}, this.queryDefaults = [], this.mutationDefaults = [], this.mountCount = 0;
  }
  mount() {
    this.mountCount++, this.mountCount === 1 && (this.unsubscribeFocus = Zn.subscribe(() => {
      Zn.isFocused() && (this.resumePausedMutations(), this.queryCache.onFocus());
    }), this.unsubscribeOnline = Wr.subscribe(() => {
      Wr.isOnline() && (this.resumePausedMutations(), this.queryCache.onOnline());
    }));
  }
  unmount() {
    var t, r;
    this.mountCount--, this.mountCount === 0 && ((t = this.unsubscribeFocus) == null || t.call(this), this.unsubscribeFocus = void 0, (r = this.unsubscribeOnline) == null || r.call(this), this.unsubscribeOnline = void 0);
  }
  isFetching(t, r) {
    const [n] = at(t, r);
    return n.fetchStatus = "fetching", this.queryCache.findAll(n).length;
  }
  isMutating(t) {
    return this.mutationCache.findAll({
      ...t,
      fetching: !0
    }).length;
  }
  getQueryData(t, r) {
    var n;
    return (n = this.queryCache.find(t, r)) == null ? void 0 : n.state.data;
  }
  ensureQueryData(t, r, n) {
    const o = Ir(t, r, n), i = this.getQueryData(o.queryKey);
    return i ? Promise.resolve(i) : this.fetchQuery(o);
  }
  getQueriesData(t) {
    return this.getQueryCache().findAll(t).map(({
      queryKey: r,
      state: n
    }) => {
      const o = n.data;
      return [r, o];
    });
  }
  setQueryData(t, r, n) {
    const o = this.queryCache.find(t), i = o == null ? void 0 : o.state.data, a = vh(r, i);
    if (typeof a > "u")
      return;
    const s = Ir(t), l = this.defaultQueryOptions(s);
    return this.queryCache.build(this, l).setData(a, {
      ...n,
      manual: !0
    });
  }
  setQueriesData(t, r, n) {
    return ve.batch(() => this.getQueryCache().findAll(t).map(({
      queryKey: o
    }) => [o, this.setQueryData(o, r, n)]));
  }
  getQueryState(t, r) {
    var n;
    return (n = this.queryCache.find(t, r)) == null ? void 0 : n.state;
  }
  removeQueries(t, r) {
    const [n] = at(t, r), o = this.queryCache;
    ve.batch(() => {
      o.findAll(n).forEach((i) => {
        o.remove(i);
      });
    });
  }
  resetQueries(t, r, n) {
    const [o, i] = at(t, r, n), a = this.queryCache, s = {
      type: "active",
      ...o
    };
    return ve.batch(() => (a.findAll(o).forEach((l) => {
      l.reset();
    }), this.refetchQueries(s, i)));
  }
  cancelQueries(t, r, n) {
    const [o, i = {}] = at(t, r, n);
    typeof i.revert > "u" && (i.revert = !0);
    const a = ve.batch(() => this.queryCache.findAll(o).map((s) => s.cancel(i)));
    return Promise.all(a).then(Te).catch(Te);
  }
  invalidateQueries(t, r, n) {
    const [o, i] = at(t, r, n);
    return ve.batch(() => {
      var a, s;
      if (this.queryCache.findAll(o).forEach((u) => {
        u.invalidate();
      }), o.refetchType === "none")
        return Promise.resolve();
      const l = {
        ...o,
        type: (a = (s = o.refetchType) != null ? s : o.type) != null ? a : "active"
      };
      return this.refetchQueries(l, i);
    });
  }
  refetchQueries(t, r, n) {
    const [o, i] = at(t, r, n), a = ve.batch(() => this.queryCache.findAll(o).filter((l) => !l.isDisabled()).map((l) => {
      var u;
      return l.fetch(void 0, {
        ...i,
        cancelRefetch: (u = i == null ? void 0 : i.cancelRefetch) != null ? u : !0,
        meta: {
          refetchPage: o.refetchPage
        }
      });
    }));
    let s = Promise.all(a).then(Te);
    return i != null && i.throwOnError || (s = s.catch(Te)), s;
  }
  fetchQuery(t, r, n) {
    const o = Ir(t, r, n), i = this.defaultQueryOptions(o);
    typeof i.retry > "u" && (i.retry = !1);
    const a = this.queryCache.build(this, i);
    return a.isStaleByTime(i.staleTime) ? a.fetch(i) : Promise.resolve(a.state.data);
  }
  prefetchQuery(t, r, n) {
    return this.fetchQuery(t, r, n).then(Te).catch(Te);
  }
  fetchInfiniteQuery(t, r, n) {
    const o = Ir(t, r, n);
    return o.behavior = Lh(), this.fetchQuery(o);
  }
  prefetchInfiniteQuery(t, r, n) {
    return this.fetchInfiniteQuery(t, r, n).then(Te).catch(Te);
  }
  resumePausedMutations() {
    return this.mutationCache.resumePausedMutations();
  }
  getQueryCache() {
    return this.queryCache;
  }
  getMutationCache() {
    return this.mutationCache;
  }
  getLogger() {
    return this.logger;
  }
  getDefaultOptions() {
    return this.defaultOptions;
  }
  setDefaultOptions(t) {
    this.defaultOptions = t;
  }
  setQueryDefaults(t, r) {
    const n = this.queryDefaults.find((o) => xt(t) === xt(o.queryKey));
    n ? n.defaultOptions = r : this.queryDefaults.push({
      queryKey: t,
      defaultOptions: r
    });
  }
  getQueryDefaults(t) {
    if (!t)
      return;
    const r = this.queryDefaults.find((n) => Gr(t, n.queryKey));
    return r == null ? void 0 : r.defaultOptions;
  }
  setMutationDefaults(t, r) {
    const n = this.mutationDefaults.find((o) => xt(t) === xt(o.mutationKey));
    n ? n.defaultOptions = r : this.mutationDefaults.push({
      mutationKey: t,
      defaultOptions: r
    });
  }
  getMutationDefaults(t) {
    if (!t)
      return;
    const r = this.mutationDefaults.find((n) => Gr(t, n.mutationKey));
    return r == null ? void 0 : r.defaultOptions;
  }
  defaultQueryOptions(t) {
    if (t != null && t._defaulted)
      return t;
    const r = {
      ...this.defaultOptions.queries,
      ...this.getQueryDefaults(t == null ? void 0 : t.queryKey),
      ...t,
      _defaulted: !0
    };
    return !r.queryHash && r.queryKey && (r.queryHash = Co(r.queryKey, r)), typeof r.refetchOnReconnect > "u" && (r.refetchOnReconnect = r.networkMode !== "always"), typeof r.useErrorBoundary > "u" && (r.useErrorBoundary = !!r.suspense), r;
  }
  defaultMutationOptions(t) {
    return t != null && t._defaulted ? t : {
      ...this.defaultOptions.mutations,
      ...this.getMutationDefaults(t == null ? void 0 : t.mutationKey),
      ...t,
      _defaulted: !0
    };
  }
  clear() {
    this.queryCache.clear(), this.mutationCache.clear();
  }
}
const Oi = /* @__PURE__ */ pe(void 0), $h = /* @__PURE__ */ pe(!1);
function Fh(e, t) {
  return e || (t && typeof window < "u" ? (window.ReactQueryClientContext || (window.ReactQueryClientContext = Oi), window.ReactQueryClientContext) : Oi);
}
const Ah = ({
  client: e,
  children: t,
  context: r,
  contextSharing: n = !1
}) => {
  se(() => (e.mount(), () => {
    e.unmount();
  }), [e]);
  const o = Fh(r, n);
  return /* @__PURE__ */ O($h.Provider, {
    value: !r && n
  }, /* @__PURE__ */ O(o.Provider, {
    value: e
  }, t));
}, Cs = window.adminXQueryClient || new Nh({
  defaultOptions: {
    queries: {
      refetchOnWindowFocus: !1,
      staleTime: 5 * (60 * 1e3),
      // 5 mins
      cacheTime: 10 * (60 * 1e3),
      // 10 mins
      // We have custom retry logic for specific errors in fetchApi()
      retry: !1,
      networkMode: "always"
    }
  }
});
window.adminXQueryClient || (window.adminXQueryClient = Cs);
const jh = pe({
  ghostVersion: "",
  externalNavigate: () => {
  },
  unsplashConfig: {
    Authorization: "",
    "Accept-Version": "",
    "Content-Type": "",
    "App-Pragma": "",
    "X-Unsplash-Cache": !0
  },
  sentryDSN: null,
  onUpdate: () => {
  },
  onInvalidate: () => {
  },
  onDelete: () => {
  }
});
function Uh({ children: e, ...t }) {
  return /* @__PURE__ */ B.jsx(So, { children: /* @__PURE__ */ B.jsx(Ah, { client: Cs, children: /* @__PURE__ */ B.jsx(jh.Provider, { value: t, children: e }) }) });
}
var Do = {};
Object.defineProperty(Do, "__esModule", { value: !0 });
Do.parse = Vh;
Do.serialize = Kh;
const Hh = /^[\u0021-\u003A\u003C\u003E-\u007E]+$/, qh = /^[\u0021-\u003A\u003C-\u007E]*$/, zh = /^([.]?[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)([.][a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$/i, Bh = /^[\u0020-\u003A\u003D-\u007E]*$/, Gh = Object.prototype.toString, Wh = /* @__PURE__ */ (() => {
  const e = function() {
  };
  return e.prototype = /* @__PURE__ */ Object.create(null), e;
})();
function Vh(e, t) {
  const r = new Wh(), n = e.length;
  if (n < 2)
    return r;
  const o = (t == null ? void 0 : t.decode) || Yh;
  let i = 0;
  do {
    const a = e.indexOf("=", i);
    if (a === -1)
      break;
    const s = e.indexOf(";", i), l = s === -1 ? n : s;
    if (a > l) {
      i = e.lastIndexOf(";", a - 1) + 1;
      continue;
    }
    const u = Mi(e, i, a), c = Ii(e, a, u), f = e.slice(u, c);
    if (r[f] === void 0) {
      let m = Mi(e, a + 1, l), p = Ii(e, l, m);
      const b = o(e.slice(m, p));
      r[f] = b;
    }
    i = l + 1;
  } while (i < n);
  return r;
}
function Mi(e, t, r) {
  do {
    const n = e.charCodeAt(t);
    if (n !== 32 && n !== 9)
      return t;
  } while (++t < r);
  return r;
}
function Ii(e, t, r) {
  for (; t > r; ) {
    const n = e.charCodeAt(--t);
    if (n !== 32 && n !== 9)
      return t + 1;
  }
  return r;
}
function Kh(e, t, r) {
  const n = (r == null ? void 0 : r.encode) || encodeURIComponent;
  if (!Hh.test(e))
    throw new TypeError(`argument name is invalid: ${e}`);
  const o = n(t);
  if (!qh.test(o))
    throw new TypeError(`argument val is invalid: ${t}`);
  let i = e + "=" + o;
  if (!r)
    return i;
  if (r.maxAge !== void 0) {
    if (!Number.isInteger(r.maxAge))
      throw new TypeError(`option maxAge is invalid: ${r.maxAge}`);
    i += "; Max-Age=" + r.maxAge;
  }
  if (r.domain) {
    if (!zh.test(r.domain))
      throw new TypeError(`option domain is invalid: ${r.domain}`);
    i += "; Domain=" + r.domain;
  }
  if (r.path) {
    if (!Bh.test(r.path))
      throw new TypeError(`option path is invalid: ${r.path}`);
    i += "; Path=" + r.path;
  }
  if (r.expires) {
    if (!Qh(r.expires) || !Number.isFinite(r.expires.valueOf()))
      throw new TypeError(`option expires is invalid: ${r.expires}`);
    i += "; Expires=" + r.expires.toUTCString();
  }
  if (r.httpOnly && (i += "; HttpOnly"), r.secure && (i += "; Secure"), r.partitioned && (i += "; Partitioned"), r.priority)
    switch (typeof r.priority == "string" ? r.priority.toLowerCase() : void 0) {
      case "low":
        i += "; Priority=Low";
        break;
      case "medium":
        i += "; Priority=Medium";
        break;
      case "high":
        i += "; Priority=High";
        break;
      default:
        throw new TypeError(`option priority is invalid: ${r.priority}`);
    }
  if (r.sameSite)
    switch (typeof r.sameSite == "string" ? r.sameSite.toLowerCase() : r.sameSite) {
      case !0:
      case "strict":
        i += "; SameSite=Strict";
        break;
      case "lax":
        i += "; SameSite=Lax";
        break;
      case "none":
        i += "; SameSite=None";
        break;
      default:
        throw new TypeError(`option sameSite is invalid: ${r.sameSite}`);
    }
  return i;
}
function Yh(e) {
  if (e.indexOf("%") === -1)
    return e;
  try {
    return decodeURIComponent(e);
  } catch {
    return e;
  }
}
function Qh(e) {
  return Gh.call(e) === "[object Date]";
}
/**
 * react-router v7.3.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
var Ps = (e) => {
  throw TypeError(e);
}, Xh = (e, t, r) => t.has(e) || Ps("Cannot " + r), Dn = (e, t, r) => (Xh(e, t, "read from private field"), r ? r.call(e) : t.get(e)), Jh = (e, t, r) => t.has(e) ? Ps("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(e) : t.set(e, r), Li = "popstate";
function Zh(e = {}) {
  function t(o, i) {
    let {
      pathname: a = "/",
      search: s = "",
      hash: l = ""
    } = Ae(o.location.hash.substring(1));
    return !a.startsWith("/") && !a.startsWith(".") && (a = "/" + a), cr(
      "",
      { pathname: a, search: s, hash: l },
      // state defaults to `null` because `window.history.state` does
      i.state && i.state.usr || null,
      i.state && i.state.key || "default"
    );
  }
  function r(o, i) {
    let a = o.document.querySelector("base"), s = "";
    if (a && a.getAttribute("href")) {
      let l = o.location.href, u = l.indexOf("#");
      s = u === -1 ? l : l.slice(0, u);
    }
    return s + "#" + (typeof i == "string" ? i : dt(i));
  }
  function n(o, i) {
    le(
      o.pathname.charAt(0) === "/",
      `relative pathnames are not supported in hash history.push(${JSON.stringify(
        i
      )})`
    );
  }
  return tp(
    t,
    r,
    n,
    e
  );
}
function U(e, t) {
  if (e === !1 || e === null || typeof e > "u")
    throw new Error(t);
}
function le(e, t) {
  if (!e) {
    typeof console < "u" && console.warn(t);
    try {
      throw new Error(t);
    } catch {
    }
  }
}
function ep() {
  return Math.random().toString(36).substring(2, 10);
}
function ki(e, t) {
  return {
    usr: e.state,
    key: e.key,
    idx: t
  };
}
function cr(e, t, r = null, n) {
  return {
    pathname: typeof e == "string" ? e : e.pathname,
    search: "",
    hash: "",
    ...typeof t == "string" ? Ae(t) : t,
    state: r,
    // TODO: This could be cleaned up.  push/replace should probably just take
    // full Locations now and avoid the need to run through this flow at all
    // But that's a pretty big refactor to the current test suite so going to
    // keep as is for the time being and just let any incoming keys take precedence
    key: t && t.key || n || ep()
  };
}
function dt({
  pathname: e = "/",
  search: t = "",
  hash: r = ""
}) {
  return t && t !== "?" && (e += t.charAt(0) === "?" ? t : "?" + t), r && r !== "#" && (e += r.charAt(0) === "#" ? r : "#" + r), e;
}
function Ae(e) {
  let t = {};
  if (e) {
    let r = e.indexOf("#");
    r >= 0 && (t.hash = e.substring(r), e = e.substring(0, r));
    let n = e.indexOf("?");
    n >= 0 && (t.search = e.substring(n), e = e.substring(0, n)), e && (t.pathname = e);
  }
  return t;
}
function tp(e, t, r, n = {}) {
  let { window: o = document.defaultView, v5Compat: i = !1 } = n, a = o.history, s = "POP", l = null, u = c();
  u == null && (u = 0, a.replaceState({ ...a.state, idx: u }, ""));
  function c() {
    return (a.state || { idx: null }).idx;
  }
  function f() {
    s = "POP";
    let v = c(), w = v == null ? null : v - u;
    u = v, l && l({ action: s, location: _.location, delta: w });
  }
  function m(v, w) {
    s = "PUSH";
    let S = cr(_.location, v, w);
    r && r(S, v), u = c() + 1;
    let x = ki(S, u), I = _.createHref(S);
    try {
      a.pushState(x, "", I);
    } catch (g) {
      if (g instanceof DOMException && g.name === "DataCloneError")
        throw g;
      o.location.assign(I);
    }
    i && l && l({ action: s, location: _.location, delta: 1 });
  }
  function p(v, w) {
    s = "REPLACE";
    let S = cr(_.location, v, w);
    r && r(S, v), u = c();
    let x = ki(S, u), I = _.createHref(S);
    a.replaceState(x, "", I), i && l && l({ action: s, location: _.location, delta: 0 });
  }
  function b(v) {
    let w = o.location.origin !== "null" ? o.location.origin : o.location.href, S = typeof v == "string" ? v : dt(v);
    return S = S.replace(/ $/, "%20"), U(
      w,
      `No window.location.(origin|href) available to create URL for href: ${S}`
    ), new URL(S, w);
  }
  let _ = {
    get action() {
      return s;
    },
    get location() {
      return e(o, a);
    },
    listen(v) {
      if (l)
        throw new Error("A history only accepts one active listener");
      return o.addEventListener(Li, f), l = v, () => {
        o.removeEventListener(Li, f), l = null;
      };
    },
    createHref(v) {
      return t(o, v);
    },
    createURL: b,
    encodeLocation(v) {
      let w = b(v);
      return {
        pathname: w.pathname,
        search: w.search,
        hash: w.hash
      };
    },
    push: m,
    replace: p,
    go(v) {
      return a.go(v);
    }
  };
  return _;
}
var ar, Ni = class {
  constructor(e) {
    if (Jh(this, ar, /* @__PURE__ */ new Map()), e)
      for (let [t, r] of e)
        this.set(t, r);
  }
  get(e) {
    if (Dn(this, ar).has(e))
      return Dn(this, ar).get(e);
    if (e.defaultValue !== void 0)
      return e.defaultValue;
    throw new Error("No value found for context");
  }
  set(e, t) {
    Dn(this, ar).set(e, t);
  }
};
ar = /* @__PURE__ */ new WeakMap();
var rp = /* @__PURE__ */ new Set([
  "lazy",
  "caseSensitive",
  "path",
  "id",
  "index",
  "children"
]);
function np(e) {
  return e.index === !0;
}
function Vr(e, t, r = [], n = {}) {
  return e.map((o, i) => {
    let a = [...r, String(i)], s = typeof o.id == "string" ? o.id : a.join("-");
    if (U(
      o.index !== !0 || !o.children,
      "Cannot specify children on an index route"
    ), U(
      !n[s],
      `Found a route id collision on id "${s}".  Route id's must be globally unique within Data Router usages`
    ), np(o)) {
      let l = {
        ...o,
        ...t(o),
        id: s
      };
      return n[s] = l, l;
    } else {
      let l = {
        ...o,
        ...t(o),
        id: s,
        children: void 0
      };
      return n[s] = l, o.children && (l.children = Vr(
        o.children,
        t,
        a,
        n
      )), l;
    }
  });
}
function ut(e, t, r = "/") {
  return Fr(e, t, r, !1);
}
function Fr(e, t, r, n) {
  let o = typeof t == "string" ? Ae(t) : t, i = Pe(o.pathname || "/", r);
  if (i == null)
    return null;
  let a = Ts(e);
  ip(a);
  let s = null;
  for (let l = 0; s == null && l < a.length; ++l) {
    let u = gp(i);
    s = pp(
      a[l],
      u,
      n
    );
  }
  return s;
}
function op(e, t) {
  let { route: r, pathname: n, params: o } = e;
  return {
    id: r.id,
    pathname: n,
    params: o,
    data: t[r.id],
    handle: r.handle
  };
}
function Ts(e, t = [], r = [], n = "") {
  let o = (i, a, s) => {
    let l = {
      relativePath: s === void 0 ? i.path || "" : s,
      caseSensitive: i.caseSensitive === !0,
      childrenIndex: a,
      route: i
    };
    l.relativePath.startsWith("/") && (U(
      l.relativePath.startsWith(n),
      `Absolute route path "${l.relativePath}" nested under path "${n}" is not valid. An absolute child route path must start with the combined path of all its parent routes.`
    ), l.relativePath = l.relativePath.slice(n.length));
    let u = Fe([n, l.relativePath]), c = r.concat(l);
    i.children && i.children.length > 0 && (U(
      // Our types know better, but runtime JS may not!
      // @ts-expect-error
      i.index !== !0,
      `Index routes must not have child routes. Please remove all child routes from route path "${u}".`
    ), Ts(i.children, t, c, u)), !(i.path == null && !i.index) && t.push({
      path: u,
      score: fp(u, i.index),
      routesMeta: c
    });
  };
  return e.forEach((i, a) => {
    var s;
    if (i.path === "" || !((s = i.path) != null && s.includes("?")))
      o(i, a);
    else
      for (let l of Ds(i.path))
        o(i, a, l);
  }), t;
}
function Ds(e) {
  let t = e.split("/");
  if (t.length === 0)
    return [];
  let [r, ...n] = t, o = r.endsWith("?"), i = r.replace(/\?$/, "");
  if (n.length === 0)
    return o ? [i, ""] : [i];
  let a = Ds(n.join("/")), s = [];
  return s.push(
    ...a.map(
      (l) => l === "" ? i : [i, l].join("/")
    )
  ), o && s.push(...a), s.map(
    (l) => e.startsWith("/") && l === "" ? "/" : l
  );
}
function ip(e) {
  e.sort(
    (t, r) => t.score !== r.score ? r.score - t.score : hp(
      t.routesMeta.map((n) => n.childrenIndex),
      r.routesMeta.map((n) => n.childrenIndex)
    )
  );
}
var ap = /^:[\w-]+$/, sp = 3, lp = 2, up = 1, cp = 10, dp = -2, $i = (e) => e === "*";
function fp(e, t) {
  let r = e.split("/"), n = r.length;
  return r.some($i) && (n += dp), t && (n += lp), r.filter((o) => !$i(o)).reduce(
    (o, i) => o + (ap.test(i) ? sp : i === "" ? up : cp),
    n
  );
}
function hp(e, t) {
  return e.length === t.length && e.slice(0, -1).every((n, o) => n === t[o]) ? (
    // If two routes are siblings, we should try to match the earlier sibling
    // first. This allows people to have fine-grained control over the matching
    // behavior by simply putting routes with identical paths in the order they
    // want them tried.
    e[e.length - 1] - t[t.length - 1]
  ) : (
    // Otherwise, it doesn't really make sense to rank non-siblings by index,
    // so they sort equally.
    0
  );
}
function pp(e, t, r = !1) {
  let { routesMeta: n } = e, o = {}, i = "/", a = [];
  for (let s = 0; s < n.length; ++s) {
    let l = n[s], u = s === n.length - 1, c = i === "/" ? t : t.slice(i.length) || "/", f = Kr(
      { path: l.relativePath, caseSensitive: l.caseSensitive, end: u },
      c
    ), m = l.route;
    if (!f && u && r && !n[n.length - 1].route.index && (f = Kr(
      {
        path: l.relativePath,
        caseSensitive: l.caseSensitive,
        end: !1
      },
      c
    )), !f)
      return null;
    Object.assign(o, f.params), a.push({
      // TODO: Can this as be avoided?
      params: o,
      pathname: Fe([i, f.pathname]),
      pathnameBase: bp(
        Fe([i, f.pathnameBase])
      ),
      route: m
    }), f.pathnameBase !== "/" && (i = Fe([i, f.pathnameBase]));
  }
  return a;
}
function Kr(e, t) {
  typeof e == "string" && (e = { path: e, caseSensitive: !1, end: !0 });
  let [r, n] = mp(
    e.path,
    e.caseSensitive,
    e.end
  ), o = t.match(r);
  if (!o)
    return null;
  let i = o[0], a = i.replace(/(.)\/+$/, "$1"), s = o.slice(1);
  return {
    params: n.reduce(
      (u, { paramName: c, isOptional: f }, m) => {
        if (c === "*") {
          let b = s[m] || "";
          a = i.slice(0, i.length - b.length).replace(/(.)\/+$/, "$1");
        }
        const p = s[m];
        return f && !p ? u[c] = void 0 : u[c] = (p || "").replace(/%2F/g, "/"), u;
      },
      {}
    ),
    pathname: i,
    pathnameBase: a,
    pattern: e
  };
}
function mp(e, t = !1, r = !0) {
  le(
    e === "*" || !e.endsWith("*") || e.endsWith("/*"),
    `Route path "${e}" will be treated as if it were "${e.replace(/\*$/, "/*")}" because the \`*\` character must always follow a \`/\` in the pattern. To get rid of this warning, please change the route path to "${e.replace(/\*$/, "/*")}".`
  );
  let n = [], o = "^" + e.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^${}|()[\]]/g, "\\$&").replace(
    /\/:([\w-]+)(\?)?/g,
    (a, s, l) => (n.push({ paramName: s, isOptional: l != null }), l ? "/?([^\\/]+)?" : "/([^\\/]+)")
  );
  return e.endsWith("*") ? (n.push({ paramName: "*" }), o += e === "*" || e === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$") : r ? o += "\\/*$" : e !== "" && e !== "/" && (o += "(?:(?=\\/|$))"), [new RegExp(o, t ? void 0 : "i"), n];
}
function gp(e) {
  try {
    return e.split("/").map((t) => decodeURIComponent(t).replace(/\//g, "%2F")).join("/");
  } catch (t) {
    return le(
      !1,
      `The URL path "${e}" could not be decoded because it is a malformed URL segment. This is probably due to a bad percent encoding (${t}).`
    ), e;
  }
}
function Pe(e, t) {
  if (t === "/")
    return e;
  if (!e.toLowerCase().startsWith(t.toLowerCase()))
    return null;
  let r = t.endsWith("/") ? t.length - 1 : t.length, n = e.charAt(r);
  return n && n !== "/" ? null : e.slice(r) || "/";
}
function yp(e, t = "/") {
  let {
    pathname: r,
    search: n = "",
    hash: o = ""
  } = typeof e == "string" ? Ae(e) : e;
  return {
    pathname: r ? r.startsWith("/") ? r : vp(r, t) : t,
    search: wp(n),
    hash: _p(o)
  };
}
function vp(e, t) {
  let r = t.replace(/\/+$/, "").split("/");
  return e.split("/").forEach((o) => {
    o === ".." ? r.length > 1 && r.pop() : o !== "." && r.push(o);
  }), r.length > 1 ? r.join("/") : "/";
}
function On(e, t, r, n) {
  return `Cannot include a '${e}' character in a manually specified \`to.${t}\` field [${JSON.stringify(
    n
  )}].  Please separate it out to the \`to.${r}\` field. Alternatively you may provide the full path as a string in <Link to="..."> and the router will parse it for you.`;
}
function Os(e) {
  return e.filter(
    (t, r) => r === 0 || t.route.path && t.route.path.length > 0
  );
}
function Oo(e) {
  let t = Os(e);
  return t.map(
    (r, n) => n === t.length - 1 ? r.pathname : r.pathnameBase
  );
}
function Mo(e, t, r, n = !1) {
  let o;
  typeof e == "string" ? o = Ae(e) : (o = { ...e }, U(
    !o.pathname || !o.pathname.includes("?"),
    On("?", "pathname", "search", o)
  ), U(
    !o.pathname || !o.pathname.includes("#"),
    On("#", "pathname", "hash", o)
  ), U(
    !o.search || !o.search.includes("#"),
    On("#", "search", "hash", o)
  ));
  let i = e === "" || o.pathname === "", a = i ? "/" : o.pathname, s;
  if (a == null)
    s = r;
  else {
    let f = t.length - 1;
    if (!n && a.startsWith("..")) {
      let m = a.split("/");
      for (; m[0] === ".."; )
        m.shift(), f -= 1;
      o.pathname = m.join("/");
    }
    s = f >= 0 ? t[f] : "/";
  }
  let l = yp(o, s), u = a && a !== "/" && a.endsWith("/"), c = (i || a === ".") && r.endsWith("/");
  return !l.pathname.endsWith("/") && (u || c) && (l.pathname += "/"), l;
}
var Fe = (e) => e.join("/").replace(/\/\/+/g, "/"), bp = (e) => e.replace(/\/+$/, "").replace(/^\/*/, "/"), wp = (e) => !e || e === "?" ? "" : e.startsWith("?") ? e : "?" + e, _p = (e) => !e || e === "#" ? "" : e.startsWith("#") ? e : "#" + e, Yr = class {
  constructor(e, t, r, n = !1) {
    this.status = e, this.statusText = t || "", this.internal = n, r instanceof Error ? (this.data = r.toString(), this.error = r) : this.data = r;
  }
};
function dr(e) {
  return e != null && typeof e.status == "number" && typeof e.statusText == "string" && typeof e.internal == "boolean" && "data" in e;
}
var Ms = [
  "POST",
  "PUT",
  "PATCH",
  "DELETE"
], Ep = new Set(
  Ms
), xp = [
  "GET",
  ...Ms
], Sp = new Set(xp), Rp = /* @__PURE__ */ new Set([301, 302, 303, 307, 308]), Cp = /* @__PURE__ */ new Set([307, 308]), Mn = {
  state: "idle",
  location: void 0,
  formMethod: void 0,
  formAction: void 0,
  formEncType: void 0,
  formData: void 0,
  json: void 0,
  text: void 0
}, Pp = {
  state: "idle",
  data: void 0,
  formMethod: void 0,
  formAction: void 0,
  formEncType: void 0,
  formData: void 0,
  json: void 0,
  text: void 0
}, rr = {
  state: "unblocked",
  proceed: void 0,
  reset: void 0,
  location: void 0
}, Io = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i, Tp = (e) => ({
  hasErrorBoundary: !!e.hasErrorBoundary
}), Is = "remix-router-transitions", Ls = Symbol("ResetLoaderData");
function Dp(e) {
  const t = e.window ? e.window : typeof window < "u" ? window : void 0, r = typeof t < "u" && typeof t.document < "u" && typeof t.document.createElement < "u";
  U(
    e.routes.length > 0,
    "You must provide a non-empty routes array to createRouter"
  );
  let n = e.mapRouteProperties || Tp, o = {}, i = Vr(
    e.routes,
    n,
    void 0,
    o
  ), a, s = e.basename || "/", l = e.dataStrategy || kp, u = {
    unstable_middleware: !1,
    ...e.future
  }, c = null, f = /* @__PURE__ */ new Set(), m = null, p = null, b = null, _ = e.hydrationData != null, v = ut(i, e.history.location, s), w = !1, S = null;
  if (v == null && !e.patchRoutesOnNavigation) {
    let d = Ce(404, {
      pathname: e.history.location.pathname
    }), { matches: h, route: y } = Ki(i);
    v = h, S = { [y.id]: d };
  }
  v && !e.hydrationData && wr(
    v,
    i,
    e.history.location.pathname
  ).active && (v = null);
  let x;
  if (v)
    if (v.some((d) => d.route.lazy))
      x = !1;
    else if (!v.some((d) => d.route.loader))
      x = !0;
    else {
      let d = e.hydrationData ? e.hydrationData.loaderData : null, h = e.hydrationData ? e.hydrationData.errors : null;
      if (h) {
        let y = v.findIndex(
          (E) => h[E.route.id] !== void 0
        );
        x = v.slice(0, y + 1).every((E) => !to(E.route, d, h));
      } else
        x = v.every(
          (y) => !to(y.route, d, h)
        );
    }
  else {
    x = !1, v = [];
    let d = wr(
      null,
      i,
      e.history.location.pathname
    );
    d.active && d.matches && (w = !0, v = d.matches);
  }
  let I, g = {
    historyAction: e.history.action,
    location: e.history.location,
    matches: v,
    initialized: x,
    navigation: Mn,
    // Don't restore on initial updateState() if we were SSR'd
    restoreScrollPosition: e.hydrationData != null ? !1 : null,
    preventScrollReset: !1,
    revalidation: "idle",
    loaderData: e.hydrationData && e.hydrationData.loaderData || {},
    actionData: e.hydrationData && e.hydrationData.actionData || null,
    errors: e.hydrationData && e.hydrationData.errors || S,
    fetchers: /* @__PURE__ */ new Map(),
    blockers: /* @__PURE__ */ new Map()
  }, C = "POP", D = !1, T, A = !1, K = /* @__PURE__ */ new Map(), ee = null, q = !1, Re = !1, He = /* @__PURE__ */ new Set(), Z = /* @__PURE__ */ new Map(), qe = 0, Ze = -1, ke = /* @__PURE__ */ new Map(), me = /* @__PURE__ */ new Set(), ze = /* @__PURE__ */ new Map(), ge = /* @__PURE__ */ new Map(), Ne = /* @__PURE__ */ new Set(), mt = /* @__PURE__ */ new Map(), vr, gt = null;
  function Ks() {
    if (c = e.history.listen(
      ({ action: d, location: h, delta: y }) => {
        if (vr) {
          vr(), vr = void 0;
          return;
        }
        le(
          mt.size === 0 || y != null,
          "You are trying to use a blocker on a POP navigation to a location that was not created by @remix-run/router. This will fail silently in production. This can happen if you are navigating outside the router via `window.history.pushState`/`window.location.hash` instead of using router navigation APIs.  This can also happen if you are using createHashRouter and the user manually changes the URL."
        );
        let E = Ko({
          currentLocation: g.location,
          nextLocation: h,
          historyAction: d
        });
        if (E && y != null) {
          let R = new Promise(($) => {
            vr = $;
          });
          e.history.go(y * -1), br(E, {
            state: "blocked",
            location: h,
            proceed() {
              br(E, {
                state: "proceeding",
                proceed: void 0,
                reset: void 0,
                location: h
              }), R.then(() => e.history.go(y));
            },
            reset() {
              let $ = new Map(g.blockers);
              $.set(E, rr), ye({ blockers: $ });
            }
          });
          return;
        }
        return yt(d, h);
      }
    ), r) {
      Wp(t, K);
      let d = () => Vp(t, K);
      t.addEventListener("pagehide", d), ee = () => t.removeEventListener("pagehide", d);
    }
    return g.initialized || yt("POP", g.location, {
      initialHydration: !0
    }), I;
  }
  function Ys() {
    c && c(), ee && ee(), f.clear(), T && T.abort(), g.fetchers.forEach((d, h) => wn(h)), g.blockers.forEach((d, h) => Vo(h));
  }
  function Qs(d) {
    return f.add(d), () => f.delete(d);
  }
  function ye(d, h = {}) {
    g = {
      ...g,
      ...d
    };
    let y = [], E = [];
    g.fetchers.forEach((R, $) => {
      R.state === "idle" && (Ne.has($) ? y.push($) : E.push($));
    }), Ne.forEach((R) => {
      !g.fetchers.has(R) && !Z.has(R) && y.push(R);
    }), [...f].forEach(
      (R) => R(g, {
        deletedFetchers: y,
        viewTransitionOpts: h.viewTransitionOpts,
        flushSync: h.flushSync === !0
      })
    ), y.forEach((R) => wn(R)), E.forEach((R) => g.fetchers.delete(R));
  }
  function kt(d, h, { flushSync: y } = {}) {
    var P, L;
    let E = g.actionData != null && g.navigation.formMethod != null && De(g.navigation.formMethod) && g.navigation.state === "loading" && ((P = d.state) == null ? void 0 : P._isRedirect) !== !0, R;
    h.actionData ? Object.keys(h.actionData).length > 0 ? R = h.actionData : R = null : E ? R = g.actionData : R = null;
    let $ = h.loaderData ? Wi(
      g.loaderData,
      h.loaderData,
      h.matches || [],
      h.errors
    ) : g.loaderData, N = g.blockers;
    N.size > 0 && (N = new Map(N), N.forEach((F, z) => N.set(z, rr)));
    let M = D === !0 || g.navigation.formMethod != null && De(g.navigation.formMethod) && ((L = d.state) == null ? void 0 : L._isRedirect) !== !0;
    a && (i = a, a = void 0), q || C === "POP" || (C === "PUSH" ? e.history.push(d, d.state) : C === "REPLACE" && e.history.replace(d, d.state));
    let k;
    if (C === "POP") {
      let F = K.get(g.location.pathname);
      F && F.has(d.pathname) ? k = {
        currentLocation: g.location,
        nextLocation: d
      } : K.has(d.pathname) && (k = {
        currentLocation: d,
        nextLocation: g.location
      });
    } else if (A) {
      let F = K.get(g.location.pathname);
      F ? F.add(d.pathname) : (F = /* @__PURE__ */ new Set([d.pathname]), K.set(g.location.pathname, F)), k = {
        currentLocation: g.location,
        nextLocation: d
      };
    }
    ye(
      {
        ...h,
        // matches, errors, fetchers go through as-is
        actionData: R,
        loaderData: $,
        historyAction: C,
        location: d,
        initialized: !0,
        navigation: Mn,
        revalidation: "idle",
        restoreScrollPosition: Qo(
          d,
          h.matches || g.matches
        ),
        preventScrollReset: M,
        blockers: N
      },
      {
        viewTransitionOpts: k,
        flushSync: y === !0
      }
    ), C = "POP", D = !1, A = !1, q = !1, Re = !1, gt == null || gt.resolve(), gt = null;
  }
  async function Uo(d, h) {
    if (typeof d == "number") {
      e.history.go(d);
      return;
    }
    let y = eo(
      g.location,
      g.matches,
      s,
      d,
      h == null ? void 0 : h.fromRouteId,
      h == null ? void 0 : h.relative
    ), { path: E, submission: R, error: $ } = Fi(
      !1,
      y,
      h
    ), N = g.location, M = cr(g.location, E, h && h.state);
    M = {
      ...M,
      ...e.history.encodeLocation(M)
    };
    let k = h && h.replace != null ? h.replace : void 0, P = "PUSH";
    k === !0 ? P = "REPLACE" : k === !1 || R != null && De(R.formMethod) && R.formAction === g.location.pathname + g.location.search && (P = "REPLACE");
    let L = h && "preventScrollReset" in h ? h.preventScrollReset === !0 : void 0, F = (h && h.flushSync) === !0, z = Ko({
      currentLocation: N,
      nextLocation: M,
      historyAction: P
    });
    if (z) {
      br(z, {
        state: "blocked",
        location: M,
        proceed() {
          br(z, {
            state: "proceeding",
            proceed: void 0,
            reset: void 0,
            location: M
          }), Uo(d, h);
        },
        reset() {
          let X = new Map(g.blockers);
          X.set(z, rr), ye({ blockers: X });
        }
      });
      return;
    }
    await yt(P, M, {
      submission: R,
      // Send through the formData serialization error if we have one so we can
      // render at the right error boundary after we match routes
      pendingError: $,
      preventScrollReset: L,
      replace: h && h.replace,
      enableViewTransition: h && h.viewTransition,
      flushSync: F
    });
  }
  function Xs() {
    gt || (gt = Kp()), bn(), ye({ revalidation: "loading" });
    let d = gt.promise;
    return g.navigation.state === "submitting" ? d : g.navigation.state === "idle" ? (yt(g.historyAction, g.location, {
      startUninterruptedRevalidation: !0
    }), d) : (yt(
      C || g.historyAction,
      g.navigation.location,
      {
        overrideNavigation: g.navigation,
        // Proxy through any rending view transition
        enableViewTransition: A === !0
      }
    ), d);
  }
  async function yt(d, h, y) {
    T && T.abort(), T = null, C = d, q = (y && y.startUninterruptedRevalidation) === !0, sl(g.location, g.matches), D = (y && y.preventScrollReset) === !0, A = (y && y.enableViewTransition) === !0;
    let E = a || i, R = y && y.overrideNavigation, $ = y != null && y.initialHydration && g.matches && g.matches.length > 0 && !w ? (
      // `matchRoutes()` has already been called if we're in here via `router.initialize()`
      g.matches
    ) : ut(E, h, s), N = (y && y.flushSync) === !0;
    if ($ && g.initialized && !Re && Hp(g.location, h) && !(y && y.submission && De(y.submission.formMethod))) {
      kt(h, { matches: $ }, { flushSync: N });
      return;
    }
    let M = wr($, E, h.pathname);
    if (M.active && M.matches && ($ = M.matches), !$) {
      let { error: te, notFoundMatches: J, route: ne } = _n(
        h.pathname
      );
      kt(
        h,
        {
          matches: J,
          loaderData: {},
          errors: {
            [ne.id]: te
          }
        },
        { flushSync: N }
      );
      return;
    }
    T = new AbortController();
    let k = Ft(
      e.history,
      h,
      T.signal,
      y && y.submission
    ), P = new Ni(
      e.unstable_getContext ? await e.unstable_getContext() : void 0
    ), L;
    if (y && y.pendingError)
      L = [
        wt($).route.id,
        { type: "error", error: y.pendingError }
      ];
    else if (y && y.submission && De(y.submission.formMethod)) {
      let te = await Js(
        k,
        h,
        y.submission,
        $,
        P,
        M.active,
        { replace: y.replace, flushSync: N }
      );
      if (te.shortCircuited)
        return;
      if (te.pendingActionResult) {
        let [J, ne] = te.pendingActionResult;
        if (Ee(ne) && dr(ne.error) && ne.error.status === 404) {
          T = null, kt(h, {
            matches: te.matches,
            loaderData: {},
            errors: {
              [J]: ne.error
            }
          });
          return;
        }
      }
      $ = te.matches || $, L = te.pendingActionResult, R = In(h, y.submission), N = !1, M.active = !1, k = Ft(
        e.history,
        k.url,
        k.signal
      );
    }
    let {
      shortCircuited: F,
      matches: z,
      loaderData: X,
      errors: de
    } = await Zs(
      k,
      h,
      $,
      P,
      M.active,
      R,
      y && y.submission,
      y && y.fetcherSubmission,
      y && y.replace,
      y && y.initialHydration === !0,
      N,
      L
    );
    F || (T = null, kt(h, {
      matches: z || $,
      ...Vi(L),
      loaderData: X,
      errors: de
    }));
  }
  async function Js(d, h, y, E, R, $, N = {}) {
    bn();
    let M = Bp(h, y);
    if (ye({ navigation: M }, { flushSync: N.flushSync === !0 }), $) {
      let L = await _r(
        E,
        h.pathname,
        d.signal
      );
      if (L.type === "aborted")
        return { shortCircuited: !0 };
      if (L.type === "error") {
        let F = wt(L.partialMatches).route.id;
        return {
          matches: L.partialMatches,
          pendingActionResult: [
            F,
            {
              type: "error",
              error: L.error
            }
          ]
        };
      } else if (L.matches)
        E = L.matches;
      else {
        let { notFoundMatches: F, error: z, route: X } = _n(
          h.pathname
        );
        return {
          matches: F,
          pendingActionResult: [
            X.id,
            {
              type: "error",
              error: z
            }
          ]
        };
      }
    }
    let k, P = sr(E, h);
    if (!P.route.action && !P.route.lazy)
      k = {
        type: "error",
        error: Ce(405, {
          method: d.method,
          pathname: h.pathname,
          routeId: P.route.id
        })
      };
    else {
      let L = await Yt(
        "action",
        d,
        [P],
        E,
        R,
        null
      );
      if (k = L[P.route.id], !k) {
        for (let F of E)
          if (L[F.route.id]) {
            k = L[F.route.id];
            break;
          }
      }
      if (d.signal.aborted)
        return { shortCircuited: !0 };
    }
    if (St(k)) {
      let L;
      return N && N.replace != null ? L = N.replace : L = zi(
        k.response.headers.get("Location"),
        new URL(d.url),
        s
      ) === g.location.pathname + g.location.search, await vt(d, k, !0, {
        submission: y,
        replace: L
      }), { shortCircuited: !0 };
    }
    if (Ee(k)) {
      let L = wt(E, P.route.id);
      return (N && N.replace) !== !0 && (C = "PUSH"), {
        matches: E,
        pendingActionResult: [L.route.id, k]
      };
    }
    return {
      matches: E,
      pendingActionResult: [P.route.id, k]
    };
  }
  async function Zs(d, h, y, E, R, $, N, M, k, P, L, F) {
    let z = $ || In(h, N), X = N || M || Qi(z), de = !q && !P;
    if (R) {
      if (de) {
        let fe = Ho(F);
        ye(
          {
            navigation: z,
            ...fe !== void 0 ? { actionData: fe } : {}
          },
          {
            flushSync: L
          }
        );
      }
      let Y = await _r(
        y,
        h.pathname,
        d.signal
      );
      if (Y.type === "aborted")
        return { shortCircuited: !0 };
      if (Y.type === "error") {
        let fe = wt(Y.partialMatches).route.id;
        return {
          matches: Y.partialMatches,
          loaderData: {},
          errors: {
            [fe]: Y.error
          }
        };
      } else if (Y.matches)
        y = Y.matches;
      else {
        let { error: fe, notFoundMatches: Sr, route: Jt } = _n(
          h.pathname
        );
        return {
          matches: Sr,
          loaderData: {},
          errors: {
            [Jt.id]: fe
          }
        };
      }
    }
    let te = a || i, [J, ne] = ji(
      e.history,
      g,
      y,
      X,
      h,
      P === !0,
      Re,
      He,
      Ne,
      ze,
      me,
      te,
      s,
      F
    );
    if (Ze = ++qe, J.length === 0 && ne.length === 0) {
      let Y = Go();
      return kt(
        h,
        {
          matches: y,
          loaderData: {},
          // Commit pending error if we're short circuiting
          errors: F && Ee(F[1]) ? { [F[0]]: F[1].error } : null,
          ...Vi(F),
          ...Y ? { fetchers: new Map(g.fetchers) } : {}
        },
        { flushSync: L }
      ), { shortCircuited: !0 };
    }
    if (de) {
      let Y = {};
      if (!R) {
        Y.navigation = z;
        let fe = Ho(F);
        fe !== void 0 && (Y.actionData = fe);
      }
      ne.length > 0 && (Y.fetchers = el(ne)), ye(Y, { flushSync: L });
    }
    ne.forEach((Y) => {
      tt(Y.key), Y.controller && Z.set(Y.key, Y.controller);
    });
    let Nt = () => ne.forEach((Y) => tt(Y.key));
    T && T.signal.addEventListener(
      "abort",
      Nt
    );
    let { loaderResults: Qt, fetcherResults: Ge } = await qo(
      y,
      J,
      ne,
      d,
      E
    );
    if (d.signal.aborted)
      return { shortCircuited: !0 };
    T && T.signal.removeEventListener(
      "abort",
      Nt
    ), ne.forEach((Y) => Z.delete(Y.key));
    let $e = Lr(Qt);
    if ($e)
      return await vt(d, $e.result, !0, {
        replace: k
      }), { shortCircuited: !0 };
    if ($e = Lr(Ge), $e)
      return me.add($e.key), await vt(d, $e.result, !0, {
        replace: k
      }), { shortCircuited: !0 };
    let { loaderData: En, errors: Xt } = Gi(
      g,
      y,
      Qt,
      F,
      ne,
      Ge
    );
    P && g.errors && (Xt = { ...g.errors, ...Xt });
    let bt = Go(), Er = Wo(Ze), xr = bt || Er || ne.length > 0;
    return {
      matches: y,
      loaderData: En,
      errors: Xt,
      ...xr ? { fetchers: new Map(g.fetchers) } : {}
    };
  }
  function Ho(d) {
    if (d && !Ee(d[1]))
      return {
        [d[0]]: d[1].data
      };
    if (g.actionData)
      return Object.keys(g.actionData).length === 0 ? null : g.actionData;
  }
  function el(d) {
    return d.forEach((h) => {
      let y = g.fetchers.get(h.key), E = nr(
        void 0,
        y ? y.data : void 0
      );
      g.fetchers.set(h.key, E);
    }), new Map(g.fetchers);
  }
  async function tl(d, h, y, E) {
    tt(d);
    let R = (E && E.flushSync) === !0, $ = a || i, N = eo(
      g.location,
      g.matches,
      s,
      y,
      h,
      E == null ? void 0 : E.relative
    ), M = ut($, N, s), k = wr(M, $, N);
    if (k.active && k.matches && (M = k.matches), !M) {
      Be(
        d,
        h,
        Ce(404, { pathname: N }),
        { flushSync: R }
      );
      return;
    }
    let { path: P, submission: L, error: F } = Fi(
      !0,
      N,
      E
    );
    if (F) {
      Be(d, h, F, { flushSync: R });
      return;
    }
    let z = sr(M, P), X = new Ni(
      e.unstable_getContext ? await e.unstable_getContext() : void 0
    ), de = (E && E.preventScrollReset) === !0;
    if (L && De(L.formMethod)) {
      await rl(
        d,
        h,
        P,
        z,
        M,
        X,
        k.active,
        R,
        de,
        L
      );
      return;
    }
    ze.set(d, { routeId: h, path: P }), await nl(
      d,
      h,
      P,
      z,
      M,
      X,
      k.active,
      R,
      de,
      L
    );
  }
  async function rl(d, h, y, E, R, $, N, M, k, P) {
    bn(), ze.delete(d);
    function L(re) {
      if (!re.route.action && !re.route.lazy) {
        let $t = Ce(405, {
          method: P.formMethod,
          pathname: y,
          routeId: h
        });
        return Be(d, h, $t, { flushSync: M }), !0;
      }
      return !1;
    }
    if (!N && L(E))
      return;
    let F = g.fetchers.get(d);
    et(d, Gp(P, F), {
      flushSync: M
    });
    let z = new AbortController(), X = Ft(
      e.history,
      y,
      z.signal,
      P
    );
    if (N) {
      let re = await _r(
        R,
        y,
        X.signal,
        d
      );
      if (re.type === "aborted")
        return;
      if (re.type === "error") {
        Be(d, h, re.error, { flushSync: M });
        return;
      } else if (re.matches) {
        if (R = re.matches, E = sr(R, y), L(E))
          return;
      } else {
        Be(
          d,
          h,
          Ce(404, { pathname: y }),
          { flushSync: M }
        );
        return;
      }
    }
    Z.set(d, z);
    let de = qe, J = (await Yt(
      "action",
      X,
      [E],
      R,
      $,
      d
    ))[E.route.id];
    if (X.signal.aborted) {
      Z.get(d) === z && Z.delete(d);
      return;
    }
    if (Ne.has(d)) {
      if (St(J) || Ee(J)) {
        et(d, ot(void 0));
        return;
      }
    } else {
      if (St(J))
        if (Z.delete(d), Ze > de) {
          et(d, ot(void 0));
          return;
        } else
          return me.add(d), et(d, nr(P)), vt(X, J, !1, {
            fetcherSubmission: P,
            preventScrollReset: k
          });
      if (Ee(J)) {
        Be(d, h, J.error);
        return;
      }
    }
    let ne = g.navigation.location || g.location, Nt = Ft(
      e.history,
      ne,
      z.signal
    ), Qt = a || i, Ge = g.navigation.state !== "idle" ? ut(Qt, g.navigation.location, s) : g.matches;
    U(Ge, "Didn't find any matches after fetcher action");
    let $e = ++qe;
    ke.set(d, $e);
    let En = nr(P, J.data);
    g.fetchers.set(d, En);
    let [Xt, bt] = ji(
      e.history,
      g,
      Ge,
      P,
      ne,
      !1,
      Re,
      He,
      Ne,
      ze,
      me,
      Qt,
      s,
      [E.route.id, J]
    );
    bt.filter((re) => re.key !== d).forEach((re) => {
      let $t = re.key, Xo = g.fetchers.get($t), cl = nr(
        void 0,
        Xo ? Xo.data : void 0
      );
      g.fetchers.set($t, cl), tt($t), re.controller && Z.set($t, re.controller);
    }), ye({ fetchers: new Map(g.fetchers) });
    let Er = () => bt.forEach((re) => tt(re.key));
    z.signal.addEventListener(
      "abort",
      Er
    );
    let { loaderResults: xr, fetcherResults: Y } = await qo(
      Ge,
      Xt,
      bt,
      Nt,
      $
    );
    if (z.signal.aborted)
      return;
    z.signal.removeEventListener(
      "abort",
      Er
    ), ke.delete(d), Z.delete(d), bt.forEach((re) => Z.delete(re.key));
    let fe = Lr(xr);
    if (fe)
      return vt(
        Nt,
        fe.result,
        !1,
        { preventScrollReset: k }
      );
    if (fe = Lr(Y), fe)
      return me.add(fe.key), vt(
        Nt,
        fe.result,
        !1,
        { preventScrollReset: k }
      );
    let { loaderData: Sr, errors: Jt } = Gi(
      g,
      Ge,
      xr,
      void 0,
      bt,
      Y
    );
    if (g.fetchers.has(d)) {
      let re = ot(J.data);
      g.fetchers.set(d, re);
    }
    Wo($e), g.navigation.state === "loading" && $e > Ze ? (U(C, "Expected pending action"), T && T.abort(), kt(g.navigation.location, {
      matches: Ge,
      loaderData: Sr,
      errors: Jt,
      fetchers: new Map(g.fetchers)
    })) : (ye({
      errors: Jt,
      loaderData: Wi(
        g.loaderData,
        Sr,
        Ge,
        Jt
      ),
      fetchers: new Map(g.fetchers)
    }), Re = !1);
  }
  async function nl(d, h, y, E, R, $, N, M, k, P) {
    let L = g.fetchers.get(d);
    et(
      d,
      nr(
        P,
        L ? L.data : void 0
      ),
      { flushSync: M }
    );
    let F = new AbortController(), z = Ft(
      e.history,
      y,
      F.signal
    );
    if (N) {
      let J = await _r(
        R,
        y,
        z.signal,
        d
      );
      if (J.type === "aborted")
        return;
      if (J.type === "error") {
        Be(d, h, J.error, { flushSync: M });
        return;
      } else if (J.matches)
        R = J.matches, E = sr(R, y);
      else {
        Be(
          d,
          h,
          Ce(404, { pathname: y }),
          { flushSync: M }
        );
        return;
      }
    }
    Z.set(d, F);
    let X = qe, te = (await Yt(
      "loader",
      z,
      [E],
      R,
      $,
      d
    ))[E.route.id];
    if (Z.get(d) === F && Z.delete(d), !z.signal.aborted) {
      if (Ne.has(d)) {
        et(d, ot(void 0));
        return;
      }
      if (St(te))
        if (Ze > X) {
          et(d, ot(void 0));
          return;
        } else {
          me.add(d), await vt(z, te, !1, {
            preventScrollReset: k
          });
          return;
        }
      if (Ee(te)) {
        Be(d, h, te.error);
        return;
      }
      et(d, ot(te.data));
    }
  }
  async function vt(d, h, y, {
    submission: E,
    fetcherSubmission: R,
    preventScrollReset: $,
    replace: N
  } = {}) {
    h.response.headers.has("X-Remix-Revalidate") && (Re = !0);
    let M = h.response.headers.get("Location");
    U(M, "Expected a Location header on the redirect Response"), M = zi(
      M,
      new URL(d.url),
      s
    );
    let k = cr(g.location, M, {
      _isRedirect: !0
    });
    if (r) {
      let de = !1;
      if (h.response.headers.has("X-Remix-Reload-Document"))
        de = !0;
      else if (Io.test(M)) {
        const te = e.history.createURL(M);
        de = // Hard reload if it's an absolute URL to a new origin
        te.origin !== t.location.origin || // Hard reload if it's an absolute URL that does not match our basename
        Pe(te.pathname, s) == null;
      }
      if (de) {
        N ? t.location.replace(M) : t.location.assign(M);
        return;
      }
    }
    T = null;
    let P = N === !0 || h.response.headers.has("X-Remix-Replace") ? "REPLACE" : "PUSH", { formMethod: L, formAction: F, formEncType: z } = g.navigation;
    !E && !R && L && F && z && (E = Qi(g.navigation));
    let X = E || R;
    if (Cp.has(h.response.status) && X && De(X.formMethod))
      await yt(P, k, {
        submission: {
          ...X,
          formAction: M
        },
        // Preserve these flags across redirects
        preventScrollReset: $ || D,
        enableViewTransition: y ? A : void 0
      });
    else {
      let de = In(
        k,
        E
      );
      await yt(P, k, {
        overrideNavigation: de,
        // Send fetcher submissions through for shouldRevalidate
        fetcherSubmission: R,
        // Preserve these flags across redirects
        preventScrollReset: $ || D,
        enableViewTransition: y ? A : void 0
      });
    }
  }
  async function Yt(d, h, y, E, R, $) {
    let N, M = {};
    try {
      N = await $p(
        l,
        d,
        h,
        y,
        E,
        $,
        o,
        n,
        R,
        u.unstable_middleware
      );
    } catch (k) {
      return y.forEach((P) => {
        M[P.route.id] = {
          type: "error",
          error: k
        };
      }), M;
    }
    for (let [k, P] of Object.entries(N))
      if (qp(P)) {
        let L = P.result;
        M[k] = {
          type: "redirect",
          response: jp(
            L,
            h,
            k,
            E,
            s
          )
        };
      } else
        M[k] = await Ap(
          P
        );
    return M;
  }
  async function qo(d, h, y, E, R) {
    let $ = Yt(
      "loader",
      E,
      h,
      d,
      R,
      null
    ), N = Promise.all(
      y.map(async (P) => {
        if (P.matches && P.match && P.controller) {
          let F = (await Yt(
            "loader",
            Ft(e.history, P.path, P.controller.signal),
            [P.match],
            P.matches,
            R,
            P.key
          ))[P.match.route.id];
          return { [P.key]: F };
        } else
          return Promise.resolve({
            [P.key]: {
              type: "error",
              error: Ce(404, {
                pathname: P.path
              })
            }
          });
      })
    ), M = await $, k = (await N).reduce(
      (P, L) => Object.assign(P, L),
      {}
    );
    return {
      loaderResults: M,
      fetcherResults: k
    };
  }
  function bn() {
    Re = !0, ze.forEach((d, h) => {
      Z.has(h) && He.add(h), tt(h);
    });
  }
  function et(d, h, y = {}) {
    g.fetchers.set(d, h), ye(
      { fetchers: new Map(g.fetchers) },
      { flushSync: (y && y.flushSync) === !0 }
    );
  }
  function Be(d, h, y, E = {}) {
    let R = wt(g.matches, h);
    wn(d), ye(
      {
        errors: {
          [R.route.id]: y
        },
        fetchers: new Map(g.fetchers)
      },
      { flushSync: (E && E.flushSync) === !0 }
    );
  }
  function zo(d) {
    return ge.set(d, (ge.get(d) || 0) + 1), Ne.has(d) && Ne.delete(d), g.fetchers.get(d) || Pp;
  }
  function wn(d) {
    let h = g.fetchers.get(d);
    Z.has(d) && !(h && h.state === "loading" && ke.has(d)) && tt(d), ze.delete(d), ke.delete(d), me.delete(d), Ne.delete(d), He.delete(d), g.fetchers.delete(d);
  }
  function ol(d) {
    let h = (ge.get(d) || 0) - 1;
    h <= 0 ? (ge.delete(d), Ne.add(d)) : ge.set(d, h), ye({ fetchers: new Map(g.fetchers) });
  }
  function tt(d) {
    let h = Z.get(d);
    h && (h.abort(), Z.delete(d));
  }
  function Bo(d) {
    for (let h of d) {
      let y = zo(h), E = ot(y.data);
      g.fetchers.set(h, E);
    }
  }
  function Go() {
    let d = [], h = !1;
    for (let y of me) {
      let E = g.fetchers.get(y);
      U(E, `Expected fetcher: ${y}`), E.state === "loading" && (me.delete(y), d.push(y), h = !0);
    }
    return Bo(d), h;
  }
  function Wo(d) {
    let h = [];
    for (let [y, E] of ke)
      if (E < d) {
        let R = g.fetchers.get(y);
        U(R, `Expected fetcher: ${y}`), R.state === "loading" && (tt(y), ke.delete(y), h.push(y));
      }
    return Bo(h), h.length > 0;
  }
  function il(d, h) {
    let y = g.blockers.get(d) || rr;
    return mt.get(d) !== h && mt.set(d, h), y;
  }
  function Vo(d) {
    g.blockers.delete(d), mt.delete(d);
  }
  function br(d, h) {
    let y = g.blockers.get(d) || rr;
    U(
      y.state === "unblocked" && h.state === "blocked" || y.state === "blocked" && h.state === "blocked" || y.state === "blocked" && h.state === "proceeding" || y.state === "blocked" && h.state === "unblocked" || y.state === "proceeding" && h.state === "unblocked",
      `Invalid blocker state transition: ${y.state} -> ${h.state}`
    );
    let E = new Map(g.blockers);
    E.set(d, h), ye({ blockers: E });
  }
  function Ko({
    currentLocation: d,
    nextLocation: h,
    historyAction: y
  }) {
    if (mt.size === 0)
      return;
    mt.size > 1 && le(!1, "A router only supports one blocker at a time");
    let E = Array.from(mt.entries()), [R, $] = E[E.length - 1], N = g.blockers.get(R);
    if (!(N && N.state === "proceeding") && $({ currentLocation: d, nextLocation: h, historyAction: y }))
      return R;
  }
  function _n(d) {
    let h = Ce(404, { pathname: d }), y = a || i, { matches: E, route: R } = Ki(y);
    return { notFoundMatches: E, route: R, error: h };
  }
  function al(d, h, y) {
    if (m = d, b = h, p = y || null, !_ && g.navigation === Mn) {
      _ = !0;
      let E = Qo(g.location, g.matches);
      E != null && ye({ restoreScrollPosition: E });
    }
    return () => {
      m = null, b = null, p = null;
    };
  }
  function Yo(d, h) {
    return p && p(
      d,
      h.map((E) => op(E, g.loaderData))
    ) || d.key;
  }
  function sl(d, h) {
    if (m && b) {
      let y = Yo(d, h);
      m[y] = b();
    }
  }
  function Qo(d, h) {
    if (m) {
      let y = Yo(d, h), E = m[y];
      if (typeof E == "number")
        return E;
    }
    return null;
  }
  function wr(d, h, y) {
    if (e.patchRoutesOnNavigation)
      if (d) {
        if (Object.keys(d[0].params).length > 0)
          return { active: !0, matches: Fr(
            h,
            y,
            s,
            !0
          ) };
      } else
        return { active: !0, matches: Fr(
          h,
          y,
          s,
          !0
        ) || [] };
    return { active: !1, matches: null };
  }
  async function _r(d, h, y, E) {
    if (!e.patchRoutesOnNavigation)
      return { type: "success", matches: d };
    let R = d;
    for (; ; ) {
      let $ = a == null, N = a || i, M = o;
      try {
        await e.patchRoutesOnNavigation({
          signal: y,
          path: h,
          matches: R,
          fetcherKey: E,
          patch: (L, F) => {
            y.aborted || Hi(
              L,
              F,
              N,
              M,
              n
            );
          }
        });
      } catch (L) {
        return { type: "error", error: L, partialMatches: R };
      } finally {
        $ && !y.aborted && (i = [...i]);
      }
      if (y.aborted)
        return { type: "aborted" };
      let k = ut(N, h, s);
      if (k)
        return { type: "success", matches: k };
      let P = Fr(
        N,
        h,
        s,
        !0
      );
      if (!P || R.length === P.length && R.every(
        (L, F) => L.route.id === P[F].route.id
      ))
        return { type: "success", matches: null };
      R = P;
    }
  }
  function ll(d) {
    o = {}, a = Vr(
      d,
      n,
      void 0,
      o
    );
  }
  function ul(d, h) {
    let y = a == null;
    Hi(
      d,
      h,
      a || i,
      o,
      n
    ), y && (i = [...i], ye({}));
  }
  return I = {
    get basename() {
      return s;
    },
    get future() {
      return u;
    },
    get state() {
      return g;
    },
    get routes() {
      return i;
    },
    get window() {
      return t;
    },
    initialize: Ks,
    subscribe: Qs,
    enableScrollRestoration: al,
    navigate: Uo,
    fetch: tl,
    revalidate: Xs,
    // Passthrough to history-aware createHref used by useHref so we get proper
    // hash-aware URLs in DOM paths
    createHref: (d) => e.history.createHref(d),
    encodeLocation: (d) => e.history.encodeLocation(d),
    getFetcher: zo,
    deleteFetcher: ol,
    dispose: Ys,
    getBlocker: il,
    deleteBlocker: Vo,
    patchRoutes: ul,
    _internalFetchControllers: Z,
    // TODO: Remove setRoutes, it's temporary to avoid dealing with
    // updating the tree while validating the update algorithm.
    _internalSetRoutes: ll
  }, I;
}
function Op(e) {
  return e != null && ("formData" in e && e.formData != null || "body" in e && e.body !== void 0);
}
function eo(e, t, r, n, o, i) {
  let a, s;
  if (o) {
    a = [];
    for (let u of t)
      if (a.push(u), u.route.id === o) {
        s = u;
        break;
      }
  } else
    a = t, s = t[t.length - 1];
  let l = Mo(
    n || ".",
    Oo(a),
    Pe(e.pathname, r) || e.pathname,
    i === "path"
  );
  if (n == null && (l.search = e.search, l.hash = e.hash), (n == null || n === "" || n === ".") && s) {
    let u = Lo(l.search);
    if (s.route.index && !u)
      l.search = l.search ? l.search.replace(/^\?/, "?index&") : "?index";
    else if (!s.route.index && u) {
      let c = new URLSearchParams(l.search), f = c.getAll("index");
      c.delete("index"), f.filter((p) => p).forEach((p) => c.append("index", p));
      let m = c.toString();
      l.search = m ? `?${m}` : "";
    }
  }
  return r !== "/" && (l.pathname = l.pathname === "/" ? r : Fe([r, l.pathname])), dt(l);
}
function Fi(e, t, r) {
  if (!r || !Op(r))
    return { path: t };
  if (r.formMethod && !zp(r.formMethod))
    return {
      path: t,
      error: Ce(405, { method: r.formMethod })
    };
  let n = () => ({
    path: t,
    error: Ce(400, { type: "invalid-body" })
  }), i = (r.formMethod || "get").toUpperCase(), a = $s(t);
  if (r.body !== void 0) {
    if (r.formEncType === "text/plain") {
      if (!De(i))
        return n();
      let f = typeof r.body == "string" ? r.body : r.body instanceof FormData || r.body instanceof URLSearchParams ? (
        // https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#plain-text-form-data
        Array.from(r.body.entries()).reduce(
          (m, [p, b]) => `${m}${p}=${b}
`,
          ""
        )
      ) : String(r.body);
      return {
        path: t,
        submission: {
          formMethod: i,
          formAction: a,
          formEncType: r.formEncType,
          formData: void 0,
          json: void 0,
          text: f
        }
      };
    } else if (r.formEncType === "application/json") {
      if (!De(i))
        return n();
      try {
        let f = typeof r.body == "string" ? JSON.parse(r.body) : r.body;
        return {
          path: t,
          submission: {
            formMethod: i,
            formAction: a,
            formEncType: r.formEncType,
            formData: void 0,
            json: f,
            text: void 0
          }
        };
      } catch {
        return n();
      }
    }
  }
  U(
    typeof FormData == "function",
    "FormData is not available in this environment"
  );
  let s, l;
  if (r.formData)
    s = no(r.formData), l = r.formData;
  else if (r.body instanceof FormData)
    s = no(r.body), l = r.body;
  else if (r.body instanceof URLSearchParams)
    s = r.body, l = Bi(s);
  else if (r.body == null)
    s = new URLSearchParams(), l = new FormData();
  else
    try {
      s = new URLSearchParams(r.body), l = Bi(s);
    } catch {
      return n();
    }
  let u = {
    formMethod: i,
    formAction: a,
    formEncType: r && r.formEncType || "application/x-www-form-urlencoded",
    formData: l,
    json: void 0,
    text: void 0
  };
  if (De(u.formMethod))
    return { path: t, submission: u };
  let c = Ae(t);
  return e && c.search && Lo(c.search) && s.append("index", ""), c.search = `?${s}`, { path: dt(c), submission: u };
}
function Ai(e, t, r = !1) {
  let n = e.findIndex((o) => o.route.id === t);
  return n >= 0 ? e.slice(0, r ? n + 1 : n) : e;
}
function ji(e, t, r, n, o, i, a, s, l, u, c, f, m, p) {
  let b = p ? Ee(p[1]) ? p[1].error : p[1].data : void 0, _ = e.createURL(t.location), v = e.createURL(o), w = r;
  i && t.errors ? w = Ai(
    r,
    Object.keys(t.errors)[0],
    !0
  ) : p && Ee(p[1]) && (w = Ai(
    r,
    p[0]
  ));
  let S = p ? p[1].statusCode : void 0, x = S && S >= 400, I = w.filter((C, D) => {
    let { route: T } = C;
    if (T.lazy)
      return !0;
    if (T.loader == null)
      return !1;
    if (i)
      return to(T, t.loaderData, t.errors);
    if (Mp(t.loaderData, t.matches[D], C))
      return !0;
    let A = t.matches[D], K = C;
    return Ui(C, {
      currentUrl: _,
      currentParams: A.params,
      nextUrl: v,
      nextParams: K.params,
      ...n,
      actionResult: b,
      actionStatus: S,
      defaultShouldRevalidate: x ? !1 : (
        // Forced revalidation due to submission, useRevalidator, or X-Remix-Revalidate
        a || _.pathname + _.search === v.pathname + v.search || // Search params affect all loaders
        _.search !== v.search || Ip(A, K)
      )
    });
  }), g = [];
  return u.forEach((C, D) => {
    if (i || !r.some((q) => q.route.id === C.routeId) || l.has(D))
      return;
    let T = ut(f, C.path, m);
    if (!T) {
      g.push({
        key: D,
        routeId: C.routeId,
        path: C.path,
        matches: null,
        match: null,
        controller: null
      });
      return;
    }
    let A = t.fetchers.get(D), K = sr(T, C.path), ee = !1;
    c.has(D) ? ee = !1 : s.has(D) ? (s.delete(D), ee = !0) : A && A.state !== "idle" && A.data === void 0 ? ee = a : ee = Ui(K, {
      currentUrl: _,
      currentParams: t.matches[t.matches.length - 1].params,
      nextUrl: v,
      nextParams: r[r.length - 1].params,
      ...n,
      actionResult: b,
      actionStatus: S,
      defaultShouldRevalidate: x ? !1 : a
    }), ee && g.push({
      key: D,
      routeId: C.routeId,
      path: C.path,
      matches: T,
      match: K,
      controller: new AbortController()
    });
  }), [I, g];
}
function to(e, t, r) {
  if (e.lazy)
    return !0;
  if (!e.loader)
    return !1;
  let n = t != null && t[e.id] !== void 0, o = r != null && r[e.id] !== void 0;
  return !n && o ? !1 : typeof e.loader == "function" && e.loader.hydrate === !0 ? !0 : !n && !o;
}
function Mp(e, t, r) {
  let n = (
    // [a] -> [a, b]
    !t || // [a, b] -> [a, c]
    r.route.id !== t.route.id
  ), o = !e.hasOwnProperty(r.route.id);
  return n || o;
}
function Ip(e, t) {
  let r = e.route.path;
  return (
    // param change for this match, /users/123 -> /users/456
    e.pathname !== t.pathname || // splat param changed, which is not present in match.path
    // e.g. /files/images/avatar.jpg -> files/finances.xls
    r != null && r.endsWith("*") && e.params["*"] !== t.params["*"]
  );
}
function Ui(e, t) {
  if (e.route.shouldRevalidate) {
    let r = e.route.shouldRevalidate(t);
    if (typeof r == "boolean")
      return r;
  }
  return t.defaultShouldRevalidate;
}
function Hi(e, t, r, n, o) {
  let i;
  if (e) {
    let l = n[e];
    U(
      l,
      `No route found to patch children into: routeId = ${e}`
    ), l.children || (l.children = []), i = l.children;
  } else
    i = r;
  let a = t.filter(
    (l) => !i.some(
      (u) => ks(l, u)
    )
  ), s = Vr(
    a,
    o,
    [e || "_", "patch", String((i == null ? void 0 : i.length) || "0")],
    n
  );
  i.push(...s);
}
function ks(e, t) {
  return "id" in e && "id" in t && e.id === t.id ? !0 : e.index === t.index && e.path === t.path && e.caseSensitive === t.caseSensitive ? (!e.children || e.children.length === 0) && (!t.children || t.children.length === 0) ? !0 : e.children.every(
    (r, n) => {
      var o;
      return (o = t.children) == null ? void 0 : o.some((i) => ks(r, i));
    }
  ) : !1;
}
async function Lp(e, t, r) {
  if (!e.lazy)
    return;
  let n = await e.lazy();
  if (!e.lazy)
    return;
  let o = r[e.id];
  U(o, "No route found in manifest");
  let i = {};
  for (let a in n) {
    let l = o[a] !== void 0 && // This property isn't static since it should always be updated based
    // on the route updates
    a !== "hasErrorBoundary";
    le(
      !l,
      `Route "${o.id}" has a static property "${a}" defined but its lazy function is also returning a value for this property. The lazy route property "${a}" will be ignored.`
    ), !l && !rp.has(a) && (i[a] = n[a]);
  }
  Object.assign(o, i), Object.assign(o, {
    // To keep things framework agnostic, we use the provided `mapRouteProperties`
    // function to set the framework-aware properties (`element`/`hasErrorBoundary`)
    // since the logic will differ between frameworks.
    ...t(o),
    lazy: void 0
  });
}
async function qi(e) {
  let t = e.matches.filter((o) => o.shouldLoad), r = {};
  return (await Promise.all(t.map((o) => o.resolve()))).forEach((o, i) => {
    r[t[i].route.id] = o;
  }), r;
}
async function kp(e) {
  return e.matches.some((t) => t.route.unstable_middleware) ? Np(
    e,
    !1,
    () => qi(e),
    (t) => ({ [t.routeId]: { type: "error", result: t.error } })
  ) : qi(e);
}
async function Np(e, t, r, n) {
  let { matches: o, request: i, params: a, context: s } = e, l = {
    handlerResult: void 0,
    propagateResult: t
  };
  try {
    let u = o.flatMap(
      (f) => f.route.unstable_middleware ? f.route.unstable_middleware.map((m) => [f.route.id, m]) : []
    ), c = await Ns(
      { request: i, params: a, context: s },
      u,
      l,
      r
    );
    return l.propagateResult ? c : l.handlerResult;
  } catch (u) {
    if (!(u instanceof ro))
      throw u;
    let c = await n(u);
    return t || !l.handlerResult ? c : Object.assign(l.handlerResult, c);
  }
}
var ro = class {
  constructor(e, t) {
    this.routeId = e, this.error = t;
  }
};
async function Ns(e, t, r, n, o = 0) {
  let { request: i } = e;
  if (i.signal.aborted)
    throw i.signal.reason ? i.signal.reason : new Error(
      `Request aborted without an \`AbortSignal.reason\`: ${i.method} ${i.url}`
    );
  let a = t[o];
  if (!a)
    return r.handlerResult = await n(), r.handlerResult;
  let [s, l] = a, u = !1, c, f = async () => {
    if (u)
      throw new Error("You may only call `next()` once per middleware");
    u = !0;
    let m = await Ns(
      e,
      t,
      r,
      n,
      o + 1
    );
    if (r.propagateResult)
      return c = m, c;
  };
  try {
    let m = await l(
      {
        request: e.request,
        params: e.params,
        context: e.context
      },
      f
    );
    return u ? m === void 0 ? c : m : f();
  } catch (m) {
    throw m instanceof ro ? m : new ro(s, m);
  }
}
async function $p(e, t, r, n, o, i, a, s, l, u) {
  let c = o.map(
    (p) => p.route.lazy ? Lp(p.route, s, a) : void 0
  );
  u && await Promise.all(c);
  let f = o.map((p, b) => {
    let _ = c[b], v = n.some((S) => S.route.id === p.route.id);
    return {
      ...p,
      shouldLoad: v,
      resolve: async (S) => (S && r.method === "GET" && (p.route.lazy || p.route.loader) && (v = !0), v ? Fp(
        t,
        r,
        p,
        _,
        S,
        l
      ) : Promise.resolve({ type: "data", result: void 0 }))
    };
  }), m = await e({
    matches: f,
    request: r,
    params: o[0].params,
    fetcherKey: i,
    context: l
  });
  try {
    await Promise.all(c);
  } catch {
  }
  return m;
}
async function Fp(e, t, r, n, o, i) {
  let a, s, l = (u) => {
    let c, f = new Promise((b, _) => c = _);
    s = () => c(), t.signal.addEventListener("abort", s);
    let m = (b) => typeof u != "function" ? Promise.reject(
      new Error(
        `You cannot call the handler for a route which defines a boolean "${e}" [routeId: ${r.route.id}]`
      )
    ) : u(
      {
        request: t,
        params: r.params,
        context: i
      },
      ...b !== void 0 ? [b] : []
    ), p = (async () => {
      try {
        return { type: "data", result: await (o ? o((_) => m(_)) : m()) };
      } catch (b) {
        return { type: "error", result: b };
      }
    })();
    return Promise.race([p, f]);
  };
  try {
    let u = r.route[e];
    if (n)
      if (u) {
        let c, [f] = await Promise.all([
          // If the handler throws, don't let it immediately bubble out,
          // since we need to let the lazy() execution finish so we know if this
          // route has a boundary that can handle the error
          l(u).catch((m) => {
            c = m;
          }),
          n
        ]);
        if (c !== void 0)
          throw c;
        a = f;
      } else if (await n, u = r.route[e], u)
        a = await l(u);
      else if (e === "action") {
        let c = new URL(t.url), f = c.pathname + c.search;
        throw Ce(405, {
          method: t.method,
          pathname: f,
          routeId: r.route.id
        });
      } else
        return { type: "data", result: void 0 };
    else if (u)
      a = await l(u);
    else {
      let c = new URL(t.url), f = c.pathname + c.search;
      throw Ce(404, {
        pathname: f
      });
    }
  } catch (u) {
    return { type: "error", result: u };
  } finally {
    s && t.signal.removeEventListener("abort", s);
  }
  return a;
}
async function Ap(e) {
  var n, o, i, a, s, l;
  let { result: t, type: r } = e;
  if (Fs(t)) {
    let u;
    try {
      let c = t.headers.get("Content-Type");
      c && /\bapplication\/json\b/.test(c) ? t.body == null ? u = null : u = await t.json() : u = await t.text();
    } catch (c) {
      return { type: "error", error: c };
    }
    return r === "error" ? {
      type: "error",
      error: new Yr(t.status, t.statusText, u),
      statusCode: t.status,
      headers: t.headers
    } : {
      type: "data",
      data: u,
      statusCode: t.status,
      headers: t.headers
    };
  }
  return r === "error" ? Yi(t) ? t.data instanceof Error ? {
    type: "error",
    error: t.data,
    statusCode: (n = t.init) == null ? void 0 : n.status,
    headers: (o = t.init) != null && o.headers ? new Headers(t.init.headers) : void 0
  } : {
    type: "error",
    error: new Yr(
      ((i = t.init) == null ? void 0 : i.status) || 500,
      void 0,
      t.data
    ),
    statusCode: dr(t) ? t.status : void 0,
    headers: (a = t.init) != null && a.headers ? new Headers(t.init.headers) : void 0
  } : {
    type: "error",
    error: t,
    statusCode: dr(t) ? t.status : void 0
  } : Yi(t) ? {
    type: "data",
    data: t.data,
    statusCode: (s = t.init) == null ? void 0 : s.status,
    headers: (l = t.init) != null && l.headers ? new Headers(t.init.headers) : void 0
  } : { type: "data", data: t };
}
function jp(e, t, r, n, o) {
  let i = e.headers.get("Location");
  if (U(
    i,
    "Redirects returned/thrown from loaders/actions must have a Location header"
  ), !Io.test(i)) {
    let a = n.slice(
      0,
      n.findIndex((s) => s.route.id === r) + 1
    );
    i = eo(
      new URL(t.url),
      a,
      o,
      i
    ), e.headers.set("Location", i);
  }
  return e;
}
function zi(e, t, r) {
  if (Io.test(e)) {
    let n = e, o = n.startsWith("//") ? new URL(t.protocol + n) : new URL(n), i = Pe(o.pathname, r) != null;
    if (o.origin === t.origin && i)
      return o.pathname + o.search + o.hash;
  }
  return e;
}
function Ft(e, t, r, n) {
  let o = e.createURL($s(t)).toString(), i = { signal: r };
  if (n && De(n.formMethod)) {
    let { formMethod: a, formEncType: s } = n;
    i.method = a.toUpperCase(), s === "application/json" ? (i.headers = new Headers({ "Content-Type": s }), i.body = JSON.stringify(n.json)) : s === "text/plain" ? i.body = n.text : s === "application/x-www-form-urlencoded" && n.formData ? i.body = no(n.formData) : i.body = n.formData;
  }
  return new Request(o, i);
}
function no(e) {
  let t = new URLSearchParams();
  for (let [r, n] of e.entries())
    t.append(r, typeof n == "string" ? n : n.name);
  return t;
}
function Bi(e) {
  let t = new FormData();
  for (let [r, n] of e.entries())
    t.append(r, n);
  return t;
}
function Up(e, t, r, n = !1, o = !1) {
  let i = {}, a = null, s, l = !1, u = {}, c = r && Ee(r[1]) ? r[1].error : void 0;
  return e.forEach((f) => {
    if (!(f.route.id in t))
      return;
    let m = f.route.id, p = t[m];
    if (U(
      !St(p),
      "Cannot handle redirect results in processLoaderData"
    ), Ee(p)) {
      let b = p.error;
      if (c !== void 0 && (b = c, c = void 0), a = a || {}, o)
        a[m] = b;
      else {
        let _ = wt(e, m);
        a[_.route.id] == null && (a[_.route.id] = b);
      }
      n || (i[m] = Ls), l || (l = !0, s = dr(p.error) ? p.error.status : 500), p.headers && (u[m] = p.headers);
    } else
      i[m] = p.data, p.statusCode && p.statusCode !== 200 && !l && (s = p.statusCode), p.headers && (u[m] = p.headers);
  }), c !== void 0 && r && (a = { [r[0]]: c }, i[r[0]] = void 0), {
    loaderData: i,
    errors: a,
    statusCode: s || 200,
    loaderHeaders: u
  };
}
function Gi(e, t, r, n, o, i) {
  let { loaderData: a, errors: s } = Up(
    t,
    r,
    n
  );
  return o.forEach((l) => {
    let { key: u, match: c, controller: f } = l, m = i[u];
    if (U(m, "Did not find corresponding fetcher result"), !(f && f.signal.aborted))
      if (Ee(m)) {
        let p = wt(e.matches, c == null ? void 0 : c.route.id);
        s && s[p.route.id] || (s = {
          ...s,
          [p.route.id]: m.error
        }), e.fetchers.delete(u);
      } else if (St(m))
        U(!1, "Unhandled fetcher revalidation redirect");
      else {
        let p = ot(m.data);
        e.fetchers.set(u, p);
      }
  }), { loaderData: a, errors: s };
}
function Wi(e, t, r, n) {
  let o = Object.entries(t).filter(([, i]) => i !== Ls).reduce((i, [a, s]) => (i[a] = s, i), {});
  for (let i of r) {
    let a = i.route.id;
    if (!t.hasOwnProperty(a) && e.hasOwnProperty(a) && i.route.loader && (o[a] = e[a]), n && n.hasOwnProperty(a))
      break;
  }
  return o;
}
function Vi(e) {
  return e ? Ee(e[1]) ? {
    // Clear out prior actionData on errors
    actionData: {}
  } : {
    actionData: {
      [e[0]]: e[1].data
    }
  } : {};
}
function wt(e, t) {
  return (t ? e.slice(0, e.findIndex((n) => n.route.id === t) + 1) : [...e]).reverse().find((n) => n.route.hasErrorBoundary === !0) || e[0];
}
function Ki(e) {
  let t = e.length === 1 ? e[0] : e.find((r) => r.index || !r.path || r.path === "/") || {
    id: "__shim-error-route__"
  };
  return {
    matches: [
      {
        params: {},
        pathname: "",
        pathnameBase: "",
        route: t
      }
    ],
    route: t
  };
}
function Ce(e, {
  pathname: t,
  routeId: r,
  method: n,
  type: o,
  message: i
} = {}) {
  let a = "Unknown Server Error", s = "Unknown @remix-run/router error";
  return e === 400 ? (a = "Bad Request", n && t && r ? s = `You made a ${n} request to "${t}" but did not provide a \`loader\` for route "${r}", so there is no way to handle the request.` : o === "invalid-body" && (s = "Unable to encode submission body")) : e === 403 ? (a = "Forbidden", s = `Route "${r}" does not match URL "${t}"`) : e === 404 ? (a = "Not Found", s = `No route matches URL "${t}"`) : e === 405 && (a = "Method Not Allowed", n && t && r ? s = `You made a ${n.toUpperCase()} request to "${t}" but did not provide an \`action\` for route "${r}", so there is no way to handle the request.` : n && (s = `Invalid request method "${n.toUpperCase()}"`)), new Yr(
    e || 500,
    a,
    new Error(s),
    !0
  );
}
function Lr(e) {
  let t = Object.entries(e);
  for (let r = t.length - 1; r >= 0; r--) {
    let [n, o] = t[r];
    if (St(o))
      return { key: n, result: o };
  }
}
function $s(e) {
  let t = typeof e == "string" ? Ae(e) : e;
  return dt({ ...t, hash: "" });
}
function Hp(e, t) {
  return e.pathname !== t.pathname || e.search !== t.search ? !1 : e.hash === "" ? t.hash !== "" : e.hash === t.hash ? !0 : t.hash !== "";
}
function qp(e) {
  return Fs(e.result) && Rp.has(e.result.status);
}
function Ee(e) {
  return e.type === "error";
}
function St(e) {
  return (e && e.type) === "redirect";
}
function Yi(e) {
  return typeof e == "object" && e != null && "type" in e && "data" in e && "init" in e && e.type === "DataWithResponseInit";
}
function Fs(e) {
  return e != null && typeof e.status == "number" && typeof e.statusText == "string" && typeof e.headers == "object" && typeof e.body < "u";
}
function zp(e) {
  return Sp.has(e.toUpperCase());
}
function De(e) {
  return Ep.has(e.toUpperCase());
}
function Lo(e) {
  return new URLSearchParams(e).getAll("index").some((t) => t === "");
}
function sr(e, t) {
  let r = typeof t == "string" ? Ae(t).search : t.search;
  if (e[e.length - 1].route.index && Lo(r || ""))
    return e[e.length - 1];
  let n = Os(e);
  return n[n.length - 1];
}
function Qi(e) {
  let { formMethod: t, formAction: r, formEncType: n, text: o, formData: i, json: a } = e;
  if (!(!t || !r || !n)) {
    if (o != null)
      return {
        formMethod: t,
        formAction: r,
        formEncType: n,
        formData: void 0,
        json: void 0,
        text: o
      };
    if (i != null)
      return {
        formMethod: t,
        formAction: r,
        formEncType: n,
        formData: i,
        json: void 0,
        text: void 0
      };
    if (a !== void 0)
      return {
        formMethod: t,
        formAction: r,
        formEncType: n,
        formData: void 0,
        json: a,
        text: void 0
      };
  }
}
function In(e, t) {
  return t ? {
    state: "loading",
    location: e,
    formMethod: t.formMethod,
    formAction: t.formAction,
    formEncType: t.formEncType,
    formData: t.formData,
    json: t.json,
    text: t.text
  } : {
    state: "loading",
    location: e,
    formMethod: void 0,
    formAction: void 0,
    formEncType: void 0,
    formData: void 0,
    json: void 0,
    text: void 0
  };
}
function Bp(e, t) {
  return {
    state: "submitting",
    location: e,
    formMethod: t.formMethod,
    formAction: t.formAction,
    formEncType: t.formEncType,
    formData: t.formData,
    json: t.json,
    text: t.text
  };
}
function nr(e, t) {
  return e ? {
    state: "loading",
    formMethod: e.formMethod,
    formAction: e.formAction,
    formEncType: e.formEncType,
    formData: e.formData,
    json: e.json,
    text: e.text,
    data: t
  } : {
    state: "loading",
    formMethod: void 0,
    formAction: void 0,
    formEncType: void 0,
    formData: void 0,
    json: void 0,
    text: void 0,
    data: t
  };
}
function Gp(e, t) {
  return {
    state: "submitting",
    formMethod: e.formMethod,
    formAction: e.formAction,
    formEncType: e.formEncType,
    formData: e.formData,
    json: e.json,
    text: e.text,
    data: t ? t.data : void 0
  };
}
function ot(e) {
  return {
    state: "idle",
    formMethod: void 0,
    formAction: void 0,
    formEncType: void 0,
    formData: void 0,
    json: void 0,
    text: void 0,
    data: e
  };
}
function Wp(e, t) {
  try {
    let r = e.sessionStorage.getItem(
      Is
    );
    if (r) {
      let n = JSON.parse(r);
      for (let [o, i] of Object.entries(n || {}))
        i && Array.isArray(i) && t.set(o, new Set(i || []));
    }
  } catch {
  }
}
function Vp(e, t) {
  if (t.size > 0) {
    let r = {};
    for (let [n, o] of t)
      r[n] = [...o];
    try {
      e.sessionStorage.setItem(
        Is,
        JSON.stringify(r)
      );
    } catch (n) {
      le(
        !1,
        `Failed to save applied view transitions in sessionStorage (${n}).`
      );
    }
  }
}
function Kp() {
  let e, t, r = new Promise((n, o) => {
    e = async (i) => {
      n(i);
      try {
        await r;
      } catch {
      }
    }, t = async (i) => {
      o(i);
      try {
        await r;
      } catch {
      }
    };
  });
  return {
    promise: r,
    //@ts-ignore
    resolve: e,
    //@ts-ignore
    reject: t
  };
}
var Lt = pe(null);
Lt.displayName = "DataRouter";
var mr = pe(null);
mr.displayName = "DataRouterState";
var ko = pe({
  isTransitioning: !1
});
ko.displayName = "ViewTransition";
var As = pe(
  /* @__PURE__ */ new Map()
);
As.displayName = "Fetchers";
var Yp = pe(null);
Yp.displayName = "Await";
var je = pe(
  null
);
je.displayName = "Navigation";
var Kt = pe(
  null
);
Kt.displayName = "Location";
var Ue = pe({
  outlet: null,
  matches: [],
  isDataRoute: !1
});
Ue.displayName = "Route";
var No = pe(null);
No.displayName = "RouteError";
function Qp(e, { relative: t } = {}) {
  U(
    gr(),
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    "useHref() may be used only in the context of a <Router> component."
  );
  let { basename: r, navigator: n } = H(je), { hash: o, pathname: i, search: a } = yr(e, { relative: t }), s = i;
  return r !== "/" && (s = i === "/" ? r : Fe([r, i])), n.createHref({ pathname: s, search: a, hash: o });
}
function gr() {
  return H(Kt) != null;
}
function pt() {
  return U(
    gr(),
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    "useLocation() may be used only in the context of a <Router> component."
  ), H(Kt).location;
}
function Xp() {
  return H(Kt).navigationType;
}
var js = "You should call navigate() in a React.useEffect(), not when your component is first rendered.";
function Us(e) {
  H(je).static || ao(e);
}
function Jp() {
  let { isDataRoute: e } = H(Ue);
  return e ? hm() : Zp();
}
function Zp() {
  U(
    gr(),
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    "useNavigate() may be used only in the context of a <Router> component."
  );
  let e = H(Lt), { basename: t, navigator: r } = H(je), { matches: n } = H(Ue), { pathname: o } = pt(), i = JSON.stringify(Oo(n)), a = zt(!1);
  return Us(() => {
    a.current = !0;
  }), ae(
    (l, u = {}) => {
      if (le(a.current, js), !a.current)
        return;
      if (typeof l == "number") {
        r.go(l);
        return;
      }
      let c = Mo(
        l,
        JSON.parse(i),
        o,
        u.relative === "path"
      );
      e == null && t !== "/" && (c.pathname = c.pathname === "/" ? t : Fe([t, c.pathname])), (u.replace ? r.replace : r.push)(
        c,
        u.state,
        u
      );
    },
    [
      t,
      r,
      i,
      o,
      e
    ]
  );
}
var em = pe(null);
function tm(e) {
  let t = H(Ue).outlet;
  return t && /* @__PURE__ */ O(em.Provider, { value: e }, t);
}
function yr(e, { relative: t } = {}) {
  let { matches: r } = H(Ue), { pathname: n } = pt(), o = JSON.stringify(Oo(r));
  return _e(
    () => Mo(
      e,
      JSON.parse(o),
      n,
      t === "path"
    ),
    [e, o, n, t]
  );
}
function rm(e, t, r, n) {
  var S;
  U(
    gr(),
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    "useRoutes() may be used only in the context of a <Router> component."
  );
  let { navigator: o, static: i } = H(je), { matches: a } = H(Ue), s = a[a.length - 1], l = s ? s.params : {}, u = s ? s.pathname : "/", c = s ? s.pathnameBase : "/", f = s && s.route;
  {
    let x = f && f.path || "";
    Hs(
      u,
      !f || x.endsWith("*") || x.endsWith("*?"),
      `You rendered descendant <Routes> (or called \`useRoutes()\`) at "${u}" (under <Route path="${x}">) but the parent route path has no trailing "*". This means if you navigate deeper, the parent won't match anymore and therefore the child routes will never render.

Please change the parent <Route path="${x}"> to <Route path="${x === "/" ? "*" : `${x}/*`}">.`
    );
  }
  let m = pt(), p;
  if (t) {
    let x = typeof t == "string" ? Ae(t) : t;
    U(
      c === "/" || ((S = x.pathname) == null ? void 0 : S.startsWith(c)),
      `When overriding the location using \`<Routes location>\` or \`useRoutes(routes, location)\`, the location pathname must begin with the portion of the URL pathname that was matched by all parent routes. The current pathname base is "${c}" but pathname "${x.pathname}" was given in the \`location\` prop.`
    ), p = x;
  } else
    p = m;
  let b = p.pathname || "/", _ = b;
  if (c !== "/") {
    let x = c.replace(/^\//, "").split("/");
    _ = "/" + b.replace(/^\//, "").split("/").slice(x.length).join("/");
  }
  let v = !i && r && r.matches && r.matches.length > 0 ? r.matches : ut(e, { pathname: _ });
  le(
    f || v != null,
    `No routes matched location "${p.pathname}${p.search}${p.hash}" `
  ), le(
    v == null || v[v.length - 1].route.element !== void 0 || v[v.length - 1].route.Component !== void 0 || v[v.length - 1].route.lazy !== void 0,
    `Matched leaf route at location "${p.pathname}${p.search}${p.hash}" does not have an element or Component. This means it will render an <Outlet /> with a null value by default resulting in an "empty" page.`
  );
  let w = sm(
    v && v.map(
      (x) => Object.assign({}, x, {
        params: Object.assign({}, l, x.params),
        pathname: Fe([
          c,
          // Re-encode pathnames that were decoded inside matchRoutes
          o.encodeLocation ? o.encodeLocation(x.pathname).pathname : x.pathname
        ]),
        pathnameBase: x.pathnameBase === "/" ? c : Fe([
          c,
          // Re-encode pathnames that were decoded inside matchRoutes
          o.encodeLocation ? o.encodeLocation(x.pathnameBase).pathname : x.pathnameBase
        ])
      })
    ),
    a,
    r,
    n
  );
  return t && w ? /* @__PURE__ */ O(
    Kt.Provider,
    {
      value: {
        location: {
          pathname: "/",
          search: "",
          hash: "",
          state: null,
          key: "default",
          ...p
        },
        navigationType: "POP"
        /* Pop */
      }
    },
    w
  ) : w;
}
function nm() {
  let e = fm(), t = dr(e) ? `${e.status} ${e.statusText}` : e instanceof Error ? e.message : JSON.stringify(e), r = e instanceof Error ? e.stack : null, n = "rgba(200,200,200, 0.5)", o = { padding: "0.5rem", backgroundColor: n }, i = { padding: "2px 4px", backgroundColor: n }, a = null;
  return console.error(
    "Error handled by React Router default ErrorBoundary:",
    e
  ), a = /* @__PURE__ */ O(Ct, null, /* @__PURE__ */ O("p", null, "💿 Hey developer 👋"), /* @__PURE__ */ O("p", null, "You can provide a way better UX than this when your app throws errors by providing your own ", /* @__PURE__ */ O("code", { style: i }, "ErrorBoundary"), " or", " ", /* @__PURE__ */ O("code", { style: i }, "errorElement"), " prop on your route.")), /* @__PURE__ */ O(Ct, null, /* @__PURE__ */ O("h2", null, "Unexpected Application Error!"), /* @__PURE__ */ O("h3", { style: { fontStyle: "italic" } }, t), r ? /* @__PURE__ */ O("pre", { style: o }, r) : null, a);
}
var om = /* @__PURE__ */ O(nm, null), im = class extends oo {
  constructor(e) {
    super(e), this.state = {
      location: e.location,
      revalidation: e.revalidation,
      error: e.error
    };
  }
  static getDerivedStateFromError(e) {
    return { error: e };
  }
  static getDerivedStateFromProps(e, t) {
    return t.location !== e.location || t.revalidation !== "idle" && e.revalidation === "idle" ? {
      error: e.error,
      location: e.location,
      revalidation: e.revalidation
    } : {
      error: e.error !== void 0 ? e.error : t.error,
      location: t.location,
      revalidation: e.revalidation || t.revalidation
    };
  }
  componentDidCatch(e, t) {
    console.error(
      "React Router caught the following error during render",
      e,
      t
    );
  }
  render() {
    return this.state.error !== void 0 ? /* @__PURE__ */ O(Ue.Provider, { value: this.props.routeContext }, /* @__PURE__ */ O(
      No.Provider,
      {
        value: this.state.error,
        children: this.props.component
      }
    )) : this.props.children;
  }
};
function am({ routeContext: e, match: t, children: r }) {
  let n = H(Lt);
  return n && n.static && n.staticContext && (t.route.errorElement || t.route.ErrorBoundary) && (n.staticContext._deepestRenderedBoundaryId = t.route.id), /* @__PURE__ */ O(Ue.Provider, { value: e }, r);
}
function sm(e, t = [], r = null, n = null) {
  if (e == null) {
    if (!r)
      return null;
    if (r.errors)
      e = r.matches;
    else if (t.length === 0 && !r.initialized && r.matches.length > 0)
      e = r.matches;
    else
      return null;
  }
  let o = e, i = r == null ? void 0 : r.errors;
  if (i != null) {
    let l = o.findIndex(
      (u) => u.route.id && (i == null ? void 0 : i[u.route.id]) !== void 0
    );
    U(
      l >= 0,
      `Could not find a matching route for errors on route IDs: ${Object.keys(
        i
      ).join(",")}`
    ), o = o.slice(
      0,
      Math.min(o.length, l + 1)
    );
  }
  let a = !1, s = -1;
  if (r)
    for (let l = 0; l < o.length; l++) {
      let u = o[l];
      if ((u.route.HydrateFallback || u.route.hydrateFallbackElement) && (s = l), u.route.id) {
        let { loaderData: c, errors: f } = r, m = u.route.loader && !c.hasOwnProperty(u.route.id) && (!f || f[u.route.id] === void 0);
        if (u.route.lazy || m) {
          a = !0, s >= 0 ? o = o.slice(0, s + 1) : o = [o[0]];
          break;
        }
      }
    }
  return o.reduceRight((l, u, c) => {
    let f, m = !1, p = null, b = null;
    r && (f = i && u.route.id ? i[u.route.id] : void 0, p = u.route.errorElement || om, a && (s < 0 && c === 0 ? (Hs(
      "route-fallback",
      !1,
      "No `HydrateFallback` element provided to render during initial hydration"
    ), m = !0, b = null) : s === c && (m = !0, b = u.route.hydrateFallbackElement || null)));
    let _ = t.concat(o.slice(0, c + 1)), v = () => {
      let w;
      return f ? w = p : m ? w = b : u.route.Component ? w = /* @__PURE__ */ O(u.route.Component, null) : u.route.element ? w = u.route.element : w = l, /* @__PURE__ */ O(
        am,
        {
          match: u,
          routeContext: {
            outlet: l,
            matches: _,
            isDataRoute: r != null
          },
          children: w
        }
      );
    };
    return r && (u.route.ErrorBoundary || u.route.errorElement || c === 0) ? /* @__PURE__ */ O(
      im,
      {
        location: r.location,
        revalidation: r.revalidation,
        component: p,
        error: f,
        children: v(),
        routeContext: { outlet: null, matches: _, isDataRoute: !0 }
      }
    ) : v();
  }, null);
}
function $o(e) {
  return `${e} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`;
}
function lm(e) {
  let t = H(Lt);
  return U(t, $o(e)), t;
}
function um(e) {
  let t = H(mr);
  return U(t, $o(e)), t;
}
function cm(e) {
  let t = H(Ue);
  return U(t, $o(e)), t;
}
function Fo(e) {
  let t = cm(e), r = t.matches[t.matches.length - 1];
  return U(
    r.route.id,
    `${e} can only be used on routes that contain a unique "id"`
  ), r.route.id;
}
function dm() {
  return Fo(
    "useRouteId"
    /* UseRouteId */
  );
}
function fm() {
  var n;
  let e = H(No), t = um(
    "useRouteError"
    /* UseRouteError */
  ), r = Fo(
    "useRouteError"
    /* UseRouteError */
  );
  return e !== void 0 ? e : (n = t.errors) == null ? void 0 : n[r];
}
function hm() {
  let { router: e } = lm(
    "useNavigate"
    /* UseNavigateStable */
  ), t = Fo(
    "useNavigate"
    /* UseNavigateStable */
  ), r = zt(!1);
  return Us(() => {
    r.current = !0;
  }), ae(
    async (o, i = {}) => {
      le(r.current, js), r.current && (typeof o == "number" ? e.navigate(o) : await e.navigate(o, { fromRouteId: t, ...i }));
    },
    [e, t]
  );
}
var Xi = {};
function Hs(e, t, r) {
  !t && !Xi[e] && (Xi[e] = !0, le(!1, r));
}
var Ji = {};
function Zi(e, t) {
  !e && !Ji[t] && (Ji[t] = !0, console.warn(t));
}
function pm(e) {
  let t = {
    // Note: this check also occurs in createRoutesFromChildren so update
    // there if you change this -- please and thank you!
    hasErrorBoundary: e.hasErrorBoundary || e.ErrorBoundary != null || e.errorElement != null
  };
  return e.Component && (e.element && le(
    !1,
    "You should not include both `Component` and `element` on your route - `Component` will be used."
  ), Object.assign(t, {
    element: O(e.Component),
    Component: void 0
  })), e.HydrateFallback && (e.hydrateFallbackElement && le(
    !1,
    "You should not include both `HydrateFallback` and `hydrateFallbackElement` on your route - `HydrateFallback` will be used."
  ), Object.assign(t, {
    hydrateFallbackElement: O(e.HydrateFallback),
    HydrateFallback: void 0
  })), e.ErrorBoundary && (e.errorElement && le(
    !1,
    "You should not include both `ErrorBoundary` and `errorElement` on your route - `ErrorBoundary` will be used."
  ), Object.assign(t, {
    errorElement: O(e.ErrorBoundary),
    ErrorBoundary: void 0
  })), t;
}
var mm = class {
  constructor() {
    this.status = "pending", this.promise = new Promise((e, t) => {
      this.resolve = (r) => {
        this.status === "pending" && (this.status = "resolved", e(r));
      }, this.reject = (r) => {
        this.status === "pending" && (this.status = "rejected", t(r));
      };
    });
  }
};
function gm({
  router: e,
  flushSync: t
}) {
  let [r, n] = be(e.state), [o, i] = be(), [a, s] = be({
    isTransitioning: !1
  }), [l, u] = be(), [c, f] = be(), [m, p] = be(), b = zt(/* @__PURE__ */ new Map()), _ = ae(
    (x, { deletedFetchers: I, flushSync: g, viewTransitionOpts: C }) => {
      x.fetchers.forEach((T, A) => {
        T.data !== void 0 && b.current.set(A, T.data);
      }), I.forEach((T) => b.current.delete(T)), Zi(
        g === !1 || t != null,
        'You provided the `flushSync` option to a router update, but you are not using the `<RouterProvider>` from `react-router/dom` so `ReactDOM.flushSync()` is unavailable.  Please update your app to `import { RouterProvider } from "react-router/dom"` and ensure you have `react-dom` installed as a dependency to use the `flushSync` option.'
      );
      let D = e.window != null && e.window.document != null && typeof e.window.document.startViewTransition == "function";
      if (Zi(
        C == null || D,
        "You provided the `viewTransition` option to a router update, but you do not appear to be running in a DOM environment as `window.startViewTransition` is not available."
      ), !C || !D) {
        t && g ? t(() => n(x)) : kn(() => n(x));
        return;
      }
      if (t && g) {
        t(() => {
          c && (l && l.resolve(), c.skipTransition()), s({
            isTransitioning: !0,
            flushSync: !0,
            currentLocation: C.currentLocation,
            nextLocation: C.nextLocation
          });
        });
        let T = e.window.document.startViewTransition(() => {
          t(() => n(x));
        });
        T.finished.finally(() => {
          t(() => {
            u(void 0), f(void 0), i(void 0), s({ isTransitioning: !1 });
          });
        }), t(() => f(T));
        return;
      }
      c ? (l && l.resolve(), c.skipTransition(), p({
        state: x,
        currentLocation: C.currentLocation,
        nextLocation: C.nextLocation
      })) : (i(x), s({
        isTransitioning: !0,
        flushSync: !1,
        currentLocation: C.currentLocation,
        nextLocation: C.nextLocation
      }));
    },
    [e.window, t, c, l]
  );
  ao(() => e.subscribe(_), [e, _]), se(() => {
    a.isTransitioning && !a.flushSync && u(new mm());
  }, [a]), se(() => {
    if (l && o && e.window) {
      let x = o, I = l.promise, g = e.window.document.startViewTransition(async () => {
        kn(() => n(x)), await I;
      });
      g.finished.finally(() => {
        u(void 0), f(void 0), i(void 0), s({ isTransitioning: !1 });
      }), f(g);
    }
  }, [o, l, e.window]), se(() => {
    l && o && r.location.key === o.location.key && l.resolve();
  }, [l, c, r.location, o]), se(() => {
    !a.isTransitioning && m && (i(m.state), s({
      isTransitioning: !0,
      flushSync: !1,
      currentLocation: m.currentLocation,
      nextLocation: m.nextLocation
    }), p(void 0));
  }, [a.isTransitioning, m]);
  let v = _e(() => ({
    createHref: e.createHref,
    encodeLocation: e.encodeLocation,
    go: (x) => e.navigate(x),
    push: (x, I, g) => e.navigate(x, {
      state: I,
      preventScrollReset: g == null ? void 0 : g.preventScrollReset
    }),
    replace: (x, I, g) => e.navigate(x, {
      replace: !0,
      state: I,
      preventScrollReset: g == null ? void 0 : g.preventScrollReset
    })
  }), [e]), w = e.basename || "/", S = _e(
    () => ({
      router: e,
      navigator: v,
      static: !1,
      basename: w
    }),
    [e, v, w]
  );
  return /* @__PURE__ */ O(Ct, null, /* @__PURE__ */ O(Lt.Provider, { value: S }, /* @__PURE__ */ O(mr.Provider, { value: r }, /* @__PURE__ */ O(As.Provider, { value: b.current }, /* @__PURE__ */ O(ko.Provider, { value: a }, /* @__PURE__ */ O(
    wm,
    {
      basename: w,
      location: r.location,
      navigationType: r.historyAction,
      navigator: v
    },
    /* @__PURE__ */ O(
      ym,
      {
        routes: e.routes,
        future: e.future,
        state: r
      }
    )
  ))))), null);
}
var ym = io(vm);
function vm({
  routes: e,
  future: t,
  state: r
}) {
  return rm(e, void 0, r, t);
}
function bm(e) {
  return tm(e.context);
}
function wm({
  basename: e = "/",
  children: t = null,
  location: r,
  navigationType: n = "POP",
  navigator: o,
  static: i = !1
}) {
  U(
    !gr(),
    "You cannot render a <Router> inside another <Router>. You should never have more than one in your app."
  );
  let a = e.replace(/^\/*/, "/"), s = _e(
    () => ({
      basename: a,
      navigator: o,
      static: i,
      future: {}
    }),
    [a, o, i]
  );
  typeof r == "string" && (r = Ae(r));
  let {
    pathname: l = "/",
    search: u = "",
    hash: c = "",
    state: f = null,
    key: m = "default"
  } = r, p = _e(() => {
    let b = Pe(l, a);
    return b == null ? null : {
      location: {
        pathname: b,
        search: u,
        hash: c,
        state: f,
        key: m
      },
      navigationType: n
    };
  }, [a, l, u, c, f, m, n]);
  return le(
    p != null,
    `<Router basename="${a}"> is not able to match the URL "${l}${u}${c}" because it does not start with the basename, so the <Router> won't render anything.`
  ), p == null ? null : /* @__PURE__ */ O(je.Provider, { value: s }, /* @__PURE__ */ O(Kt.Provider, { children: t, value: p }));
}
var Ar = "get", jr = "application/x-www-form-urlencoded";
function vn(e) {
  return e != null && typeof e.tagName == "string";
}
function _m(e) {
  return vn(e) && e.tagName.toLowerCase() === "button";
}
function Em(e) {
  return vn(e) && e.tagName.toLowerCase() === "form";
}
function xm(e) {
  return vn(e) && e.tagName.toLowerCase() === "input";
}
function Sm(e) {
  return !!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey);
}
function Rm(e, t) {
  return e.button === 0 && // Ignore everything but left clicks
  (!t || t === "_self") && // Let browser handle "target=_blank" etc.
  !Sm(e);
}
var kr = null;
function Cm() {
  if (kr === null)
    try {
      new FormData(
        document.createElement("form"),
        // @ts-expect-error if FormData supports the submitter parameter, this will throw
        0
      ), kr = !1;
    } catch {
      kr = !0;
    }
  return kr;
}
var Pm = /* @__PURE__ */ new Set([
  "application/x-www-form-urlencoded",
  "multipart/form-data",
  "text/plain"
]);
function Ln(e) {
  return e != null && !Pm.has(e) ? (le(
    !1,
    `"${e}" is not a valid \`encType\` for \`<Form>\`/\`<fetcher.Form>\` and will default to "${jr}"`
  ), null) : e;
}
function Tm(e, t) {
  let r, n, o, i, a;
  if (Em(e)) {
    let s = e.getAttribute("action");
    n = s ? Pe(s, t) : null, r = e.getAttribute("method") || Ar, o = Ln(e.getAttribute("enctype")) || jr, i = new FormData(e);
  } else if (_m(e) || xm(e) && (e.type === "submit" || e.type === "image")) {
    let s = e.form;
    if (s == null)
      throw new Error(
        'Cannot submit a <button> or <input type="submit"> without a <form>'
      );
    let l = e.getAttribute("formaction") || s.getAttribute("action");
    if (n = l ? Pe(l, t) : null, r = e.getAttribute("formmethod") || s.getAttribute("method") || Ar, o = Ln(e.getAttribute("formenctype")) || Ln(s.getAttribute("enctype")) || jr, i = new FormData(s, e), !Cm()) {
      let { name: u, type: c, value: f } = e;
      if (c === "image") {
        let m = u ? `${u}.` : "";
        i.append(`${m}x`, "0"), i.append(`${m}y`, "0");
      } else
        u && i.append(u, f);
    }
  } else {
    if (vn(e))
      throw new Error(
        'Cannot submit element that is not <form>, <button>, or <input type="submit|image">'
      );
    r = Ar, n = null, o = jr, a = e;
  }
  return i && o === "text/plain" && (a = i, i = void 0), { action: n, method: r.toLowerCase(), encType: o, formData: i, body: a };
}
function Ao(e, t) {
  if (e === !1 || e === null || typeof e > "u")
    throw new Error(t);
}
async function Dm(e, t) {
  if (e.id in t)
    return t[e.id];
  try {
    let r = await import(
      /* @vite-ignore */
      /* webpackIgnore: true */
      e.module
    );
    return t[e.id] = r, r;
  } catch (r) {
    return console.error(
      `Error loading route module \`${e.module}\`, reloading page...`
    ), console.error(r), window.__reactRouterContext && window.__reactRouterContext.isSpaMode, window.location.reload(), new Promise(() => {
    });
  }
}
function Om(e) {
  return e != null && typeof e.page == "string";
}
function Mm(e) {
  return e == null ? !1 : e.href == null ? e.rel === "preload" && typeof e.imageSrcSet == "string" && typeof e.imageSizes == "string" : typeof e.rel == "string" && typeof e.href == "string";
}
async function Im(e, t, r) {
  let n = await Promise.all(
    e.map(async (o) => {
      let i = t.routes[o.route.id];
      if (i) {
        let a = await Dm(i, r);
        return a.links ? a.links() : [];
      }
      return [];
    })
  );
  return $m(
    n.flat(1).filter(Mm).filter((o) => o.rel === "stylesheet" || o.rel === "preload").map(
      (o) => o.rel === "stylesheet" ? { ...o, rel: "prefetch", as: "style" } : { ...o, rel: "prefetch" }
    )
  );
}
function ea(e, t, r, n, o, i) {
  let a = (l, u) => r[u] ? l.route.id !== r[u].route.id : !0, s = (l, u) => {
    var c;
    return (
      // param change, /users/123 -> /users/456
      r[u].pathname !== l.pathname || // splat param changed, which is not present in match.path
      // e.g. /files/images/avatar.jpg -> files/finances.xls
      ((c = r[u].route.path) == null ? void 0 : c.endsWith("*")) && r[u].params["*"] !== l.params["*"]
    );
  };
  return i === "assets" ? t.filter(
    (l, u) => a(l, u) || s(l, u)
  ) : i === "data" ? t.filter((l, u) => {
    var f;
    let c = n.routes[l.route.id];
    if (!c || !c.hasLoader)
      return !1;
    if (a(l, u) || s(l, u))
      return !0;
    if (l.route.shouldRevalidate) {
      let m = l.route.shouldRevalidate({
        currentUrl: new URL(
          o.pathname + o.search + o.hash,
          window.origin
        ),
        currentParams: ((f = r[0]) == null ? void 0 : f.params) || {},
        nextUrl: new URL(e, window.origin),
        nextParams: l.params,
        defaultShouldRevalidate: !0
      });
      if (typeof m == "boolean")
        return m;
    }
    return !0;
  }) : [];
}
function Lm(e, t, { includeHydrateFallback: r } = {}) {
  return km(
    e.map((n) => {
      let o = t.routes[n.route.id];
      if (!o)
        return [];
      let i = [o.module];
      return o.clientActionModule && (i = i.concat(o.clientActionModule)), o.clientLoaderModule && (i = i.concat(o.clientLoaderModule)), r && o.hydrateFallbackModule && (i = i.concat(o.hydrateFallbackModule)), o.imports && (i = i.concat(o.imports)), i;
    }).flat(1)
  );
}
function km(e) {
  return [...new Set(e)];
}
function Nm(e) {
  let t = {}, r = Object.keys(e).sort();
  for (let n of r)
    t[n] = e[n];
  return t;
}
function $m(e, t) {
  let r = /* @__PURE__ */ new Set(), n = new Set(t);
  return e.reduce((o, i) => {
    if (t && !Om(i) && i.as === "script" && i.href && n.has(i.href))
      return o;
    let s = JSON.stringify(Nm(i));
    return r.has(s) || (r.add(s), o.push({ key: s, link: i })), o;
  }, []);
}
function Fm(e, t) {
  let r = typeof e == "string" ? new URL(
    e,
    // This can be called during the SSR flow via PrefetchPageLinksImpl so
    // don't assume window is available
    typeof window > "u" ? "server://singlefetch/" : window.location.origin
  ) : e;
  return r.pathname === "/" ? r.pathname = "_root.data" : t && Pe(r.pathname, t) === "/" ? r.pathname = `${t.replace(/\/$/, "")}/_root.data` : r.pathname = `${r.pathname.replace(/\/$/, "")}.data`, r;
}
function qs() {
  let e = H(Lt);
  return Ao(
    e,
    "You must render this element inside a <DataRouterContext.Provider> element"
  ), e;
}
function Am() {
  let e = H(mr);
  return Ao(
    e,
    "You must render this element inside a <DataRouterStateContext.Provider> element"
  ), e;
}
var jo = pe(void 0);
jo.displayName = "FrameworkContext";
function zs() {
  let e = H(jo);
  return Ao(
    e,
    "You must render this element inside a <HydratedRouter> element"
  ), e;
}
function jm(e, t) {
  let r = H(jo), [n, o] = be(!1), [i, a] = be(!1), { onFocus: s, onBlur: l, onMouseEnter: u, onMouseLeave: c, onTouchStart: f } = t, m = zt(null);
  se(() => {
    if (e === "render" && a(!0), e === "viewport") {
      let _ = (w) => {
        w.forEach((S) => {
          a(S.isIntersecting);
        });
      }, v = new IntersectionObserver(_, { threshold: 0.5 });
      return m.current && v.observe(m.current), () => {
        v.disconnect();
      };
    }
  }, [e]), se(() => {
    if (n) {
      let _ = setTimeout(() => {
        a(!0);
      }, 100);
      return () => {
        clearTimeout(_);
      };
    }
  }, [n]);
  let p = () => {
    o(!0);
  }, b = () => {
    o(!1), a(!1);
  };
  return r ? e !== "intent" ? [i, m, {}] : [
    i,
    m,
    {
      onFocus: or(s, p),
      onBlur: or(l, b),
      onMouseEnter: or(u, p),
      onMouseLeave: or(c, b),
      onTouchStart: or(f, p)
    }
  ] : [!1, m, {}];
}
function or(e, t) {
  return (r) => {
    e && e(r), r.defaultPrevented || t(r);
  };
}
function Um({
  page: e,
  ...t
}) {
  let { router: r } = qs(), n = _e(
    () => ut(r.routes, e, r.basename),
    [r.routes, e, r.basename]
  );
  return n ? /* @__PURE__ */ O(qm, { page: e, matches: n, ...t }) : null;
}
function Hm(e) {
  let { manifest: t, routeModules: r } = zs(), [n, o] = be([]);
  return se(() => {
    let i = !1;
    return Im(e, t, r).then(
      (a) => {
        i || o(a);
      }
    ), () => {
      i = !0;
    };
  }, [e, t, r]), n;
}
function qm({
  page: e,
  matches: t,
  ...r
}) {
  let n = pt(), { manifest: o, routeModules: i } = zs(), { basename: a } = qs(), { loaderData: s, matches: l } = Am(), u = _e(
    () => ea(
      e,
      t,
      l,
      o,
      n,
      "data"
    ),
    [e, t, l, o, n]
  ), c = _e(
    () => ea(
      e,
      t,
      l,
      o,
      n,
      "assets"
    ),
    [e, t, l, o, n]
  ), f = _e(() => {
    if (e === n.pathname + n.search + n.hash)
      return [];
    let b = /* @__PURE__ */ new Set(), _ = !1;
    if (t.forEach((w) => {
      var x;
      let S = o.routes[w.route.id];
      !S || !S.hasLoader || (!u.some((I) => I.route.id === w.route.id) && w.route.id in s && ((x = i[w.route.id]) != null && x.shouldRevalidate) || S.hasClientLoader ? _ = !0 : b.add(w.route.id));
    }), b.size === 0)
      return [];
    let v = Fm(e, a);
    return _ && b.size > 0 && v.searchParams.set(
      "_routes",
      t.filter((w) => b.has(w.route.id)).map((w) => w.route.id).join(",")
    ), [v.pathname + v.search];
  }, [
    a,
    s,
    n,
    o,
    u,
    t,
    e,
    i
  ]), m = _e(
    () => Lm(c, o),
    [c, o]
  ), p = Hm(c);
  return /* @__PURE__ */ O(Ct, null, f.map((b) => /* @__PURE__ */ O("link", { key: b, rel: "prefetch", as: "fetch", href: b, ...r })), m.map((b) => /* @__PURE__ */ O("link", { key: b, rel: "modulepreload", href: b, ...r })), p.map(({ key: b, link: _ }) => (
    // these don't spread `linkProps` because they are full link descriptors
    // already with their own props
    /* @__PURE__ */ O("link", { key: b, ..._ })
  )));
}
function zm(...e) {
  return (t) => {
    e.forEach((r) => {
      typeof r == "function" ? r(t) : r != null && (r.current = t);
    });
  };
}
var Bs = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u";
try {
  Bs && (window.__reactRouterVersion = "7.3.0");
} catch {
}
function Bm(e, t) {
  return Dp({
    basename: t == null ? void 0 : t.basename,
    unstable_getContext: t == null ? void 0 : t.unstable_getContext,
    future: t == null ? void 0 : t.future,
    history: Zh({ window: t == null ? void 0 : t.window }),
    hydrationData: (t == null ? void 0 : t.hydrationData) || Gm(),
    routes: e,
    mapRouteProperties: pm,
    dataStrategy: t == null ? void 0 : t.dataStrategy,
    patchRoutesOnNavigation: t == null ? void 0 : t.patchRoutesOnNavigation,
    window: t == null ? void 0 : t.window
  }).initialize();
}
function Gm() {
  let e = window == null ? void 0 : window.__staticRouterHydrationData;
  return e && e.errors && (e = {
    ...e,
    errors: Wm(e.errors)
  }), e;
}
function Wm(e) {
  if (!e)
    return null;
  let t = Object.entries(e), r = {};
  for (let [n, o] of t)
    if (o && o.__type === "RouteErrorResponse")
      r[n] = new Yr(
        o.status,
        o.statusText,
        o.data,
        o.internal === !0
      );
    else if (o && o.__type === "Error") {
      if (o.__subType) {
        let i = window[o.__subType];
        if (typeof i == "function")
          try {
            let a = new i(o.message);
            a.stack = "", r[n] = a;
          } catch {
          }
      }
      if (r[n] == null) {
        let i = new Error(o.message);
        i.stack = "", r[n] = i;
      }
    } else
      r[n] = o;
  return r;
}
var Gs = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i, Ws = Je(
  function({
    onClick: t,
    discover: r = "render",
    prefetch: n = "none",
    relative: o,
    reloadDocument: i,
    replace: a,
    state: s,
    target: l,
    to: u,
    preventScrollReset: c,
    viewTransition: f,
    ...m
  }, p) {
    let { basename: b } = H(je), _ = typeof u == "string" && Gs.test(u), v, w = !1;
    if (typeof u == "string" && _ && (v = u, Bs))
      try {
        let A = new URL(window.location.href), K = u.startsWith("//") ? new URL(A.protocol + u) : new URL(u), ee = Pe(K.pathname, b);
        K.origin === A.origin && ee != null ? u = ee + K.search + K.hash : w = !0;
      } catch {
        le(
          !1,
          `<Link to="${u}"> contains an invalid URL which will probably break when clicked - please update to a valid URL path.`
        );
      }
    let S = Qp(u, { relative: o }), [x, I, g] = jm(
      n,
      m
    ), C = Qm(u, {
      replace: a,
      state: s,
      target: l,
      preventScrollReset: c,
      relative: o,
      viewTransition: f
    });
    function D(A) {
      t && t(A), A.defaultPrevented || C(A);
    }
    let T = (
      // eslint-disable-next-line jsx-a11y/anchor-has-content
      /* @__PURE__ */ O(
        "a",
        {
          ...m,
          ...g,
          href: v || S,
          onClick: w || i ? t : D,
          ref: zm(p, I),
          target: l,
          "data-discover": !_ && r === "render" ? "true" : void 0
        }
      )
    );
    return x && !_ ? /* @__PURE__ */ O(Ct, null, T, /* @__PURE__ */ O(Um, { page: S })) : T;
  }
);
Ws.displayName = "Link";
var Vm = Je(
  function({
    "aria-current": t = "page",
    caseSensitive: r = !1,
    className: n = "",
    end: o = !1,
    style: i,
    to: a,
    viewTransition: s,
    children: l,
    ...u
  }, c) {
    let f = yr(a, { relative: u.relative }), m = pt(), p = H(mr), { navigator: b, basename: _ } = H(je), v = p != null && // Conditional usage is OK here because the usage of a data router is static
    // eslint-disable-next-line react-hooks/rules-of-hooks
    tg(f) && s === !0, w = b.encodeLocation ? b.encodeLocation(f).pathname : f.pathname, S = m.pathname, x = p && p.navigation && p.navigation.location ? p.navigation.location.pathname : null;
    r || (S = S.toLowerCase(), x = x ? x.toLowerCase() : null, w = w.toLowerCase()), x && _ && (x = Pe(x, _) || x);
    const I = w !== "/" && w.endsWith("/") ? w.length - 1 : w.length;
    let g = S === w || !o && S.startsWith(w) && S.charAt(I) === "/", C = x != null && (x === w || !o && x.startsWith(w) && x.charAt(w.length) === "/"), D = {
      isActive: g,
      isPending: C,
      isTransitioning: v
    }, T = g ? t : void 0, A;
    typeof n == "function" ? A = n(D) : A = [
      n,
      g ? "active" : null,
      C ? "pending" : null,
      v ? "transitioning" : null
    ].filter(Boolean).join(" ");
    let K = typeof i == "function" ? i(D) : i;
    return /* @__PURE__ */ O(
      Ws,
      {
        ...u,
        "aria-current": T,
        className: A,
        ref: c,
        style: K,
        to: a,
        viewTransition: s
      },
      typeof l == "function" ? l(D) : l
    );
  }
);
Vm.displayName = "NavLink";
var Km = Je(
  ({
    discover: e = "render",
    fetcherKey: t,
    navigate: r,
    reloadDocument: n,
    replace: o,
    state: i,
    method: a = Ar,
    action: s,
    onSubmit: l,
    relative: u,
    preventScrollReset: c,
    viewTransition: f,
    ...m
  }, p) => {
    let b = Zm(), _ = eg(s, { relative: u }), v = a.toLowerCase() === "get" ? "get" : "post", w = typeof s == "string" && Gs.test(s);
    return /* @__PURE__ */ O(
      "form",
      {
        ref: p,
        method: v,
        action: _,
        onSubmit: n ? l : (x) => {
          if (l && l(x), x.defaultPrevented)
            return;
          x.preventDefault();
          let I = x.nativeEvent.submitter, g = (I == null ? void 0 : I.getAttribute("formmethod")) || a;
          b(I || x.currentTarget, {
            fetcherKey: t,
            method: g,
            navigate: r,
            replace: o,
            state: i,
            relative: u,
            preventScrollReset: c,
            viewTransition: f
          });
        },
        ...m,
        "data-discover": !w && e === "render" ? "true" : void 0
      }
    );
  }
);
Km.displayName = "Form";
function Ym(e) {
  return `${e} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`;
}
function Vs(e) {
  let t = H(Lt);
  return U(t, Ym(e)), t;
}
function Qm(e, {
  target: t,
  replace: r,
  state: n,
  preventScrollReset: o,
  relative: i,
  viewTransition: a
} = {}) {
  let s = Jp(), l = pt(), u = yr(e, { relative: i });
  return ae(
    (c) => {
      if (Rm(c, t)) {
        c.preventDefault();
        let f = r !== void 0 ? r : dt(l) === dt(u);
        s(e, {
          replace: f,
          state: n,
          preventScrollReset: o,
          relative: i,
          viewTransition: a
        });
      }
    },
    [
      l,
      s,
      u,
      r,
      n,
      t,
      e,
      o,
      i,
      a
    ]
  );
}
var Xm = 0, Jm = () => `__${String(++Xm)}__`;
function Zm() {
  let { router: e } = Vs(
    "useSubmit"
    /* UseSubmit */
  ), { basename: t } = H(je), r = dm();
  return ae(
    async (n, o = {}) => {
      let { action: i, method: a, encType: s, formData: l, body: u } = Tm(
        n,
        t
      );
      if (o.navigate === !1) {
        let c = o.fetcherKey || Jm();
        await e.fetch(c, r, o.action || i, {
          preventScrollReset: o.preventScrollReset,
          formData: l,
          body: u,
          formMethod: o.method || a,
          formEncType: o.encType || s,
          flushSync: o.flushSync
        });
      } else
        await e.navigate(o.action || i, {
          preventScrollReset: o.preventScrollReset,
          formData: l,
          body: u,
          formMethod: o.method || a,
          formEncType: o.encType || s,
          replace: o.replace,
          state: o.state,
          fromRouteId: r,
          flushSync: o.flushSync,
          viewTransition: o.viewTransition
        });
    },
    [e, t, r]
  );
}
function eg(e, { relative: t } = {}) {
  let { basename: r } = H(je), n = H(Ue);
  U(n, "useFormAction must be used inside a RouteContext");
  let [o] = n.matches.slice(-1), i = { ...yr(e || ".", { relative: t }) }, a = pt();
  if (e == null) {
    i.search = a.search;
    let s = new URLSearchParams(i.search), l = s.getAll("index");
    if (l.some((c) => c === "")) {
      s.delete("index"), l.filter((f) => f).forEach((f) => s.append("index", f));
      let c = s.toString();
      i.search = c ? `?${c}` : "";
    }
  }
  return (!e || e === ".") && o.route.index && (i.search = i.search ? i.search.replace(/^\?/, "?index&") : "?index"), r !== "/" && (i.pathname = i.pathname === "/" ? r : Fe([r, i.pathname])), dt(i);
}
function tg(e, t = {}) {
  let r = H(ko);
  U(
    r != null,
    "`useViewTransitionState` must be used within `react-router-dom`'s `RouterProvider`.  Did you accidentally import `RouterProvider` from `react-router`?"
  );
  let { basename: n } = Vs(
    "useViewTransitionState"
    /* useViewTransitionState */
  ), o = yr(e, { relative: t.relative });
  if (!r.isTransitioning)
    return !1;
  let i = Pe(r.currentLocation.pathname, n) || r.currentLocation.pathname, a = Pe(r.nextLocation.pathname, n) || r.nextLocation.pathname;
  return Kr(o.pathname, a) != null || Kr(o.pathname, i) != null;
}
new TextEncoder();
const rg = he.createContext({
  stack: [],
  previousPath: null,
  canGoBack: !1
});
function ng({
  children: e,
  maxStackSize: t = 100
}) {
  const r = pt(), n = Xp(), [o, i] = be([]);
  se(() => {
    n === "PUSH" ? i((l) => [...l, r.pathname].slice(-t)) : n === "POP" ? i((l) => l.slice(0, -1)) : n === "REPLACE" && i((l) => [...l.slice(0, -1), r.pathname].slice(-t));
  }, [r, n, t]);
  const a = o.length > 1 ? o[o.length - 2] : null, s = o.length > 1;
  return /* @__PURE__ */ B.jsx(rg.Provider, { value: { stack: o, previousPath: a, canGoBack: s }, children: e });
}
function og({
  routes: e,
  prefix: t,
  errorElement: r,
  children: n
}) {
  const o = _e(() => {
    const i = `/${t == null ? void 0 : t.replace(/\/+/g, "/").replace(/^\/|\/$/g, "")}`, a = {
      element: /* @__PURE__ */ B.jsx(ng, { children: n }),
      children: e.map((s) => ({
        ...s,
        errorElement: s.errorElement || r || /* @__PURE__ */ B.jsx(ha, {})
      }))
    };
    return Bm([a], {
      basename: i
    });
  }, [e, t, r, n]);
  return /* @__PURE__ */ B.jsx(gm, { router: o });
}
const ig = ({ framework: e, designSystem: t }) => /* @__PURE__ */ B.jsx(Uh, { ...e, children: /* @__PURE__ */ B.jsx(og, { prefix: Nc, routes: $c, children: /* @__PURE__ */ B.jsx(Lc, { darkMode: t.darkMode, fetchKoenigLexical: null, children: /* @__PURE__ */ B.jsx(bm, {}) }) }) });
export {
  ig as AdminXApp
};
//# sourceMappingURL=stats.js.map
